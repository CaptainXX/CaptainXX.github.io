<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Linux," />










<meta name="description" content="鸟哥的Linux私房菜——学习笔记 本学习笔记是本人在鸟哥的Linux私房菜学习的全部笔记。 笔记内容自2018/07/13起按时间递增，最新的笔记将在最上方显示。   2018-8-13终于装好了双系统Ubuntu，从今天开始的笔记都在Ubuntu上用vim写吧～ 强行让自己习惯Linux的操作方式，不过Ubuntu的字体真的很好看啊。 碰到不少的坑，明天再开一篇来写一下遇到的坑，以备以后重装系">
<meta name="keywords" content="Linux">
<meta property="og:type" content="article">
<meta property="og:title" content="鸟哥的Linux私房菜">
<meta property="og:url" content="http://yoursite.com/2018/08/28/2018-07-17-VbirdLinuxBasic/index.html">
<meta property="og:site_name" content="CaptainX">
<meta property="og:description" content="鸟哥的Linux私房菜——学习笔记 本学习笔记是本人在鸟哥的Linux私房菜学习的全部笔记。 笔记内容自2018/07/13起按时间递增，最新的笔记将在最上方显示。   2018-8-13终于装好了双系统Ubuntu，从今天开始的笔记都在Ubuntu上用vim写吧～ 强行让自己习惯Linux的操作方式，不过Ubuntu的字体真的很好看啊。 碰到不少的坑，明天再开一篇来写一下遇到的坑，以备以后重装系">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://yoursite.com/images/Vbird/16-1.1.png">
<meta property="og:image" content="http://yoursite.com/images/Vbird/13-5.1.png">
<meta property="og:image" content="http://yoursite.com/images/Vbird/13-3.1.png">
<meta property="og:image" content="http://yoursite.com/images/Vbird/13-4.1.png">
<meta property="og:image" content="http://yoursite.com/images/Vbird/12-2.1.png">
<meta property="og:image" content="http://yoursite.com/images/Vbird/12-2.2.png">
<meta property="og:image" content="http://yoursite.com/images/Vbird/12-6.1.png">
<meta property="og:image" content="http://yoursite.com/images/Vbird/12-1.1.png">
<meta property="og:image" content="http://yoursite.com/images/Vbird/10-2.1.png">
<meta property="og:image" content="http://yoursite.com/images/Vbird/10-2.2.png">
<meta property="og:image" content="http://yoursite.com/images/Vbird/10-4.1.png">
<meta property="og:image" content="http://yoursite.com/images/Vbird/8-2.1.png">
<meta property="og:image" content="http://yoursite.com/images/Vbird/8-3.1.png">
<meta property="og:image" content="http://yoursite.com/images/Vbird/vim-commands.jpg">
<meta property="og:image" content="http://yoursite.com/images/Vbird/8-5.1.png">
<meta property="og:image" content="http://yoursite.com/images/Vbird/6-5.1.png">
<meta property="og:image" content="http://yoursite.com/images/Vbird/6-5.2.png">
<meta property="og:image" content="http://yoursite.com/images/Vbird/6-5.3.png">
<meta property="og:image" content="http://yoursite.com/images/Vbird/6-5.4.png">
<meta property="og:image" content="http://yoursite.com/images/Vbird/inode.jpg">
<meta property="og:image" content="http://yoursite.com/images/Vbird/7-1.1.png">
<meta property="og:image" content="http://yoursite.com/images/Vbird/7-1.2.png">
<meta property="og:image" content="http://yoursite.com/images/Vbird/7-1.3.png">
<meta property="og:image" content="http://yoursite.com/images/Vbird/7-1.4.png">
<meta property="og:image" content="http://yoursite.com/images/Vbird/7-1.5.png">
<meta property="og:image" content="http://yoursite.com/images/Vbird/7-3.1.png">
<meta property="og:image" content="http://yoursite.com/images/Vbird/7-3.2.png">
<meta property="og:image" content="http://yoursite.com/images/Vbird/7-3.4.png">
<meta property="og:image" content="http://yoursite.com/images/Vbird/7-5.1.png">
<meta property="og:image" content="http://yoursite.com/images/Vbird/7-6.1.png">
<meta property="og:image" content="http://yoursite.com/images/Vbird/5-3.1.png">
<meta property="og:image" content="http://yoursite.com/images/Vbird/5-3.2.png">
<meta property="og:image" content="http://yoursite.com/images/Vbird/6-1.1.png">
<meta property="og:image" content="http://yoursite.com/images/Vbird/6-1.2.png">
<meta property="og:image" content="http://yoursite.com/images/Vbird/6-1.4.png">
<meta property="og:image" content="http://yoursite.com/images/Vbird/6-1.3.png">
<meta property="og:image" content="http://yoursite.com/images/Vbird/6-1.5.png">
<meta property="og:image" content="http://yoursite.com/images/Vbird/6-1.6.png">
<meta property="og:image" content="http://yoursite.com/images/Vbird/6-1.7.png">
<meta property="og:image" content="http://yoursite.com/images/Vbird/6-1.8.png">
<meta property="og:image" content="http://yoursite.com/images/Vbird/6-1.9.png">
<meta property="og:image" content="http://yoursite.com/images/Vbird/6-1.10.png">
<meta property="og:image" content="http://yoursite.com/images/Vbird/6-2.1.png">
<meta property="og:image" content="http://yoursite.com/images/Vbird/6-2.2.png">
<meta property="og:image" content="http://yoursite.com/images/Vbird/6-2.3.png">
<meta property="og:image" content="http://yoursite.com/images/Vbird/6-2.4.png">
<meta property="og:image" content="http://yoursite.com/images/Vbird/6-2.5.png">
<meta property="og:image" content="http://yoursite.com/images/Vbird/6-2.6.png">
<meta property="og:image" content="http://yoursite.com/images/Vbird/6-2.7.png">
<meta property="og:image" content="http://yoursite.com/images/Vbird/6-2.8.png">
<meta property="og:image" content="http://yoursite.com/images/Vbird/6-2.9.png">
<meta property="og:image" content="http://yoursite.com/images/Vbird/6-2.10.png">
<meta property="og:image" content="http://yoursite.com/images/Vbird/6-2.11.png">
<meta property="og:image" content="http://yoursite.com/images/Vbird/6-2.12.png">
<meta property="og:image" content="http://yoursite.com/images/Vbird/6-2.13.png">
<meta property="og:image" content="http://yoursite.com/images/Vbird/6-2.14.png">
<meta property="og:image" content="http://yoursite.com/images/Vbird/6-2.15.png">
<meta property="og:image" content="http://yoursite.com/images/Vbird/6-2.16.png">
<meta property="og:image" content="http://yoursite.com/images/Vbird/6-2.18.png">
<meta property="og:image" content="http://yoursite.com/images/Vbird/6-2.17.png">
<meta property="og:image" content="http://yoursite.com/images/Vbird/6-4.1.png">
<meta property="og:image" content="http://yoursite.com/images/Vbird/6-4.2.png">
<meta property="og:image" content="http://yoursite.com/images/Vbird/6-4.3.png">
<meta property="og:image" content="http://yoursite.com/images/Vbird/6-4.4.png">
<meta property="og:image" content="http://yoursite.com/images/Vbird/5-2.1.png">
<meta property="og:image" content="http://yoursite.com/images/Vbird/5-2.2.png">
<meta property="og:image" content="http://yoursite.com/images/Vbird/5-2.3.png">
<meta property="og:image" content="http://yoursite.com/images/Vbird/5-2.4.png">
<meta property="og:updated_time" content="2018-08-13T08:15:38.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="鸟哥的Linux私房菜">
<meta name="twitter:description" content="鸟哥的Linux私房菜——学习笔记 本学习笔记是本人在鸟哥的Linux私房菜学习的全部笔记。 笔记内容自2018/07/13起按时间递增，最新的笔记将在最上方显示。   2018-8-13终于装好了双系统Ubuntu，从今天开始的笔记都在Ubuntu上用vim写吧～ 强行让自己习惯Linux的操作方式，不过Ubuntu的字体真的很好看啊。 碰到不少的坑，明天再开一篇来写一下遇到的坑，以备以后重装系">
<meta name="twitter:image" content="http://yoursite.com/images/Vbird/16-1.1.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"right","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2018/08/28/2018-07-17-VbirdLinuxBasic/"/>





  <title>鸟哥的Linux私房菜 | CaptainX</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-right page-post-detail">
    <div class="headband"></div>
    <a href="https://github.com/CaptainXX/CaptainXX.github.io" class="github-corner" aria-label="View source on Github"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">CaptainX</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/28/2018-07-17-VbirdLinuxBasic/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Xu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CaptainX">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">鸟哥的Linux私房菜</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-28T10:28:25+08:00">
                2018-08-28
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/notes/" itemprop="url" rel="index">
                    <span itemprop="name">notes</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  57,162 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  225 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="鸟哥的Linux私房菜——学习笔记"><a href="#鸟哥的Linux私房菜——学习笔记" class="headerlink" title="鸟哥的Linux私房菜——学习笔记"></a>鸟哥的Linux私房菜——学习笔记</h2><ul>
<li>本学习笔记是本人在<a href="http://linux.vbird.org/" target="_blank" rel="noopener">鸟哥的Linux私房菜</a>学习的全部笔记。</li>
<li>笔记内容自2018/07/13起按时间递增，最新的笔记将在最上方显示。</li>
</ul>
<hr>
<h3 id="2018-8-13"><a href="#2018-8-13" class="headerlink" title="2018-8-13"></a>2018-8-13</h3><p>终于装好了双系统Ubuntu，从今天开始的笔记都在Ubuntu上用vim写吧～</p>
<p>强行让自己习惯Linux的操作方式，不过Ubuntu的字体真的很好看啊。</p>
<p>碰到不少的坑，明天再开一篇来写一下遇到的坑，以备以后重装系统的时候吧……虽然完全不想再重装啦</p>
<h4 id="第二十二章-软件安装RPM-SRPM-YUM"><a href="#第二十二章-软件安装RPM-SRPM-YUM" class="headerlink" title="第二十二章 软件安装RPM SRPM, YUM"></a>第二十二章 软件安装RPM SRPM, YUM</h4><p>CentOS的RPM和Debian的dpkg</p>
<ul>
<li>dpkg</li>
</ul>
<p>最早是由Debian Linux社群开发的，通过dpkg就可以很简单地安装软件，同时可以提供安装后的软件信息。Ubuntu也是由Debian衍生出来的Linux distribution，所以也是支持dpkg的</p>
<ul>
<li>RPM (Red Hat Package Manager)</li>
</ul>
<p>由 Red Hat 公司开发出来的，很多 distribution 都在使用的非常方便的软件管理方式。</p>
<p>因为是已经编译好的软件，所以通常不同 distribution 释出的RPM不能安装在别的 distribution 上面</p>
<p>因此就有了SRPM，SRPM是PRM的源码，自己提供了 configure 和 Makefile, 可以修改参数设定文件，编译出适合正在使用的 distribution 的RPM 文件</p>
<p>SRPM用法：</p>
<ul>
<li>先将软件以RPM方式编译为RPM文件</li>
<li>再将这个RPM安装进系统中</li>
</ul>
<p>SRPM文件后缀：xxx.src.rpm</p>
<p>RPM文件名：</p>
<p>例：<code>rp-pppoe-3.11-5.el7.x86_64.rpm</code></p>
<p>文件名不同项目以-来分隔。</p>
<ul>
<li>软件名称：rp-pppoe</li>
<li>版本信息：3.11</li>
<li>释出版本的次数：5，同一版本中因为bug或是安全问题进行小幅度patch或重设编译参数，之后重新打包成RPM文件</li>
<li>操作硬件平台：<code>.el7.x86_64</code>,不同的平台设定参数也有所不同</li>
</ul>
<p>平台名称：</p>
<p>i386    适用所有的x86平台<br>i586    针对586等级的电脑进行最佳化编译<br>i686    目前市场的大部分都是这个等级的CPU<br>x86_64    针对64位的CPU最佳化编译<br>noarch    没有任何硬件等级的限制，一般是shell脚本软件</p>
<p>目前的软件大多是i686 x86_64 和 noarch版本，386可以在一些很特别的软件上面看到，硬件方面是向下兼容的。</p>
<p>RPM管理软件：<code>rpm</code></p>
<p>只有使用root权限才能操作rpm指令(Ubuntu里对应的是dpkg)</p>
<p><code>rpm -ivh package_name.rpm</code><br>-i    install    安装<br>-v    verbose    显示详细安装信息<br>-h    显示安装进度</p>
<p><code>rpm -U|F -vh pakage_name.rpm</code></p>
<p>升级更新软件：</p>
<p>-U    如果没有安装过后面的软件，则安装；如果有新版可用，则更新<br>-F    只有已经安装了的软件才会更新，不会自动安装未安装的软件</p>
<p><code>rpm qa</code>查询已经安装的软件</p>
<p><code>rpm q[licdR] [name]</code>查询已安装的软件名称</p>
<p><code>rpm qf [filename]</code></p>
<p><code>rpm -qp[licdR] [name]</code></p>
<p>-q    仅查询</p>
<p>-qa    列出所有软件名称</p>
<p>-qi    列出软件的详细信息</p>
<p>-ql    列出该软件的所有文件与目录所在完整文件名</p>
<p>-qc    列出该软件的所有设定文件</p>
<p>-qd    列出该软件的所有说明文件</p>
<p>-qR    列出与该软件有关的相依软件所含档案</p>
<p>-q –scripts    列出是否含有安装后需要执行的脚本文件</p>
<p>-p    packages 列出某个RPM文件</p>
<p>rpm命令和dpkg命令的对应：</p>
<p><code>rpm -q logrotate</code>    =    <code>dpkg --list logrotating</code></p>
<p><code>rpm -ql logrotate</code>    =    <code>dpkg --listfiles logrotate</code></p>
<p><code>rpm -V</code>验证数字签名</p>
<p><code>rpm -e</code>卸载</p>
<p><code>yum</code>线上升级</p>
<hr>
<h3 id="2018-8-8"><a href="#2018-8-8" class="headerlink" title="2018-8-8"></a>2018-8-8</h3><p>为什么使用make：</p>
<p><code>wget -nd http://linux.vbird.org/linux_basic/0520source/main.tgz</code></p>
<p>解压后获取四个C语言文件，用gcc编译</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">gcc -c main.c</span><br><span class="line">gcc -c haha.c</span><br><span class="line">gcc -c sin_value.c</span><br><span class="line">gcc -c cos_value.c</span><br><span class="line"></span><br><span class="line">gcc -o main main.o haha.o sin_value.o cos_value.o -lm</span><br></pre></td></tr></table></figure>
<p>使用make来编译，先建立名为makefile的文件：</p>
<p><code>vim makefile</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">main: main.o haha.o sin_value.o cos_value.o</span><br><span class="line">	gcc -o main main.o haha.o sin_value.o cos_value.o -lm</span><br></pre></td></tr></table></figure>
<p>Makefile语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Target: object1 object2</span><br><span class="line">&lt;tab&gt;	gcc -o binaryfile object1 object2</span><br><span class="line">&lt;tab&gt;	other commands</span><br></pre></td></tr></table></figure></p>
<p>make编译一次后，如果有更改源码，再重新进行一次make就可以更新binary文件了</p>
<p>环境变量：CFLAGS等</p>
<p>赋予方式：</p>
<ol>
<li><code>CFLAGS=&quot;-Wall&quot; make clean main</code></li>
<li>在makefile中加上<code>CFLAGS = -Wall</code></li>
<li>也可以直接读取当前shell环境的环境变量</li>
</ol>
<p>优先级：make命令中加入的 &gt; makefile中指定的 &gt; shell的环境变量</p>
<p>特殊变量：<code>$@</code>，在makefile中代表前面的Target</p>
<p>Tarball软件安装和管理</p>
<p>源码编译所需要的基础软件：</p>
<ul>
<li>gcc等编译器（C compiler）</li>
<li>make、autoconfig等软件</li>
<li>Kernel提供的函数库以及相关的Include文件，尤其是驱动程序需要的模组</li>
</ul>
<p>目前的Linux distribution预设一般是没有安装gcc或者make等软件的，CentO S或RedHat中可以选择Development Tools或是Kernel Source Development等软件包安装</p>
<p>CentOS和RedHat都可以使用RPM来安装软件，在有网络连接的情况下也可以使用yum来安装</p>
<p>yum有软件群组安装功能</p>
<ul>
<li>安装gcc等软件开发工具<code>yum groupinstall &quot;Development Tools&quot;</code></li>
<li>若待安装的软件需要图形界面支持<code>yum groupinstall &quot;X Software Development&quot;</code></li>
<li>若安装的软件较旧，可以<code>yum groupinstall &quot;Legacy Software Development&quot;</code></li>
</ul>
<p>具体在下一章有，下面还是来看Tarball</p>
<p>Tarball的安装流程：</p>
<ul>
<li>tar解压到/usr/local/src</li>
<li>进入目录，查询INSTALL文件或README文件</li>
<li>使用configure或config侦测环境，建立makefile</li>
<li>make编译</li>
<li>用make和Makefile的参数设定，依据install这个target来安装到正确的路径</li>
</ul>
<p>指令下达方式：</p>
<ul>
<li><code>./configure</code>，建立Makefile</li>
<li><code>make clean</code>，清除一下object file</li>
<li><code>make</code>依据Makefile中预设的工作进行编译。一般是编译产生object files</li>
<li><code>make install</code>最后的安装步骤，将上一步编译完成的文件安装到指定目录</li>
</ul>
<p>上述指令必须是依序进行的，如果上一步执行不成功，下一步也无法执行</p>
<p>软件安装常用目录：</p>
<p>以Apache为例：</p>
<ul>
<li>/etc/httpd</li>
<li>/usr/lib</li>
<li>/usr/bin</li>
<li>/usr/share/man</li>
</ul>
<p>内容大致在etc, lib, bin, man等目录中，分别对应设定文件，函数库，可执行文件，线上说明文件</p>
<p>如果你用Tarball来安装，放在/usr/local中，你的资料会放在：</p>
<ul>
<li>/usr/local/etc</li>
<li>/usr/local/bin</li>
<li>/usr/local/lib</li>
<li>/usr/local/man</li>
</ul>
<p>如果安装的软件多了的话，升级或是移除就比较难以查询文件来源，如果安装的单独的目录，就会在这个目录中创建 etc, bin, lib, man四个目录，如</p>
<ul>
<li>/usr/local/apache/etc</li>
<li>/usr/local/apache/bin</li>
<li>/usr/local/apache/lib</li>
<li>/usr/local/apache/man</li>
</ul>
<p>这样只要删除这个文件夹，就可以删除软件了，但是实际安装时，还是需要查看Makefile里面的install信息。</p>
<p>但是这样的操作虽然简化了删除，却会让命令下达时必须使用绝对路径。</p>
<p>在多个相依程序安装和更新上，使用Tarball也会面临更新一个程序就需要重新把所有相依程序都编译一遍的问题。</p>
<p>这就是使用Tarball弊端，在卸载上有一些难度，为了方便Tarball管理，鸟哥建议：</p>
<ul>
<li>将Tarball的源码解压到/usr/local/src目录中</li>
<li>安装时，最好安装到/usr/local这个预设路径下</li>
<li>考虑到未来的反安装，最好把每个软件单独在/usr/local安装</li>
<li>为安装到单独目录的软件的man page加入man path：<ul>
<li><code>vim /etc/man_db.conf</code></li>
<li><code>40G</code></li>
<li>添加<code>MANPATH_MAP /usr/local/software/bin /usr/local/software/man</code></li>
</ul>
</li>
</ul>
<p>INSTALL或README一定要仔细阅读，查看./configure的选项也很重要</p>
<p>利用patch更新源码</p>
<p><code>patch -pN &lt; patchfile</code>这个N指的是要更新的文件所在目录，与patchfile所在目录差几级</p>
<p>例如：要更新的文件绝对路径为 /home/guest/file2update</p>
<p>-p1 就表示 home/guest/file2update</p>
<p>-p2 就表示 guest/file2update</p>
<p>-p3 就表示file2update</p>
<p>函数库管理</p>
<p>动态Dynamic与静态Static函数库</p>
<p>静态函数库的特点：</p>
<ul>
<li>扩展名：<code>.a</code></li>
<li>编译行为：会直接整合到可执行文件中，因此会扩大可执行文件</li>
<li>可独立执行：编译后的可执行文件可以独立执行，不需要向外部要求读取函数库内容</li>
<li>升级较困难：函数库升级后，所有调用了此函数库的程序都要重新编译</li>
</ul>
<p>动态函数库的特点：</p>
<ul>
<li>扩展名：<code>.so</code></li>
<li>编译行为：程序里只有一个指针来指向函数库位置。程序使用到函数库时才会调用</li>
<li>不能被独立执行，需要有函数库的支持</li>
<li>升级函数库后不需要重新编译程序</li>
</ul>
<p>目前的Linux distribution大多使用动态函数库</p>
<p>大多数函数库的位置在：/lib64, /lib目录下，kernel的函数库放置在 /lib/modules里面</p>
<p>将动态函数库载入内存：</p>
<ol>
<li>在 /etc/ld.so.conf 里面加入需要载入内存的动态函数库所在目录</li>
<li><code>ldconfig</code>来将 /etc/ld.so.conf中的信息读入内存</li>
<li>同时记录一份资料在 /etc/ld.so.cache 中</li>
</ol>
<p><code>ldconfig [-f conf] [-C cache]</code></p>
<p>-f 以后面接的文件作为函数库的路径，而不是/etc/ld.so.conf</p>
<p>-C 以后就接的文件作为 内存的函数库资料，而不是 /etc/ld.so.cache</p>
<p><code>ldconfig [-p]</code></p>
<p>-p 列出目前有的所有函数库资料内容</p>
<p>查看程序的动态函数库或者查看和某个函数相关的其他函数库：</p>
<p><code>ldd [-vdr] filename</code></p>
<p>-v verbose</p>
<p>-d 重新将信息有遗失的link点显示出来</p>
<p>-r 将ELF有关的错误内容显示出来</p>
<p>验证软件的正确性：指纹验证。</p>
<p><code>md5sum / sha1sum / sha256sum [-bct] filename</code></p>
<p>-b 使用binary的读取方式，预设是 Windows/DOS文件形态的读取方式</p>
<p>-c 检验文件指纹</p>
<p>-t 以文字形式读取文件指纹</p>
<p><code>md5sum / sha1sum / sha256sum [--status|--warn] --check filename</code></p>
<p>你必须要在你的Linux上面为你的重要文件进行指纹资料库建立。</p>
<ul>
<li>/etc/passwd</li>
<li>/etc/shadow</li>
<li>/etc/group</li>
<li>/usr/bin/passwd</li>
<li>/sbin/rpcbind</li>
<li>/bin/login</li>
<li>/bin/ls</li>
<li>/bin/ps</li>
<li>/bin/top</li>
</ul>
<p>这几个文件最容易被修改了，建议建立MD5指纹库，定期以shell script的方式由程序来检查指纹是否正常</p>
<p>下面是我自己写的脚本</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment">#Program:</span></span><br><span class="line"><span class="comment"># 	This Program is used to  and check the MD5 prints of file: /etc/passwd /etc/shadow /etc/group /usr/bin/passwd /sbin/rpcbind /bin/login /bin/ls /bin/ps /bin/top</span></span><br><span class="line"><span class="comment"># History:</span></span><br><span class="line"><span class="comment"># 2018/08/08	Captainxu	First release</span></span><br><span class="line"></span><br><span class="line">PATH=/usr/<span class="built_in">local</span>/bin:/usr/<span class="built_in">local</span>/sbin:/usr/bin:/usr/sbin:/bin:/sbin:/home/captainxu/.<span class="built_in">local</span>/bin:/home/captainxu/bin</span><br><span class="line"><span class="built_in">export</span> PATH</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$0</span> start to funcion..."</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ ! -f /root/md5prints ];<span class="keyword">then</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="string">"This is the first time when this script is used!"</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="string">"A file named '/root/md5prints' will be established as the original data."</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="string">"This script will use this original data to compare the MD5 code of several important files."</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="string">"To make sure that your important files had not been changed by some bad guys."</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="string">"Creating files..."</span></span><br><span class="line">	touch /root/md5prints</span><br><span class="line">	<span class="keyword">for</span> file <span class="keyword">in</span> /etc/passwd /etc/shadow /etc/group /usr/bin/passwd /sbin/rpcbind /bin/login /bin/ls /bin/ps /bin/top</span><br><span class="line">	<span class="keyword">do</span></span><br><span class="line">		<span class="built_in">echo</span> $(md5sum <span class="variable">$&#123;file&#125;</span>) &gt;&gt; /root/md5prints</span><br><span class="line">	<span class="keyword">done</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="string">"DONE!"</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="string">"I advise you to add this script to your crontab, so that it can sostenuto check the files."</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	<span class="built_in">declare</span> -i i=1</span><br><span class="line">	<span class="keyword">for</span> file <span class="keyword">in</span> /etc/passwd /etc/shadow /etc/group /usr/bin/passwd /sbin/rpcbind /bin/login /bin/ls /bin/ps /bin/top</span><br><span class="line">	<span class="keyword">do</span></span><br><span class="line">		PRINT=$(md5sum <span class="variable">$&#123;file&#125;</span> | cut -d <span class="string">" "</span> -f1)</span><br><span class="line">		FILECONTENT=$(sed -n <span class="string">"<span class="variable">$&#123;i&#125;</span>,1p"</span> /root/md5prints | cut -d <span class="string">" "</span> -f1)</span><br><span class="line">		<span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;file&#125;</span>:"</span></span><br><span class="line">		<span class="built_in">echo</span> <span class="string">" original:	<span class="variable">$&#123;FILECONTENT&#125;</span>"</span></span><br><span class="line">		<span class="built_in">echo</span> <span class="string">" now:		<span class="variable">$&#123;PRINT&#125;</span>"</span></span><br><span class="line">		[ <span class="string">"<span class="variable">$PRINT</span>"</span> == <span class="string">"<span class="variable">$FILECONTENT</span>"</span>  ] &amp;&amp; <span class="built_in">echo</span> <span class="string">"<span class="variable">$file</span> is OK!"</span> || <span class="built_in">echo</span> <span class="string">"<span class="variable">$file</span> has bad md5!"</span></span><br><span class="line">		((i++))</span><br><span class="line">	<span class="keyword">done</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="2018-8-7"><a href="#2018-8-7" class="headerlink" title="2018-8-7"></a>2018-8-7</h3><p>累积备份和差异备份</p>
<p>完整累积备份</p>
<p>第一次完整备份后，就只备份与当前系统有差异的部分</p>
<p>使用dd, cpio, xfsdump/xfsrestore</p>
<p>完整差异备份</p>
<p>第一次完整备份后，就只备份与第一次备份有差异的部分</p>
<p>工具也可以使用上面列出的，还可以使用rsync来进行镜像备份</p>
<p><code>rsync -av sourcedir destination</code></p>
<p>例如将/home备份进/backupdata/home</p>
<p><code>rsync -av /home /backupdata</code>会在/backupdata自动创建一个/home子目录</p>
<p>关键资料备份：如果主机即使宕机一两天也不会影响你的正常生活，就可以仅备份关键资料</p>
<p>可以直接使用tar和date来处理：</p>
<p><code>tar -jpcvf mysql.$(date +%Y-%m-%d).tar.bz2 /var/lib/mysql</code></p>
<p>可以写一个脚本放入crontab</p>
<p>鸟哥的备份策略：</p>
<p>每日备份经常变动的数据，每周备份不常变动的数据</p>
<p>备份硬件：使用一个独立的filesystem，挂载到/backup中</p>
<p>每日进行：仅备份Mysql数据库</p>
<p>每周进行：/home, /var, /etc, /boot, /usr/local等目录与特殊服务的目录</p>
<p>使用crontab来自动进行</p>
<p>异地备份：每月定期把资料烧录到光碟或通过网络传给另一台机器</p>
<p>鸟哥的每月备份脚本</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># ====================================================================</span></span><br><span class="line"><span class="comment"># 使用者參數輸入位置：</span></span><br><span class="line"><span class="comment"># basedir=你用來儲存此腳本所預計備份的資料之目錄(請獨立檔案系統)</span></span><br><span class="line">basedir=/backup/weekly  &lt;==您只要改這裡就好了！</span><br><span class="line"></span><br><span class="line"><span class="comment"># ====================================================================</span></span><br><span class="line"><span class="comment"># 底下請不要修改了！用預設值即可！</span></span><br><span class="line">PATH=/bin:/usr/bin:/sbin:/usr/sbin; <span class="built_in">export</span> PATH</span><br><span class="line"><span class="built_in">export</span> LANG=C</span><br><span class="line"></span><br><span class="line"><span class="comment"># 設定要備份的服務的設定檔，以及備份的目錄</span></span><br><span class="line">named=<span class="variable">$basedir</span>/named</span><br><span class="line">postfixd=<span class="variable">$basedir</span>/postfix</span><br><span class="line">vsftpd=<span class="variable">$basedir</span>/vsftp</span><br><span class="line">sshd=<span class="variable">$basedir</span>/ssh</span><br><span class="line">sambad=<span class="variable">$basedir</span>/samba</span><br><span class="line">wwwd=<span class="variable">$basedir</span>/www</span><br><span class="line">others=<span class="variable">$basedir</span>/others</span><br><span class="line">userinfod=<span class="variable">$basedir</span>/userinfo</span><br><span class="line"><span class="comment"># 判斷目錄是否存在，若不存在則予以建立。</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">dirs</span> <span class="keyword">in</span> <span class="variable">$named</span> <span class="variable">$postfixd</span> <span class="variable">$vsftpd</span> <span class="variable">$sshd</span> <span class="variable">$sambad</span> <span class="variable">$wwwd</span> <span class="variable">$others</span> <span class="variable">$userinfod</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">	[ ! -d <span class="string">"<span class="variable">$dirs</span>"</span> ] &amp;&amp; mkdir -p <span class="variable">$dirs</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 將系統主要的服務之設定檔分別備份下來，同時也備份 /etc 全部。</span></span><br><span class="line">cp -a /var/named/chroot/&#123;etc,var&#125;	<span class="variable">$named</span></span><br><span class="line">cp -a /etc/postfix /etc/dovecot.conf	<span class="variable">$postfixd</span></span><br><span class="line">cp -a /etc/vsftpd/*			<span class="variable">$vsftpd</span></span><br><span class="line">cp -a /etc/ssh/*			<span class="variable">$sshd</span></span><br><span class="line">cp -a /etc/samba/*			<span class="variable">$sambad</span></span><br><span class="line">cp -a /etc/&#123;my.cnf,php.ini,httpd&#125;	<span class="variable">$wwwd</span></span><br><span class="line"><span class="built_in">cd</span> /var/lib</span><br><span class="line">  tar -jpc -f <span class="variable">$wwwd</span>/mysql.tar.bz2 	mysql</span><br><span class="line"><span class="built_in">cd</span> /var/www</span><br><span class="line">  tar -jpc -f <span class="variable">$wwwd</span>/html.tar.bz2 	html cgi-bin</span><br><span class="line"><span class="built_in">cd</span> /</span><br><span class="line">  tar -jpc -f <span class="variable">$others</span>/etc.tar.bz2	etc</span><br><span class="line"><span class="built_in">cd</span> /usr/</span><br><span class="line">  tar -jpc -f <span class="variable">$others</span>/local.tar.bz2	<span class="built_in">local</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 關於使用者參數方面</span></span><br><span class="line">cp -a /etc/&#123;passwd,shadow,group&#125;	<span class="variable">$userinfod</span></span><br><span class="line"><span class="built_in">cd</span> /var/spool</span><br><span class="line">  tar -jpc -f <span class="variable">$userinfod</span>/mail.tar.bz2	mail</span><br><span class="line"><span class="built_in">cd</span> /</span><br><span class="line">  tar -jpc -f <span class="variable">$userinfod</span>/home.tar.bz2	home</span><br><span class="line"><span class="built_in">cd</span> /var/spool</span><br><span class="line">  tar -jpc -f <span class="variable">$userinfod</span>/cron.tar.bz2	cron at</span><br></pre></td></tr></table></figure>
<p>使用<code>wget -nd http://linux.vbird.org/linux_basic/0580backup/backupwk-0.1.sh</code>也可以获取</p>
<p>对MySQL数据库的每日备份脚本：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># =========================================================</span></span><br><span class="line"><span class="comment"># 請輸入，你想讓備份資料放置到那個獨立的目錄去</span></span><br><span class="line">basedir=/backup/daily/  &lt;==你只要改這裡就可以了！</span><br><span class="line"></span><br><span class="line"><span class="comment"># =========================================================</span></span><br><span class="line">PATH=/bin:/usr/bin:/sbin:/usr/sbin; <span class="built_in">export</span> PATH</span><br><span class="line"><span class="built_in">export</span> LANG=C</span><br><span class="line">basefile1=<span class="variable">$basedir</span>/mysql.$(date +%Y-%m-%d).tar.bz2</span><br><span class="line">basefile2=<span class="variable">$basedir</span>/cgi-bin.$(date +%Y-%m-%d).tar.bz2</span><br><span class="line">[ ! -d <span class="string">"<span class="variable">$basedir</span>"</span> ] &amp;&amp; mkdir <span class="variable">$basedir</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. MysQL (資料庫目錄在 /var/lib/mysql)</span></span><br><span class="line"><span class="built_in">cd</span> /var/lib</span><br><span class="line">  tar -jpc -f <span class="variable">$basefile1</span> mysql</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. WWW 的 CGI 程式 (如果有使用 CGI 程式的話)</span></span><br><span class="line"><span class="built_in">cd</span> /var/www</span><br><span class="line">  tar -jpc -f <span class="variable">$basefile2</span> cgi-bin</span><br></pre></td></tr></table></figure></p>
<p>也可以<code>wget -nd http://linux.vbird.org/linux_basic/0580backup/backupday.sh</code>获取</p>
<p>将脚本加入crontab就可以定期自动进行备份了</p>
<p>两台Linux之间通过网络备份数据：</p>
<p><code>rsync -av -e ssh basedir id@ip:remotedir</code></p>
<p>问题（犯蠢）记录：</p>
<p>在做鸟哥课后练习中，备份现有系统再重装一台CentOS 7，之后用备份的CentOS 7恢复到新装的机器中。</p>
<p>当我重启原来的机器时，发现无法顺利开机，在图形画面的读条界面停止，之后自动进入救援模式。</p>
<p>显示错误：</p>
<ol>
<li>[sda] Assuming drive cache: write through</li>
<li>Host SMBus controller not enabled</li>
</ol>
<p>第一个问题在开机时grub界面按<code>e</code>，删除 rhgb(图形进度条模式) 和 quiet(方便Debug)</p>
<p>第二个问题在/etc/modprobe.d/blacklist.conf文件中，添加<code>blacklist i2c_piix4</code></p>
<p>两个问题即可解决</p>
<p>但是重启之后还是不能顺利开机，问题完全没有解决。</p>
<p>后来在/etc/fstab中发现，我之前删除了RAID磁盘序列，并且将磁盘重新分出一个区来挂载到/backup，而原来的RAID自动挂载的命令没有删除。</p>
<p>解决方法：<code>vim /etc/fstab</code>，注释掉或者删除挂载RAID的行，重启，顺利开机！</p>
<p>总结：多查看系统日志信息，查看详细的开机日志。</p>
<h4 id="第二十一章-软件安装：源码与Tarball"><a href="#第二十一章-软件安装：源码与Tarball" class="headerlink" title="第二十一章 软件安装：源码与Tarball"></a>第二十一章 软件安装：源码与Tarball</h4><p>可执行文件：一般是指二进制文件</p>
<p>使用<code>file /bin/bash</code>命令可以查看文件的类型到底是什么</p>
<p>二进制文件会显示 ELF 64-bit LSB executable</p>
<p>而脚本文件会显示 text executable（因为开头一行写了#!/bin/bash）</p>
<p>Linux标准的程序语言是C，可以使用C来编写程序源码，然后使用gcc来编译，就可以制作一个Binary program了。</p>
<p>编译过程中会产生后缀为<code>.o</code>的目标文件(object file)，C语言源码一般后缀为<code>.c</code></p>
<p>Linux自带函数库：分为动态函数库和静态函数库</p>
<p>Linux核心就提供了很多核心相关的函数库，相关信息在 /usr/include, /usr/lib, /usr/lib64中</p>
<p><code>make</code>会在目录下讯在Makefile文件，这个文件中记录了源码如何编译的详细信息。</p>
<p>软件开发商一般会写一个侦测程序来侦测使用者的系统环境，来查看环境中是否有开发商所需要的功能，侦测程序运行结束后，就会主动建立Makefile，一般这个程序叫做<code>configure</code> <code>config</code></p>
<p>一般侦测程序会检查：</p>
<ul>
<li>是否有合适的编译器可以编译程序源码</li>
<li>是否已经存在本软件需要的函数库或其他相依软件</li>
<li>操作系统是否适合本软件，包括kernel版本</li>
<li>核心的头文件是否存在(header include)(驱动程序必须要的侦测)</li>
</ul>
<p>编译流程基本就是两部：</p>
<ul>
<li>configure（一定要成功）</li>
<li>make</li>
</ul>
<p>Tarball软件</p>
<p>就是将源码以tar打包，再压缩</p>
<p>里面的文件一般包含：</p>
<ul>
<li>源码</li>
<li>侦测程序</li>
<li>软件说明和安装说明</li>
</ul>
<p>更新软件的需求：</p>
<ul>
<li>需要新版功能</li>
<li>安全问题补丁</li>
<li>执行效率升级</li>
</ul>
<p>更新软件的方式:</p>
<ul>
<li>通过源码编译来安装</li>
<li>通过编译好的二进制文件来安装</li>
</ul>
<p>预先编译好程序再释出的机制在很多distribution中都有，如</p>
<p>Red Hat系统发展的RPM软件管理机制与yum线上更新模式</p>
<p>Debian使用的dpkg软件管理机制和apt线上更新模式</p>
<p>CentOS是依据标准的Linux distribution，可以使用Tarball或RPM来进行升级</p>
<p>安装Tarball的过程：</p>
<ul>
<li>下载<code>*.tar.gz</code>文件</li>
<li>解开打包，得到源码</li>
<li>使用gcc编译源码，产生object file</li>
<li>使用gcc来进行函数库、主程序、副程序连接，形成主要的二进制文件</li>
<li>将上述的二进制文件及设定档安装在主机上</li>
</ul>
<p>3、4步可以使用make来简化</p>
<p>C语言程序设计(Linux环境)：</p>
<p><code>yum groupinstall &quot;Development Tools&quot;</code>安装gcc等软件</p>
<p><code>vim hello.c</code>创建C文件</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Hello World\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译这个hello world<code>gcc hello.c</code></p>
<p>产生<code>a.out</code>文件</p>
<p><code>./a.out</code>运行</p>
<p>编译产生hello.o文件<code>gcc -c hello.c</code></p>
<p><code>gcc -o hello hello.o</code>产生可执行文件</p>
<p>主、副程序的连接</p>
<p>如果在一个程序中引用了另一个程序：</p>
<p><code>vim thanks.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Hello World\n"</span>);</span><br><span class="line">    thanks_2();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>vim thanks_2.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thanks_2</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Thank you!\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>进行程序的编译<code>gcc -c thanks.c thanks_2.c</code></p>
<p>连接目标文件<code>gcc -o thanks thanks.o thanks_2.o</code></p>
<p>产生二进制文件 thanks，运行输出 Hello world thanke you !</p>
<p>在编译过程中，可以加入参数来使用gcc的不同功能</p>
<p><code>gcc -O -c thanks.c</code> -O为产生最佳化的参数</p>
<p><code>gcc -Wall -c thanks.c</code> -Wall 会在编译过程中显示Debug信息(Warnings Errors)</p>
<p><code>gcc sin.c -lm -L/lib -L/lib64</code></p>
<p>-l    表示加入某个函数库<br>m    表示libm.so这个函数库<br>-L    表示到后面接的目录去寻找函数库</p>
<p><code>gcc sin.c -lm -I/usr/include</code> -I后面接的目录的要去搜寻的目录</p>
<p>总结：（gcc 的简易用法）</p>
<p>编译：<code>gcc -c hello.c</code>产生目标文件</p>
<p>最佳化编译：<code>gcc -O -c hello.c</code></p>
<p>添加寻找函数的路径：<code>gcc sin.c -lm -L/lib -I/usr/include</code></p>
<p>将编译结果输出为特定的文件名：<code>gcc -o hello hello.c</code></p>
<p>输出Debug信息：<code>gcc -Wall -o hello hello.c</code></p>
<p>更多功能可以<code>man gcc</code></p>
<p>看到 21.3使用make进行编译</p>
<hr>
<h3 id="2018-8-6"><a href="#2018-8-6" class="headerlink" title="2018-8-6"></a>2018-8-6</h3><p>模组载入</p>
<p>建议使用<code>modprobe</code>来载入模组，它会自动克服模组的相依性，再决定需要载入哪些模组</p>
<p><code>insmod</code>完全是由用户来载入一个完整的模组，不能主动分析相依性</p>
<p><code>insmod [/full/path/module_name][parameters]</code></p>
<p><code>rmmod [-fw] module_name</code></p>
<p>-f    强制移除该模组，无论是否正在被使用</p>
<p><code>modprobe [-cfr] module_name</code></p>
<p>-c    列出目前系统所有的模组</p>
<p>-f    强制载入该模组</p>
<p>-r    类似rmmod，移除模组</p>
<p>19-3    Boot loader: Grub2</p>
<p>Linux将boot loader的程序码执行和设定载入分成了两个stage</p>
<ol>
<li>执行boot loader主程序</li>
</ol>
<p>因为MBR实在太小，所以MBR或boot sector通常只安装主程序</p>
<ol start="2">
<li>主程序载入设定文件</li>
</ol>
<p>设定文件一般都在/boot下</p>
<p><code>ll /boot/grub2</code></p>
<p>grub2的优点：</p>
<ul>
<li>支持较多文件系统</li>
<li>开机时可以自行编辑与修改开机设定项目</li>
<li>可以动态搜索设定文件，不需要在修改设定后重新安装grub2</li>
</ul>
<p>磁盘与分区在grub2中的代号</p>
<p>(hd0, 1)         # 自动判断格式</p>
<p>(hd0, msdos) # MBR模式</p>
<p>(hd0, gpt1)     # GPT模式</p>
<p>搜索到的第一个磁盘编号为hd0</p>
<p>第一个分区编号为1，分 MBR GPT 分别标注</p>
<p>查看grub2的设定文件<code>cat /boot/grub2/grub.cfg</code></p>
<p>主要环境设定文件<code>cat /etc/default/grub</code></p>
<p>TIMEOUT        预设倒数读秒的秒数</p>
<p>DISTRIBUTOR    </p>
<p>DEFAULT        预设开机选单，使用哪一个选单则添加相关的数字，从0开始编号</p>
<p>DISABLE_SUBMENU    是否隐藏次选单</p>
<p>TERMINAL_OUTPUT    指定信息输出的终端机格式</p>
<p>CMDLINE_LINUX        在menuentry括号内的LINUX16项目后续的核心参数</p>
<p>DISABLE_RECOVERY    取消救援选单的制作</p>
<p>编辑完主要环境设定档后，使用<code>grub2-mkconfig</code>来重建grub.cfg</p>
<p>选单的建立目录</p>
<p><code>ll /etc/grub.d</code></p>
<p>menuentry选单的功能：</p>
<ul>
<li>直接指定核心开机</li>
</ul>
<p>默认通过10_linux脚本制作，想添加别的参数，可以先到grub.cfg中复制相关的选单项目，粘贴到40_custom中，在custom文档中修改</p>
<p>通过chain loader移交loader控制权</p>
<p>例如要将控制权交给Windows的loader，只有一个磁盘，且Windows的分区在/dev/sda1，那么可以这样写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">menuentry &quot;Windows&quot;&#123;</span><br><span class="line">    insmod chain # 载入chainloader模组</span><br><span class="line">    insmod ntfs # 载入Windows所在的文件系统</span><br><span class="line">    set root=(hd0,1) # Windows所在分区号</span><br><span class="line">    chainloader +1 # 去boot sector读取loader</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>initramfs必要的时刻</p>
<ul>
<li>根目录磁盘为SATA、USB、SCSI等连接界面</li>
<li>根目录文件系统为LVM，RAID等特殊格式</li>
<li>根目录文件系统为非传统Linux认识的文件系统</li>
<li>其他必须要在核心载入时提供的模组</li>
</ul>
<p>重制initramfs</p>
<p><code>dracut [-fv] [--add-drivers 列表] initramfs文件名 核心版本</code></p>
<p>-f    强制编译处initramfs，如果已经存在，则覆盖</p>
<p>-v    显示dracut的运行过程</p>
<p>–add-drivers 列表    在原本预设的核心模组中添加你想要的模组</p>
<p>initramfs文件名        设置文件名，开头最好是initramfs，后面接版本和功能</p>
<p>核心版本        一般是目前运行的版本（uname -r）</p>
<p>–modules    将dracut提供的核心模组载入，<code>/usr/lib/dracut/modules.d/</code>下为可用模组</p>
<p>–gzip|–bzip|–xz    使用某种方式来压缩initramfs，默认gzip</p>
<p>–filesystems    加入某些额外的文件系统</p>
<p>测试与安装grub2</p>
<p>如果没有预装grub2，可以安装</p>
<p><code>grub2-install [--boot-directory=DIR] INSTALL_DEVICE</code></p>
<p>–boot-directory    指定DIR为目标目录，默认目录为/boot/grub2/*</p>
<p>INSTALL_DEVICE    安装的装置代号（要安装在哪个磁盘的MBR下）</p>
<p><code>grub2-install /dev/sda</code></p>
<p>重装之后，/boot/grub2/下的目录都更新了，但是也没有设定文件，需要自己建立</p>
<p><code>grub2-mkconfig -o /boot/grub2/grub.cfg</code></p>
<p>重启时在grub2选单按下e，可以查看选中的选单的设置，并且可以直接编辑</p>
<p>在linux16那一行加入 <code>systemd.unit=rescue.target</code>再按下^X来进入系统，就可以进入救援模式</p>
<p>在systemd使用时，进入救援模式也需要root密码，要是忘记了root密码</p>
<p>通过图形显示grub：</p>
<p>在/etc/default/grub中加入</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GRUB_TERMINAL=gfxterm</span><br><span class="line">GRUB_GFXMODE=1024x768x24</span><br><span class="line">GRUB_GFXPAYLOAD_LINUX=keep</span><br></pre></td></tr></table></figure>
<p>grub2账户密码与选单设定</p>
<p>superusers    相当于root，选单的修改受限</p>
<p>users        设定一般账户的相关参数和密码</p>
<p>在 grub.cfg中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">set superusers=&quot;captain&quot;</span><br><span class="line">password captain qwertyuiop</span><br><span class="line">password mortal1 123456</span><br><span class="line">menuentry &quot;Everyone&quot; --unrestricted&#123;</span><br><span class="line">    set root=(hd0,1)</span><br><span class="line">    chainloader +1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">menuentry &quot;Only superusers&quot; --users&quot;&quot;&#123;</span><br><span class="line">    set root=(hd0,2)</span><br><span class="line">    chainloader +1</span><br><span class="line">&#125;</span><br><span class="line">menuentry &quot;Only mortal and captain&quot; --users mortal&#123;</span><br><span class="line">    set root=(hd0,3)</span><br><span class="line">    chainloader +1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>生成加密的密码：</p>
<p><code>grub2-mkpasswd-pbkdf2</code></p>
<p><code>vim /etc/grub.d/01_users</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">EOF</span><br><span class="line">cat &lt;&lt; EOF</span><br><span class="line">set superusers=&quot;captain&quot;</span><br><span class="line">password_dbkdf2 captain grub.pbkdf2.sha512.10000.25376F4AF885B82064982E056C67432832D39923A95D42EF33EA671212D3EF6F7FA1EB769EB9C482B504762422C2CE7DC00A5FB3220A52AD30567FAE712F45BE.DE5D23698DCB96F1381B713B5E772D122E519286371DBB5DB08FF1999263C95D1598D2F8ED7C1B7D620F4E253579B6ABC4ABEEEC8A469DF8C6EEFC9340E5CD7E</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure></p>
<p>19-4    开机过程的问题解决</p>
<p>通过rd.break核心参数来重设root密码（忘记了密码时）</p>
<p>在重启画面中，按e进入编辑模式，在linux16项目下添加 rd.break，按下^X开机</p>
<p>进入RAM Disk环境，就直接取得了root权限</p>
<p>mount查看sysroot的挂载点</p>
<p><code>mount -o remount,rw /sysroot</code>挂载为可读写</p>
<p><code>chroot /sysroot</code>切换根目录的位置到/sysroot</p>
<p><code>echo &quot;your passswd&quot; | passwd --stdin root</code>更改密码</p>
<p><code>touch /.autorelabel</code> 变回SELinux的安全本文</p>
<p>exit</p>
<p>reboot</p>
<h4 id="第二十章-基础系统设置与备份策略"><a href="#第二十章-基础系统设置与备份策略" class="headerlink" title="第二十章 基础系统设置与备份策略"></a>第二十章 基础系统设置与备份策略</h4><p>网络设定</p>
<p>获取网络参数</p>
<p>手动设定参数</p>
<ul>
<li>IP</li>
<li>子网掩码 netmask</li>
<li>网关 gateway</li>
<li>DNS服务器的IP　168.95.1.1</li>
</ul>
<p>自动获取参数DHCP</p>
<p>以太网卡 Ethernet ethN</p>
<p>新的CentOS7对网卡编号为：</p>
<ul>
<li>eno1    主板BIOS内建的网卡</li>
<li>ens1        主板BIOS内建的PCI-E网卡</li>
<li>enp2s0    PCI-E界面的独立网卡</li>
<li>eth0          以上网卡以外的</li>
</ul>
<p><code>nmcli connection show</code>显示当前系统上预设的网卡代号和连线代号</p>
<p>设置网络参数</p>
<p><code>nmcli connection modify ens33 \</code></p>
<p><code>connection.autoconnect yes\</code></p>
<p><code>ipv4.method manual\</code></p>
<p><code>ipv4.addresses 172.16.1.1/16\</code></p>
<p><code>ipv4.gateway 172.16.200.254\</code></p>
<p><code>ipv4.dns 172.16.200.254</code></p>
<p><code>nmcli connection up ens33</code>激活ens33</p>
<p>自动取得IP</p>
<p><code>nmcli connection modify ens33 connection.autoconnect yes ipv4.method auto</code></p>
<p><code>nmcli connection up ens33</code></p>
<p>就好了</p>
<p>修改主机名称：</p>
<p><code>hostnamectl [set-hostname 主机名]</code></p>
<p>日期与时间设定：</p>
<p><code>timedatectl [command]</code></p>
<p>list-timezones    列出系统上所以支持的时区名称</p>
<p>set-timezone        设定时区</p>
<p>set-time            设定时间</p>
<p>set-ntp            设定网络校时系统</p>
<p>手动网络校时:</p>
<p><code>ntpdate ntp1.aliyun.com</code>和阿里云服务器同步</p>
<p><code>hwclokcl -w</code>写入BIOS</p>
<p>语系设定：</p>
<p><code>localectl</code></p>
<p><code>export LC_ALL=en_US.utf8</code>切换为英文</p>
<p><code>localectl set-locale LANG=en_US.utf8</code>设置为英文</p>
<p>防火墙简易设定（详细设定见服务器篇）：</p>
<p>服务</p>
<p>端口</p>
<p>获取服务器的硬件信息</p>
<p><code>dmidecode -t type</code></p>
<p>type:</p>
<p>1    详细系统资料</p>
<p>4    CPU相关资料</p>
<p>9    系统的相关插槽格式</p>
<p>17    每一个内存插槽的规格</p>
<p>硬件设置都被记录在了/proc和/sys中了</p>
<p>呼叫硬件的指令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">gdisk	分区列表</span><br><span class="line">dmesg	查看核心工作过程中显示的信息记录</span><br><span class="line">vmstat	分析系统目前状态</span><br><span class="line">lspci	列出PCI接口的设备</span><br><span class="line">lsusb	列出USB端口的状态和USB设备</span><br><span class="line">iostat	和vmstat类似，可以即时分析</span><br></pre></td></tr></table></figure>
<p><code>lspci [-vvn]</code></p>
<p>-v    显示更多信息</p>
<p>-vv    更加多信息</p>
<p>-n    直接观察PCI的ID</p>
<p>更新pci的文件档案：</p>
<p><code>update-pciids</code></p>
<p><code>lsusb -t</code></p>
<p><code>iostat [-c|-d] [-k|-m] [-t] 间隔秒数 侦测次数</code></p>
<p>-c    仅显示CPU信息</p>
<p>-d    仅显示存储设备的状态</p>
<p>-k    以KB为单位显示</p>
<p>-m    以MB为单位显示</p>
<p>-t    显示日期</p>
<p>如果有设置次数，那么第一个显示的是开机到现在的总数量</p>
<p>了解磁盘的健康状态：</p>
<p><code>smartd</code>服务【Self-Monitoring，Analysis and Reporting Technology System】</p>
<p><code>smartctl -a /dev/sda</code>显示sda的信息</p>
<p><code>smartctl -t short /dev/sda</code>让设备进行一次自检</p>
<p>备份要点</p>
<p>备份因素考量：</p>
<ul>
<li>备份哪些档案</li>
<li>选择什么媒体</li>
<li>备份的方式</li>
<li>备份的频率</li>
<li>备份的工具</li>
</ul>
<p>具有备份意义的文件：</p>
<ul>
<li>系统基本设定</li>
<li>网络服务的文件</li>
</ul>
<p>文件系统本身需要备份的档案：</p>
<ul>
<li>/etc/passwd</li>
<li>/etc/shadow</li>
<li>/etc/group</li>
<li>/etc/gshadow</li>
<li>/home</li>
</ul>
<p>Linux的重要参数文件都在/etc/下，所以只要备份这个目录，就可以备份几乎所以的设定文件</p>
<p>/var/spool/mail    的内容也值得备份</p>
<p>设定过的文件夹：</p>
<ul>
<li>/var/spool/(at|cron)</li>
<li>/boot</li>
<li>/root</li>
<li>如果安装过其他软件，/usr/local和/opt也应该备份</li>
</ul>
<p>网络服务的数据库：</p>
<p>如果我们使用的软件都是远程RPM安装的，需要备份的资料有：</p>
<ul>
<li>软件本身的设定文件</li>
<li>软件提供的服务信息<ul>
<li>WWW信息：/var/www目录，/srv/www目录，用户家目录等</li>
<li>Mariadb：/var/lib/mysql目录</li>
</ul>
</li>
<li>其他在Linux主机上面提供服务的数据库文件</li>
</ul>
<p>如果因为经费有限等原因，至少需要备份下列目录</p>
<ul>
<li>/etc</li>
<li>/home</li>
<li>/root</li>
<li>/var/spool/mail</li>
<li>/var/spool/cron</li>
<li>/var/spool/at</li>
<li>/var/lib</li>
</ul>
<p>不需要备份的目录：</p>
<ul>
<li>/dev</li>
<li>/proc, /sys, /run</li>
<li>/mnt, /media</li>
<li>/tmp</li>
</ul>
<p>备份媒体的选择：</p>
<p>经费充足的情况下，可以使用外接式NAS设备</p>
<p>经费不足的情况下，可以使用磁盘来备份</p>
<p>看到20.4 备份的种类、频率与工具的选择</p>
<hr>
<h3 id="2018-8-2"><a href="#2018-8-2" class="headerlink" title="2018-8-2"></a>2018-8-2</h3><p>CentOS 7.x的initramfs 文件内容</p>
<p><code>sudo lsinitrd /boot/initramfs-3.10.0-862.el7.x86_64.img</code></p>
<p>可以看见init确实被systemd取代了</p>
<p>要解开此文件，先要去除前面的 kernel/x86/microcode/GenuineIntel.bin之前的文件</p>
<ol>
<li>获取需要去除的容量：</li>
</ol>
<p><code>sudo cpio -i -d --no-absolute-filenames -I /boot/initramfs-3.10.0-862.el7.x86_64.img</code></p>
<p>结果 192blocks，容量=192*512=98304B</p>
<ol start="2">
<li>将不需要的档案头文件部分去除</li>
</ol>
<p><code>sudo dd if=/boot/initramfs-3.10.0-862.el7.x86_64.img of=initramfs.gz bs=98304 skip=1</code></p>
<ol start="3">
<li>解压产生的文件</li>
</ol>
<p><code>gzip -d initramfs.gz</code></p>
<p>产生了新的cpio文件，再用cpio解开</p>
<p><code>cpio -d -i -H newc --no-absolute-filenames &lt; initramfs</code></p>
<p>解压后<code>ll</code>发现几乎产生了一个小型的根目录，这样就可以让kernel挂载了</p>
<p>核心载入完成后，主机硬件就准备就绪了，此时核心会呼叫systemd作为第一支程式。</p>
<p>systemd通过预设的/etc/systemd/system/default.target 来规划准备软件的使用环境</p>
<p>预设的操作环境：</p>
<p>multi-user.target 和 graphical.target两个</p>
<p>systemd为了和systemV的操作行为兼容，将runlevel与系统操作环境做了结合</p>
<p><code>ll -d /usr/lib/systemd/system/runlevel*.target | cut -c 28-</code></p>
<p>init 0    = systemctl poweroff</p>
<p>init 1     = systemctl rescue</p>
<p>init 2-4     = systemctl isolate multi-user.target</p>
<p>init 5    = systemctl isolate graphical.target</p>
<p>init 6    = systemctl reboot</p>
<p>/etc/systemd/system/graphical.target.wants     使用者设定载入的wants</p>
<p>/usr/lib/systemd/system/graphical.target.wants    系统预设载入的wants</p>
<p>systemd的开机流程：</p>
<p> 1    local-fs.target + swap.target：挂载本机 /etc/fstab 里面所规范的文件系统与内存交换空间</p>
<p>2    sysinit.target ：侦测硬件，载入所需要的核心模组等</p>
<p>3    basic.target：载入主要的周边硬件驱动与防火墙相关的服务</p>
<p>4    multi-user.target下的一般系统和网络服务</p>
<p>5    图形界面相关服务如gdm.service 等其他服务</p>
<p>开机启动指令或者脚本可以写入 /etc/rc.d/rc.local</p>
<p>其他常见的环境设定文件<br>authconfig：用于使用者的身份验证。建议使用 authconfig-tui 来修改</p>
<p>cpupower：Linux核心如何操作CPU的原则，预设是用多少算多少</p>
<p>firewalld, iptables-config, ip6tables-config, ebtables-config:</p>
<p>都是防火墙服务的启动</p>
<p>network-scripts：设置网卡，在服务器架设篇才会提到</p>
<p>核心一般是压缩文件，只有解压缩之后才能使用</p>
<p>核心和核心模组的位置：</p>
<p>核心： /boot/vmlinuz或/boot/vmlinuz-version</p>
<p>核心解压缩所用RAM Disk： /boot/initramfs</p>
<p>核心模组：/lib/modules/version/kernel或/lib/modules/$(uname -r)/kernel</p>
<p>核心源码：/usr/src/linux或/usr/src/kernels</p>
<p>核心顺利载入后，会记录下来：</p>
<p>核心版本：/proc/version</p>
<p>系统核心功能：/proc/sys/kernel</p>
<p>有一个新的硬件，操作系统不支持，怎么办？</p>
<ul>
<li>重新编译核心，并加入最新的硬件驱动程序源码</li>
<li>将该硬件的驱动程序编译为模组，在开机时载入该模组</li>
</ul>
<p>核心模组的放置处: /lib/modules/$(uname -r)/kernel</p>
<p>该目录下有一下几个次目录：</p>
<p>arch    与硬件平台有关的项目，CPU等级等</p>
<p>ctypto    核心支持的加密算法</p>
<p>drivers    一些硬件的驱动程序</p>
<p>fs        核心支持的filesystem</p>
<p>lib        一些函数库</p>
<p>net        与网络有关的各项协议文件</p>
<p>sound    与音效有关的各项模组</p>
<p>检查模组相依性：</p>
<p><code>depmod [-Ane]</code></p>
<p>-A    搜寻比modules.dep更加新的模组，找到新的模组才会更新</p>
<p>-n    不写入modules.dep，而是直接输出结果(stdout)</p>
<p>-e    显示出现在已经载入的不可执行的模组名称</p>
<p>kernel核心模组后缀名一定是.ko</p>
<p><code>lsmod</code>显示核心目前已经载入的模组</p>
<p><code>modinfo [-F field] [-adln] [module_name|filename]</code>查看模组信息</p>
<p>-F    仅列出后面接的项目（author description license parm depends alias等）</p>
<p>-a    仅列出作者名称</p>
<p>-d    仅列出description</p>
<p>-l    仅列出授权license</p>
<p>-n    仅列出模组的路径</p>
<p>看到19.2.3 核心模组的载入与移除</p>
<hr>
<h3 id="2018-8-1"><a href="#2018-8-1" class="headerlink" title="2018-8-1"></a>2018-8-1</h3><p>18-1    什么是登录档</p>
<p>记录系统活动的几个档案，何时何人何地做了什么事</p>
<p>CentOS 7的登录档：</p>
<p>记录daemon运行过程中产生的信息</p>
<ul>
<li>解决系统错误</li>
<li>解决网络服务问题</li>
<li>过往事件的记录</li>
</ul>
<p>常见登录档文件名</p>
<p>/var/log/boot.log        上次开机时启动的信息</p>
<p>/var/log/cron            例行性工作的日志</p>
<p>/var/log/dmesg        系统开机时核心侦测的信息</p>
<p>/var/log/lastlog        可以记录最近一次登录系统的相关资讯</p>
<p>/var/log/mail*        记录邮件往来的信息，主要是记录postfix（SMTP）和dovecot（POP3）信息</p>
<p>/var/log/messages    系统发生的错误信息记录</p>
<p>/var/log/secure        所有需要输入密码的软件</p>
<p>/var/log/wtmp(faillog)    正确登录系统(wtmp)和错误登录(faillog)的信息</p>
<p>/var/log/httpd/*</p>
<p>/var/log/samba/*        网络服务记录</p>
<p>记录登录档需要的程序和服务有：</p>
<ul>
<li>systemd-journald.service 主要的信息收集</li>
<li>rsyslog.service 登录系统与网络等服务的信息</li>
<li>logrotate 进行登录档的轮替</li>
</ul>
<p>18-2    rsyslog.service 记录登录档的服务</p>
<p>设定档：/etc/rsyslog.conf</p>
<p>规定了[服务名称    信息等级        信息记录在哪里]</p>
<p>Linux核心的syslog服务类型</p>
<p>0    kernel    核心产生的信息</p>
<p>1    user    使用者产生的信息</p>
<p>2    mail    邮件收发产生的信息</p>
<p>3    daemon    系统服务信息</p>
<p>4    auth    认证授权有关的机制</p>
<p>5    syslog    由syslog产生的信息</p>
<p>6    lpr        打印相关信息</p>
<p>7    news    新闻群组服务器有关</p>
<p>8    uucp    全名：Unix to Unix Copy Protocol</p>
<p>9    cron    例行工作</p>
<p>10    authpriv    类似auth，但记录更多账户的私人信息</p>
<p>11    ftp        与FTP通信协议相关的信息</p>
<p>16-23    local0-local7    保留给本机用户使用的登录档信息</p>
<p>将各种类别的服务的登录档，记录在不同的档案中，就是/etc/rsyslog.conf要做的</p>
<p>信息等级</p>
<p>7    debug</p>
<p>6    info</p>
<p>5    notice</p>
<p>4    warning</p>
<p>3    err            重大的错误信息</p>
<p>2    crit            更严重的错误信息</p>
<p>1    alert        警告，更加严重</p>
<p>0    emerg        系统即将宕机，硬件出问题导致核心无法顺利工作才会发出</p>
<p>等级连接符：</p>
<p>.    比后面还要严重的等级都被记录。mail.info：只有等级高于info的信息才被记录</p>
<p>.=    只记录后面等级的信息</p>
<p>.!    反向选择，只有低于这个等级的信息才被记录</p>
<p>常见的放置记录档位置：</p>
<p>/var/log</p>
<p>/dev/lp0    打印机</p>
<p>使用者名称    显示给使用者</p>
<p>远程主机</p>
<p>*        线上的所有人</p>
<p>/etc/rsyslog.conf文件格式</p>
<p>mail.info    /var/log/maillog</p>
<p>意为把mail相关的信息，等级高于info，都写入后面的文件</p>
<p>news.*;cron.*    /var/log/cronnews    把news和cron产生的信息写入</p>
<p>news.=warn;cron.=warn    /var/log/cronnews.warn    把warn等级的信息另外写入</p>
<p>查看rsyslog.conf</p>
<p><code>cat /etc/rsyslog.conf | grep -v &#39;^#&#39; | grep -v &#39;^\$&#39; | grep -v &#39;^$&#39;; cat /etc/rsyslog.conf | grep &#39;#kern&#39;</code></p>
<p>如果登录档被删除，很大可能是主机被黑了</p>
<p>登录档只要被编辑过就无法继续记录，此时需要重启<code>rsyslog.service</code></p>
<p>增加隐藏属性，使登录档无法被删除，只能被添加，但是会导致我们无法使用logrotate</p>
<p><code>chattr +a /var/log/kern.log</code></p>
<p>查看<code>lsattr /var/log/</code></p>
<p>rsyslogd，可以使用一台机器作为登录档服务器</p>
<p>网络较为稳定，可以使用UDP，想要信息稳定传输，建议使用TCP</p>
<p>将加注释的下面两行的注释取消</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># Provides TCP syslog reception</span><br><span class="line">$ModLoad imtcp</span><br><span class="line">$InputTCPServerRun 514</span><br></pre></td></tr></table></figure>
<p>重启rsyslogd</p>
<p>登录档发送客户端：</p>
<p>/etc/rsyslog.conf</p>
<p>要将所有信息发送给服务器(192.168.1.100)的话，添加：</p>
<p><code>*.* @@192.168.1.100</code>TCP</p>
<p><code>*.* @192.167.1.100</code>UDP</p>
<p>18-3    登录档的轮替</p>
<p>logrotate程序是在cron 中进行的</p>
<p><code>ls /etc/cron.daily</code></p>
<p>logrotate的设定档</p>
<p>/etc/logrotate.conf</p>
<p>/etc/logrotate.d</p>
<p>执行一次logrotate，原log文件会变成 log.1，然后在创建一个新的log空文件，继续存储日志</p>
<p>.conf设定语法</p>
<p>登录档的文件名 {</p>
<p>​    个别参数设定值</p>
<p>​    sharedscripts</p>
<p>​    prerotate # 轮替前执行的命令</p>
<p>​      /usr/bin/chattr -a /var/log/messages</p>
<p>​    endscript</p>
<p>​    sharedscripts</p>
<p>​    postrotate # 轮替后执行的命令</p>
<p>​      /usr/bin/chattr +a /var/log/messages</p>
<p>​    endscript</p>
<p>}</p>
<p><code>logrotate -v /etc/logrotate.conf</code>进行轮替</p>
<p>18-4    systemd-journald.service简介</p>
<p>建议启动rsyslodf来协助分类记录。因为systemd-journald只记录本次开机的情况</p>
<p><code>journalctl [-nrpf] [--since TIME] [--until TIME] _optional</code></p>
<p>-n    显示最近几行，也就是最新的记录</p>
<p>-r    反向输出，显示最旧的记录</p>
<p>-p    输出后面接的信息的重要性排序</p>
<p>-f    持续显示日志内容</p>
<p>–since –until        设定开始与结束的时间</p>
<p>_SYSTEMD_UNIT=unit.service    只输出unit.service 的信息</p>
<p>_COMM=bash    只输出与bash有关的信息</p>
<p>_PID=pid        只输出PID为pid的信息</p>
<p>_UID=uid        只输出UID为uid的信息</p>
<p>SYSLOG_FACILITY=[0-23]    使用syslog.h规范的服务相对序号来呼叫出正确的资料</p>
<p><code>logger [-p daemonname.level] &quot;message&quot;</code>让自己的信息存入登录档</p>
<p><code>logger -p user.info &quot;I will check logger command&quot;</code></p>
<p>保存journal：</p>
<p>创建目录<code>/var/log/journal</code></p>
<p>18-5    分析登录档</p>
<p>CentOS 7预设使用 logwatch 进行登录档分析</p>
<p>安装：挂载iso到/mnt</p>
<p><code>yum install /mnt/Packages/perl-5.*.rpm /mnt/Packages/perl-Date-Manip-*.rpm /mnt/Packages/perl-Sys-CPU-*.rpm /mnt/Packages/perl-Sys-MemInfo-*.rpm /mnt/Packages/logwatch-*.rpm</code></p>
<p>安装之后就将logwatch写入cron.daily了</p>
<h4 id="第十九章-开机流程、模组管理与loader"><a href="#第十九章-开机流程、模组管理与loader" class="headerlink" title="第十九章 开机流程、模组管理与loader"></a>第十九章 开机流程、模组管理与loader</h4><p>19-1    Linux开机流程分析</p>
<ol>
<li>载入BIOS硬件信息并进行自检，依据设置取得第一个可开机的装置</li>
<li>读取并执行第一个开机装置（硬盘）内MBR的boot loader</li>
<li>依据boot loader 的设定载入Kernel，Kernel开始侦测硬件与载入驱动程序</li>
<li>硬件驱动成功后，Kernel会主动调用systemd程序，并以default.target流程开机<ol>
<li>systemd 执行 sysinit.target 初始化系统及basic.target 准备操作系统</li>
<li>systemd 执行 multi-user.target 下的本机与服务器服务</li>
<li>systemd 执行 multi-user.target 下的 /etc/rc.d/rc.local 档案</li>
<li>。。。。。。。。。。。。。。。。。getty.target 及 登录服务</li>
<li>。。。。。。。graphical需要的服务</li>
</ol>
</li>
</ol>
<p>核心启动后会接管BIOS的工作，重新检测一次硬件设备</p>
<p>核心档案 /boot/vmlinuz</p>
<p>核心模组 /lib/modules (/lib 与 / 不可以放在不同的partition中)</p>
<p>目前驱动程序都是在 /lib/modules内的，但是在核心不认识SATA硬盘的情况下，无法挂载根目录，也就无法读取SATA的驱动程序，此时需要虚拟档案系统来处理。</p>
<p>虚拟档案系统（Initial RAM Disk/Filesystem）</p>
<p>文件名一般是 /boot/initrd 或 /boot/initramfs</p>
<p>能通过boot loader 载入内存，然后被解压缩为一个根目录，能够提供一个可执行文件，通过这个文件来载入开机过程需要的核心模组，如USB、RAID、LVM、SCSI等</p>
<p>载入完成后，可以帮助核心重新调用　systemd来开始后续的正常开机流程</p>
<p>看到图19.1.3</p>
<hr>
<h3 id="2018-7-31"><a href="#2018-7-31" class="headerlink" title="2018-7-31"></a>2018-7-31</h3><h4 id="第十七章-认识系统服务（daemons）"><a href="#第十七章-认识系统服务（daemons）" class="headerlink" title="第十七章 认识系统服务（daemons）"></a>第十七章 认识系统服务（daemons）</h4><p>常驻在内存中的程序，命名一般是程式名加d（daemon）</p>
<p>在SystemV时，由init去启动所有系统服务</p>
<p>CentOS 7 已经不再用init 管理，相关的管理方式可以查看<a href="http://linux.vbird.org/linux_basic/0560daemons//0560daemons-centos5.php" target="_blank" rel="noopener">鸟哥的旧版教程</a></p>
<p>使用systemd来管理启动服务</p>
<p>优点：</p>
<ul>
<li>平行处理所有服务，加速开机流程，可以让所有的服务同时启动</li>
<li>一经要求就回应的on-demand启动方式，仅通过systemd服务和systemctl指令来处理</li>
<li>自行检查服务相依性，如果相依的服务没有启动，systemd会自动帮忙启动</li>
<li>systemd将所有的服务都作为服务单位（unit），并将其分为不同的类（type），如：service, socket等</li>
<li>将多个服务集合成一个target，启动target就启动了很多daemon</li>
<li>向下兼容init脚本</li>
</ul>
<p>无法完全取代init的地方</p>
<ul>
<li>runlevel对应：只有1，3，5对应systemd的target</li>
<li>不可自定参数</li>
<li>手动启动的服务无法通过systemd侦测到，也无法进行后续管理</li>
<li>无法通过stdin传入信息</li>
</ul>
<p>systemd的设定文件：</p>
<ul>
<li>/usr/lib/systemd/system：每个服务的主要启动脚本设定</li>
<li>/run/systemd/system：系统执行过程中产生的服务脚本，优先级高于上面的</li>
<li>/etc/systemd/system：管理员依据主机系统的需求建立的执行脚本，优先级更高，开机时会先查看此目录，来启动开机需要启动的服务，实际上此目录都是链接到/usr/lib/systemd/system的链接文件</li>
</ul>
<p>常见的systemd服务类型：</p>
<p>.service    一般服务类型，主要是系统服务，经常被使用到的服务都是这个类型</p>
<p>.socket    内部程序信息交换服务，主要是IPC的传输信息插槽文件，一般是比较不常用的服务</p>
<p>.target    执行环境类型，是一群unit的集合，也就是一群其他服务的集合</p>
<p>.mount/.automount    文件系统挂载服务，来自网络的自动挂载，NFS文件系统等</p>
<p>.path    侦测特定文件或目录类型，用于需要某些目录来支持的服务</p>
<p>.timer    循环执行的服务，类似与anacrontab</p>
<p>通过<code>systemctl</code>来管理服务</p>
<p>服务的启动分为：现在立即启动和开机时是否启动</p>
<p><code>systemctl [command] [unit]</code></p>
<p>command:</p>
<p>start    立即启动后面的unit</p>
<p>stop    立即关闭后面的unit</p>
<p>restart    立即重启后面的unit</p>
<p>reload    不关闭后面的unit情况下，重新载入设定文件</p>
<p>enable    设定下次开机时，启动后面的unit</p>
<p>disable    下次开机不启动后面的unit</p>
<p>status    目前后面unit的状态，列出是否正在执行，开机是否启动，登录</p>
<p>is-active    目前有没有正在运行</p>
<p>is-enabled    开机时有没有预设要启用</p>
<p>mask        强制注销服务</p>
<p>unmask        解除强制注销</p>
<p>Active状态：</p>
<p>active(running)    正在执行</p>
<p>active(exit)        仅执行一次就正常结束的服务</p>
<p>active(waiting)    等待其他事件才能继续处理</p>
<p>inactive            服务没有运作</p>
<p>daemon预设状态</p>
<p>enabled    开机执行</p>
<p>disabled    开机不会执行</p>
<p>static    不可以自己启动，但是可以被其他enabled服务来唤醒</p>
<p>mask    无论如何都不能启动<code>systemctl unmask</code>可以改回原来的状态</p>
<p>相互依赖的服务会在启动一个服务时，自动启动依赖的服务，所以必须全部关掉才能保证不被启动</p>
<p>通过systemctl观察系统上的所有服务：</p>
<p><code>systemctl [command] [--type=TYPE] [--all]</code></p>
<p>command</p>
<p>list-units        列出目前启动的unit，–all可以列出没启动的</p>
<p>list-unit-files    将所有文件列表说明</p>
<p>–type=TYPE    unit type</p>
<p>取得target</p>
<p><code>systemctl [command] [unit.target]</code></p>
<p>command:</p>
<p>get-default    取得目前的target</p>
<p>set-default    设定一个target为默认的操作模式</p>
<p>isolate        切换到后面的target模式</p>
<p>multi-user.target    命令行模式</p>
<p>graphical.target    图形模式</p>
<p>切换操作模式的指令<code>systemctl [command]</code></p>
<p>command:</p>
<p>poweroff    关机</p>
<p>reboot        重启</p>
<p>suspend        暂停模式，将资料状态保存在内存中，然后关掉大部分硬件，并没关机</p>
<p>hibernate    休眠模式，将状态保存在硬盘中，关机</p>
<p>rescue        救援模式</p>
<p>emergency    紧急救援模式</p>
<p>追踪unit的相依性</p>
<p><code>systemctl list-dependencies [unit] [--reverse]</code></p>
<p>–reverse    表示谁会用到unit这个服务</p>
<p>直接查询表示查询unit的相依服务</p>
<p>系统daemon相关目录：除了上面的三个以外</p>
<p>/etc/sysconfig/*    所有服务的初始化选项</p>
<p>/var/lib            会产生资料的服务，都会将资料写入此目录</p>
<p>/run            放置临时文件</p>
<p>让网络服务和端口号对应的文件：/etc/services</p>
<p>建议关闭不必要的网络服务</p>
<p><code>netstat -tlunp</code>查看</p>
<p>关闭 avahi-daemon</p>
<p>一般服务器至少需要25号端口，22号端口需要防火墙，其余的端口都可以关闭了</p>
<p>想要建立服务：</p>
<p>需要修改/etc/systemd/system</p>
<p>官方预设的设定文件在 /usr/lib/systemd/system/vsftpd.service</p>
<p>个人设定文件可以写在：/etc/systemd/system/vsftpd.service.d/custom.conf</p>
<p>/etc/systemd/system/vsftpd.service。wants/*    放置连接文件，启动vsftpd.service后，最好再加上这个目录下建议的服务</p>
<p>/etc/systemd/system/vsftpd.service.requires/*    放置连接文件，启动服务前，需要事先启动哪些服务</p>
<p>设定文件的结构:</p>
<p>Unit        unit本身的说明</p>
<ul>
<li>Description</li>
<li>Documentation</li>
<li>After 表示在哪个daemon之后启动，仅是说明启动顺序，不强制要求</li>
<li>Before 同，仅说明启动顺序</li>
<li>Requires 必须在哪个daemon之后启动，强制要求的相依服务</li>
<li>Wants 最好在启动服务后，再启动这些服务</li>
<li><p>Conflicts 冲突的服务</p>
<p>  ervice、Socket、Timer、Mount、Path    不同的unit type使用相应的设置</p>
</li>
</ul>
<p>Service部分</p>
<ul>
<li>Type 代表启动方式<ul>
<li>simple 预设，表示这个daemon由ExecStart接的指令串来启动</li>
<li>forking 由ExecStart启动的程序通过spawns延伸出其他子程序来作为此daemon的主要服务</li>
<li>oneshot 类似simple，，不过这个程序在工作完成后就结束了</li>
<li>dbus 必须取得一个D-Bus名称后，才能继续运行，需要设定Bus Name</li>
<li>idle  类似simple，要执行这个daemon必须要所有工作都执行完才行 </li>
</ul>
</li>
<li>EnvironmentFile 指定脚本的环境</li>
<li>Exec Start 实际执行此daemon的指令或脚本程序。</li>
<li>ExecStop  与systemctl stop 有关</li>
<li>ExecReload 与systemctl reload有关</li>
<li>Restart 结束一个服务后，这个服务会马上重启</li>
<li>RemainAfterExit </li>
<li>TimeoutSec  强制结束等待时间</li>
<li>KillMode </li>
<li><p>RestartSec 服务重启等待时间</p>
<p>  nstall        将此unit安装到哪个target的意思</p>
</li>
<li><p>WantedBy 这个unit本身是挂在哪个target下</p>
</li>
<li>Also 当这个服务被enable，此项目后面的unit也enable</li>
<li>Alias 建立别名</li>
</ul>
<p>建立两个同时运作的vsftp</p>
<p>复制一份<code>vsftpd.conf</code>在/etc/vsftpd下，命名为<code>vsftpd2.conf</code>，修改监听端口</p>
<p><code>cp vsftpd.conf vsftpd2.conf</code></p>
<p>复制一份启动脚本设定，修改Description为新的描述，Exec Start目录为刚才的conf文件</p>
<p><code>cp /usr/lib/systemd/system/vsftpd.service vsftpd2.service</code></p>
<p>重新载入systemd脚本设定</p>
<p><code>systemctl daemon-reload</code></p>
<p><code>systemctl list-unit-files --all | grep vsftpd</code></p>
<p>重启服务</p>
<p><code>systemctl restart vsftpd.service vsftpd2.service</code></p>
<p>在设置新的服务开机自启就好了</p>
<p>设定规则：</p>
<ul>
<li>设定项目是可重复的，后面的会覆盖前面的</li>
<li>逻辑值设定可以使用：0/1 yes/no true/false on/off 都可以</li>
<li>空白行、开头为#或；的行都表示注释</li>
</ul>
<p>将tty的数量降低到4个</p>
<p><code>systemctl stop getty@tty5.service</code></p>
<p><code>systemctl stop getty@tty6.service</code></p>
<p><code>systemctl restart systemd-logind.service</code></p>
<p>打开第8个tty</p>
<p><code>systemctl start getty@tty8.service</code></p>
<p>暂时新增vsftpd到2121端口</p>
<p>利用/usr/lib/systemd/system下的vsftp@.service</p>
<p>文件中 %i 表示的就是@后面接的数字</p>
<p>新增 vsftpd3.conf，监听端口2121</p>
<p>然后启动服务</p>
<p><code>sudo systemctl start vsftpd@vsftpd3.service</code></p>
<p>启动成功</p>
<p>自己新建一个service</p>
<ol>
<li>新建执行脚本，给予权限</li>
<li>在/etc/systemd/system/目录下添加文件，设置好Unit，Service，Install</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=backup my server</span><br><span class="line">Requires=atd.service</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=simple</span><br><span class="line">ExecStart=/bin/bash -c <span class="string">" echo /backups/backup.sh | at now"</span></span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure>
<ol start="3">
<li><code>systemctl daemon-reload</code>重新载入配置文件</li>
<li><code>systemctl start</code>开启服务</li>
</ol>
<p>使用 Timer来代替crontab</p>
<p>使用Timer的前提</p>
<ul>
<li>系统的timer.target必须启动</li>
<li>需要有一个 something.service 服务存在（something是自己设置的名字）</li>
<li>需要有一个 something.timer 时间启动服务存在</li>
</ul>
<p>something.timer的设定值</p>
<p><code>/etc/systemd/system/*.timer</code></p>
<table>
<thead>
<tr>
<th>設定參數</th>
<th>參數意義說明</th>
</tr>
</thead>
<tbody>
<tr>
<td>OnActiveSec</td>
<td>當 timers.target 啟動多久之後才執行這隻 unit</td>
</tr>
<tr>
<td>OnBootSec</td>
<td>當開機完成後多久之後才執行</td>
</tr>
<tr>
<td>OnStartupSec</td>
<td>當 systemd 第一次啟動之後過多久才執行</td>
</tr>
<tr>
<td>OnUnitActiveSec</td>
<td>這個 timer 設定檔所管理的那個 unit 服務在最後一次啟動後，隔多久後再執行一次的意思</td>
</tr>
<tr>
<td>OnUnitInactiveSec</td>
<td>這個 timer 設定檔所管理的那個 unit 服務在最後一次停止後，隔多久再執行一次的意思。</td>
</tr>
<tr>
<td>OnCalendar</td>
<td>使用實際時間 (非循環時間) 的方式來啟動服務的意思！至於時間的格式後續再來談。</td>
</tr>
<tr>
<td>Unit</td>
<td>一般來說不太需要設定，因此如同上面剛剛提到的，基本上我們設定都是 sname.server + sname.timer，那如果你的 sname 並不相同時，那在 .timer 的檔案中， 就得要指定是哪一個 service unit 囉！</td>
</tr>
<tr>
<td>Persistent</td>
<td>當使用 OnCalendar 的設定時，指定該功能要不要持續進行的意思。通常是設定為 yes ，比較能夠滿足類似 anacron 的功能喔！</td>
</tr>
</tbody>
</table>
<p>时间设定的格式：</p>
<p><code>英文周名    YYYY-MM-DD    HH:MM:SS</code></p>
<p><code>Thu 2018-07-31 13:00:00</code></p>
<p>小单位写在前面</p>
<p><code>10s 300m 5day</code></p>
<p>一些服务介绍：（服务器）</p>
<p>abrtd                让使用者可以针对不同的应用软件去设计登录错误的机制</p>
<p>accounts-daemon    进行使用者账户信息查询</p>
<p>alsa-X                音效有关，服务器可以关闭这些服务</p>
<p>atd        at的服务</p>
<p>auditd    SELinux所需服务之一</p>
<p>avahi-daemon    客户端的服务，自动分析与管理网络，可以关闭</p>
<p>brandbot, rhel-*    用于关机过程中需要的各种侦测环境的脚本，也提供网络界面的启动和关闭</p>
<p>chronyd, ntpd, ntpdate    用于网络时间矫正</p>
<p>cpupower    提供CPU的运作规范。/etc/sysconfig/cpupower有详细内容</p>
<p>crond    crontab支持服务</p>
<p>cups    印表机（打印机）服务，没有的话可以关闭</p>
<p>dbus    使用D-Bus方式在不同的应用程序间传送信息</p>
<p>dm-event，multipathd    监控装置对应表的服务（device mapper）</p>
<p>dmraid-activation, mdmonitor    启动Software RAID的服务</p>
<p>dracut-shutdown        用来处理initramfs相关行为，和开机流程相关性较高</p>
<p>ebtables        设定网卡为桥接时的封包分析政策。防火墙</p>
<p>emergency、rescue    紧急模式和救援模式的服务</p>
<p>firewalld        防火墙系统，取代iptables</p>
<p>gdm    GNOME登入管理员</p>
<p>getty@    在本机产生几个终端的服务</p>
<p>hyper、ksm、libvirt、vmtoolsd    虚拟机相关服务</p>
<p>irqbalance    多核心硬件的系统需要这个服务，可以自动分析系统中断</p>
<p>iscsi        可以挂载来自网络磁碟机的服务</p>
<p>kdump    Linux核心出错时，用来记录内存的东西</p>
<p>lvm2-*    LVM相关的许多服务</p>
<p>microcode    Intel的CPU提供的微指令集</p>
<p>ModemManager、network、NetworkManager*         数据机，网络设定的服务</p>
<p>quotaon        启动Quota用到的服务</p>
<p>rc-local        相容 /etc/rc.d/rc.local的调用方式，必须有x权限</p>
<p>rsyslog        记录系统产生的各项讯息</p>
<p>smartd        自动的侦测硬盘状态，发生问题时回报给管理员</p>
<p>sysstat        sar指令会记录系统资源的使用情况，这个服务用来让这些情况写入log</p>
<p>systemd-*    系统运作过程需要的服务</p>
<p>plymount*、upower    与图形界面使用相关的服务</p>
<p>查询服务端口</p>
<p><code>cat /etc/services | grep Port</code></p>
<h4 id="第十八章-认识与分析登录档"><a href="#第十八章-认识与分析登录档" class="headerlink" title="第十八章 认识与分析登录档"></a>第十八章 认识与分析登录档</h4><hr>
<h3 id="2018-7-30"><a href="#2018-7-30" class="headerlink" title="2018-7-30"></a>2018-7-30</h3><h4 id="程序管理与SELinux初探"><a href="#程序管理与SELinux初探" class="headerlink" title="程序管理与SELinux初探"></a>程序管理与SELinux初探</h4><p>PID：给予程序的ID</p>
<p>根据使用者的权限，程序也会拥有不同的权限</p>
<p>在程序中调用程序后，互称父子程序，由PPID（Parent PID）可以得知父程序</p>
<p>如果有process在被kill之后又出现，如果不是crontab，就肯定是父程序的问题，只要kill掉父程序就好了</p>
<p>Linux程序调用的流程： fork and exec，先由父程序复制一个子程序，再以exec的方式来执行</p>
<p>常驻内存的程序：系统和网络服务（daemon）</p>
<ul>
<li>一般daemon程序名后面都有个d</li>
</ul>
<p>Linux的多人环境：</p>
<ul>
<li>每个人的系统环境都可以随每个人的喜好来设定：~/.bashrc 因为每个人取得的shellPID不同</li>
<li>Linux预设了六个命令行界面和一个图形界面使用ALT+ F1~F7来切换</li>
<li>Linux可以随时kill掉死掉的程序，输入<code>ps -aux</code>找出错误的程序再kill掉就好了</li>
<li><code>cp file1 file2 &amp;</code>可以在后台进行程序</li>
</ul>
<p>工作管理</p>
<ul>
<li>要管理的工作必须是你shell的子程序</li>
<li>你可以控制和下达指令的环境称为前景</li>
<li>可以自行运作，无法用^C终止的程序，称为背景，可以使用<code>bg/fg</code>呼叫该工作</li>
<li>背景中执行的程序不能等待终端的输入</li>
</ul>
<p><code>&amp;</code> 在指令的末尾，就可以使指令进入背景运行，并在开始运行时显示工作号码和PID，结束运行时显示ＤＯＮＥ</p>
<p>但是如果指令有stdout，还是会输出在前景上，所以需要使用 &amp;&gt; log.txt 将数据流导向文件</p>
<p><code>^z</code>可以将目前的程序放入背景，并暂停程序</p>
<p><code>jobs [-lrs]</code>查看目前背景工作状态</p>
<p><code>-l</code>除了jobnumber和指令串外，同时列出PID号码</p>
<p><code>-r</code>仅列出在背景run的工作</p>
<p><code>-s</code>仅列出正在背景中暂停的工作</p>
<p>列出的程序中带有+表示是最后一个被放入背景，带有-表示是倒数第二个被放入背景，倒数第三个及以上就没有标志了</p>
<p><code>fg %jobnumber</code>将工作拉回前景来进行</p>
<p><code>bg</code>让程序在背景中的状态变为运行中</p>
<p><code>kill -signal %jobnumber</code>结束背景工作</p>
<p><code>kill -l</code></p>
<p><code>-l</code>列出当前kill能使用的signal</p>
<p>signal:</p>
<ul>
<li>-1 重新读取一次参数设定文件</li>
<li>-2 由键盘输入^c同样的动作</li>
<li>-9 立刻强制删除一个工作</li>
<li>-5 以正常的方式终止一项工作</li>
</ul>
<p>一般知道正常关闭顺序的程序应该使用正常关闭顺序关闭，不知道的情况下才用kill -9</p>
<p>!注意，上文提到的背景指的是shell的背景，主要作用是可以避免被 ^C结束掉，当shell结束时，背景中的工作也会结束</p>
<p><code>nohup</code>可以把工作放入系统背景，即使登出ssh工作还可以继续</p>
<p>nohup不支持bash的内建指令，指令必须是外部指令</p>
<p><code>nohup scripts &amp;</code></p>
<p>登出再登录，用<code>pstree</code>查看，发现脚本还在执行</p>
<p>程序查看</p>
<p><code>ps aux</code>查看系统所以程序的情况</p>
<p><code>ps -lA</code>同样观察所有程序</p>
<p><code>-l</code>    较长，较详细地列出该程序的信息</p>
<p>-A    显示所有的Process</p>
<p><code>ps axjf</code>连同部分程序树状态也显示</p>
<p>-a    显示不与终端有关的process</p>
<p>x    通常和a一起用，可以列出完整信息</p>
<p>j    列出工作的格式</p>
<p>f    做更为完整的输出</p>
<p><code>ps -l</code>查询自己bash的程序状态</p>
<p>F    process flag</p>
<ul>
<li>4表示权限为root</li>
<li><p>1表示子程序仅有复制而没有执行的权限</p>
<pre><code>process status
</code></pre></li>
<li><p>R表示程序正在运作中</p>
</li>
<li>S表示程序在睡眠状态</li>
<li>D表示不可唤醒的睡眠状态，可能是在等待IO</li>
<li>T停止状态，可能是在工作控制或除错状态</li>
<li><p>Z僵尸状态，程序已经终止但无法被移出内存</p>
<p>  ID/PID/PPID    此程序被该UID拥有，程序PID，程序PPID</p>
<pre><code>CPU使用率
</code></pre><p>  RI/NI    Priority/Nice，CPU执行的优先级，数字越小优先级越高</p>
<p>  DDR    kernel function，指出该程序在内存的哪个部分</p>
<p>  Z        此程序用掉多少内存</p>
<p>  CHAN    目前程序是否在运行，- 代表在运行</p>
<p>  TY        登入者的终端号</p>
<p>  IME    用掉的CPU时间</p>
<p>  MD    此程序的指令</p>
</li>
</ul>
<p><code>ps aux</code>查询所有系统程序的状态</p>
<p>USER    process的所属用户</p>
<p>PID        process的程序识别码</p>
<p>%CPU    使用掉的CPU资源占比</p>
<p>%MEM    占用的实体内存百分比</p>
<p>VSZ        占用的虚拟内存量KB</p>
<p>RSS        占用的固定内存量</p>
<p>TTY        在哪个终端运作，若无终端则显示？</p>
<p>STAT    程序状态，与<code>ps -l</code>的flag相同</p>
<p>TIME    使用的CPU运作时间</p>
<p>COMMAND    程序的指令</p>
<p>僵尸程序的成因是本应该结束的程序，系统却无法将其结束，于是就留在内存中</p>
<p><code>top [-d number] | top [-bnp]</code>动态观察程序的变化</p>
<p>-d    接秒数，画面更新的间隔，秒</p>
<p>-b    按批次执行top</p>
<p>-n    和b搭配，设置进行的次数</p>
<p>-p    指定某些PID来进行观测</p>
<p>在执行过程 中可以使用的按键</p>
<p><code>top -b -n 2 &gt; /tmp/top.txt</code>将top的结果输出到文件</p>
<p><code>top -d 2 -p PID</code>观察PID为PID的process</p>
<p><code>$$</code>获取当前bash的PID</p>
<p><code>pstree [-A|U] [-up]</code></p>
<p>-A    各程序树之间的连接以ASCII字符表示</p>
<p>-U    各程序树之间的连接以UNICODE来表示</p>
<p>-p    同时列出每个process的PID</p>
<p>-u    同时列出每个process所属的账号名称</p>
<p>程序之间管理的signal：<code>kill -l</code></p>
<p>1    SIGHUP        重启程序，可让程序重新读取自己的设定文件</p>
<p>2    SIGINT        中断程序，相当于^C</p>
<p>9    SIGKILL        强制中断，可能会留下临时文件</p>
<p>15    SIGTERM    以正常的方式结束程序，如果无法使用正常的程序结束，那么这个signal没有用</p>
<p>19    SIGSTOP        相当于^z    暂停程序</p>
<p><code>killall [-ile] [command name]</code></p>
<p>-i    interactive 互动式，若要删除时会出现提示字符</p>
<p>-e    exact，后面的command name要一致，但命令不能超过15个字符</p>
<p><code>-l</code>    指定名称忽略大小写</p>
<p>执行优先级：</p>
<p>PRI是由核心动态调整的，用户只能通过改NI的方式来调整PRI：</p>
<p>PRI[new] = PRI[old] + NI</p>
<p>但是最后的PRI值并不是简单的求和结果，而是由核心分析后决定的</p>
<p>更改NI：top -&gt; r -&gt; input PID -&gt; input NI value</p>
<ul>
<li>nice值的范围是 -20 ~ 19</li>
<li>root可以调整自己或他人程序的nice值</li>
<li>一般用户可调整自己的nice值，且范围是0~19</li>
<li>一般用户只能将nice值越调越高</li>
</ul>
<p><code>nice [-n number] command</code>给command在执行时就加上新的nice值</p>
<p>number 的范围是 -20~19，指的是在原有的nice值下加上一个值，变成新的nice值</p>
<p><code>renice [number] PID</code></p>
<p>设置PID为PID的process优先级为number</p>
<p>观察系统资源</p>
<p><code>free [-b|-k|-m|-g|-h] [-t] [-s N -c N]</code>内存使用情况</p>
<p>-b    可以自己指定单位：b=bytes，m=Mbytes, k=Kbytes。。。-h表示让系统自己指定单位</p>
<p>-t    在输出的结果中显示内存和虚拟内存的总量</p>
<p>-s    让系统每几秒钟输出一次</p>
<p>如果发现系统使用的swap超过20%，请及时添加内存</p>
<p><code>uname [-asrmpi]</code>查阅系统与核心相关信息</p>
<p>-a    所有系统相关的信息</p>
<p>-s    系统核心名称</p>
<p>-r    核心版本</p>
<p>-m    系统的硬件名称</p>
<p>-p    CPU的类型，与-m类似</p>
<p>-i    硬件的平台</p>
<p><code>uptime</code>观察系统启动时间与工作负载，显示的是开机时间和1、5、15分钟的平均工作负载</p>
<p><code>netstat [-atunlp]</code>追踪网络或插槽</p>
<p>-a    列出系统所有的连接、监听、Socket信息</p>
<p>-t    列出tcp网络封包的信息</p>
<p>-u    列出udp网络封包的信息</p>
<p>-n    不以程序的服务名称，以端口号来表示</p>
<p>-l    列出目前正在监听的服务</p>
<p>-p    列出该网络服务的PID</p>
<p>显示信息的意义：</p>
<p>Proto    网络封包的协定</p>
<p>Recv-Q            非由使用者程式連結到此 socket 的複製的總 bytes 數； （看不懂。。。。）</p>
<p>Send-Q            非由遠端主機傳送過來的 acknowledged 總 bytes 數； </p>
<p>Local Address    本地端IP端口情况</p>
<p>Foreign Address    远端主机的IP端口情况</p>
<p>State            连线状态</p>
<p>socket file 可以沟通两个程序之间的信息。</p>
<p>上面指令显示的socket file项目的意义：</p>
<p>Proto    一般都是unix</p>
<p>RefCnt    连接到此socket的程序数量</p>
<p>Flags    连线的flag</p>
<p>Type    socket的存取类型，主要有STREAM和DGRAM两种</p>
<p>State    若为CONNECTED表示多个程序之间已经建立连线</p>
<p>Path    连接到此socket的相关程序路径</p>
<p><code>netstat -tulnp</code>查看程序启动的网络后门（监听的端口等）</p>
<p><code>dmesg</code>分析核心产生的信息</p>
<p>一般配合<code>less</code>使用<code>dmesg|less</code></p>
<p><code>vmstat</code>侦测系统资源变化，动态显示系统资源的运作</p>
<p><code>vmstat [-a] [延迟[总计侦测次数]]</code>CPU、内存等信息</p>
<p><code>vmstat [-fs]</code>内存相关</p>
<p>-f    开机到目前为止，系统复制的程序数</p>
<p>-s    将开机到目前为止，事件导致内存状态变化情况列表说明</p>
<p><code>vmstat [-S 单位]</code></p>
<p>-S    让显示的信息有单位 K M等</p>
<p><code>vmstat [-d]</code></p>
<p>-d    列出磁盘读写总量的统计表</p>
<p><code>vmstat [-p 分隔槽]</code></p>
<p>-p    可显示该分隔槽的读写总量统计表</p>
<p><code>vmstat 1 3</code>统计目前CPU状态，每秒1次，共3次</p>
<p><code>vmstat 5</code>代表5秒一次，无穷次，只能用^C停止</p>
<p><code>vmstat</code>显示的信息意义：</p>
<p>procs：这里的数量越多，系统越忙碌</p>
<p>r        等待运行的程序数量</p>
<p>b        不可被唤醒的程序数量</p>
<p>memory：</p>
<p>swpd    虚拟内存被使用的容量</p>
<p>free        未被使用的内存量</p>
<p>buff        缓冲区容量</p>
<p>cache    快速读取的内存容量</p>
<p>swap：如果这里的数值很大表示内存和磁盘经常进行存取，系统速度会很慢</p>
<p>si        由磁盘中将程序取出的量</p>
<p>so        由于内存不足而将没用的程序写入swap的量</p>
<p>io：此处数量大表示系统IO繁忙</p>
<p>bi        从磁盘读入区块的量</p>
<p>bo        写入磁盘的区块数量</p>
<p>system：此处代表系统与周边设备的沟通频率</p>
<p>in        每秒被中断的程序次数</p>
<p>cs        每秒进行的事件切换次数</p>
<p>cpu：</p>
<p>us        非核心层的CPU使用状态</p>
<p>sy        核心层使用的CPU状态</p>
<p>id        闲置的状态</p>
<p>wa        等待IO所耗费的CPU状态</p>
<p>st        被虚拟机盗用的CPU使用状态</p>
<p><code>vmstat -d</code>可以显示磁盘的信息</p>
<p>寻找有特殊权限的文件<code>find / -perm /6000</code></p>
<p>/proc/*各文件的意义：</p>
<p>各个程序（进程process）的PID都以目录的形式存在/proc中</p>
<p>查看/proc/1的内容</p>
<p>主要看：</p>
<ul>
<li>cmdline    是这个程序被启动的指令串</li>
<li><p>environ   是这个程序的环境变量内容</p>
<pre><code>/proc/cmdline    載入 kernel 時所下達的相關指令與參數！查閱此檔案，可瞭解指令是如何啟動的！

/proc/cpuinfo    本機的 CPU 的相關資訊，包含時脈、類型與運算功能等

/proc/devices    這個檔案記錄了系統各個主要裝置的主要裝置代號，與 mknod 有關呢！

/proc/filesystems    目前系統已經載入的檔案系統囉！

/proc/interrupts    目前系統上面的 IRQ 分配狀態。

/proc/ioports    目前系統上面各個裝置所配置的 I/O 位址。

/proc/kcore    這個就是記憶體的大小啦！好大對吧！但是不要讀他啦！

/proc/loadavg    還記得 top 以及 uptime 吧？沒錯！上頭的三個平均數值就是記錄在此！

/proc/meminfo    使用 free 列出的記憶體資訊，嘿嘿！在這裡也能夠查閱到！

/proc/modules    目前我們的 Linux 已經載入的模組列表，也可以想成是驅動程式啦！

/proc/mounts    系統已經掛載的資料，就是用 mount 這個指令呼叫出來的資料啦！

/proc/swaps    到底系統掛載入的記憶體在哪裡？呵呵！使用掉的 partition 就記錄在此啦！

/proc/partitions    使用 fdisk -l 會出現目前所有的 partition 吧？在這個檔案當中也有紀錄喔！
</code></pre><p>   /proc/uptime    就是用 uptime 的時候，會出現的資訊啦！</p>
<pre><code>/proc/version    核心的版本，就是用 uname -a 顯示的內容啦！

/proc/bus/*    一些匯流排的裝置，還有 USB 的裝置也記錄在此喔！
</code></pre></li>
</ul>
<p><code>fuser [-umv] [-k [i] [-signal]] file/dir</code>由文件或文件系统找出正在使用该文件的程序</p>
<p>-u    除了程序的PID之外，同时列出该程序的拥有者</p>
<p>-m    后面接的文件名会主动地提到文件系统最顶层，对卸载不成功很有效</p>
<p>-v    可以列出每个文件与程序还有指令的完整相关性</p>
<p>-k    找出使用该文件/目录的PID，并试图把SIGKILL讯号发送给这个PID</p>
<p>-i    必须和k配合，在删除PID之前询问使用者</p>
<p>-signal    发送signal，预设是-9，SIGKILL</p>
<p>当想要卸载磁盘时发现Device is busy，就可以使用fuser来追踪</p>
<p><code>fuser -uv .</code></p>
<p>此处的权限项目意义为：</p>
<p>c    此程序在当前目录下</p>
<p>e    可被触发为执行状态</p>
<p>f    是一个被开启的文件</p>
<p>r    代表顶层目录</p>
<p>F    该文件被开启了，不过在等待回应中</p>
<p>m    可能为分享的动态函数库</p>
<p><code>fuser -mvu dir</code>可以看到有多少进程在存取这个目录</p>
<p>有进程在存取文件系统时，这个分区就无法卸载</p>
<p><code>fuser -mki dir</code>可以一个一个地删除这些正在使用的进程</p>
<p><code>fuser</code>也可以对文件使用，查看有哪些进程在存取文件</p>
<p><code>fuser -uv /run/systemd/sessions/5.ref</code></p>
<p><code>lsof [-auU] [+d]</code>列出被程序所开启的文件名</p>
<p>-a    多项文件需要同时成立才显示结果：AND</p>
<p>-U    仅列出UNIX like系统的socket档案类型</p>
<p>-u    后面接username，列出该使用者相关程序所开启的文件</p>
<p>+d    后面接目录，即，找出某个目录下已经被开启的文件</p>
<p><code>pidof</code>找出某个正在执行的程序的PID</p>
<p><code>pidof [-sx] programname</code></p>
<p>-s    仅列出一个PID而不列出其他PID</p>
<p>-x    同时列出该程序可能的父程序的PID</p>
<p>SELinux（Security Enhanced Linux）</p>
<p>自主式存取控制（Discretionary Access Control，DAC）：就是之前一直使用的依据程序拥有者的rwx权限来决定存取能力</p>
<p>DAC的弊端：</p>
<ul>
<li>root有至高无上的权力，如果被cracker获得，会造成很大麻烦</li>
<li>使用者可以取得程序来变更文件资源的存取权限。不小心把权限设置成777等问题</li>
</ul>
<p>委任式存取控制：MAC</p>
<p>可以针对特定程序与特定的文件资源来进行权限控制。</p>
<p>也就是说，即使是root，在获得某些程序时，权限不一定是root</p>
<p><img src="/images/Vbird/16-1.1.png" alt=""></p>
<p>这是Apache网络服务使用DAC和MAC的不同结果</p>
<p>SELinux 的运作方式</p>
<p>通过MAC管理程序，目标是该程序能否读取的档案资源</p>
<ul>
<li>主体（Subject）：SELinux管理的程序，=process</li>
<li>目标（Object）：主题程序能否存取的目标资源，一般是文件系统</li>
<li>政策（Policy）：SELinux会依据某些服务来制订基本的存取安全性政策。这些政策内有详细的规则来指定不同的服务。<ul>
<li>targeted：针对网络服务的限制多，针对本机的限制较少，是预设政策，建议使用</li>
<li>minimum：由targeted修订，仅针对选择的程序进行保护</li>
<li>mls：完整的SELinux限制，限制方面较为严格</li>
</ul>
</li>
<li>安全性文本（security context）：主体与目标的安全性文本必须一致才能顺利存取。如果设置错误会产生权限不符的错误信息</li>
</ul>
<p>SELinux运作流程：</p>
<ol>
<li>程序主题请求SELinux验证<ol>
<li>SELinux分析政策规则</li>
</ol>
</li>
<li>进行安全性文本比对<ol>
<li>比对正确则通过</li>
<li>比对错误则AVC拒绝存取的信息说明</li>
</ol>
</li>
</ol>
<p>通过SELinux之后，程序主体还必须拥有必要的rwx权限才能继续进行对目标的存取</p>
<p>程序存取出现权限不符的情况时，就需要分析SELinux和DAC权限中可能出现的问题</p>
<p>安全性文本（security context）：放置在文件的inode中，读取文件时就可以进行比对</p>
<p>使用<code>ls -Z</code>可以查看安全性文本（必须先打开SELinux功能）</p>
<p>其中安全性文本主要分为三栏</p>
<p><code>identify:role:type</code></p>
<p>身份识别    角色    类型</p>
<p>身份识别（Identify）：</p>
<p>相当于账号方面的身份识别：</p>
<p>​    unconfined_u    不受限的用户，该文件产生于不受限的程序。预设的Bash是不受SELinux限制的。所以产生的文件都是不受SELinux限制的</p>
<p>​    system_u        系统用户，大部分是系统产生的文件</p>
<p>角色（Role）：</p>
<p>通过这个栏位，可以知道资料是属于程序、文件资源还是代表使用者</p>
<p>​    object_r        代表文件或目录等档案资源，也是最常见的</p>
<p>​    system_r    代表程序，一般使用者也会被指定为system_r</p>
<p>类型（Type）：最重要</p>
<p>一个主体程序能不能读取到档案资源与这个有关</p>
<p>​    type    在Object上称为Type</p>
<p>​    domain    在Subject上称为domain</p>
<p><code>ps -eZ</code></p>
<p>在一个设定好的领域（domain）内的程序只能读取由政策设定好的type的文件，即使这个文件的权限设置为777，如果domain type不对，也无法读取</p>
<p>SELinux的三种模式启动、关闭、观察</p>
<ul>
<li>enforcing模式：强制模式，代表SELinux运作中，并且已经正确地开始限制domain/type了</li>
<li>permissive：宽容模式，仅有警告信息，并不会限制domain/type，此模式用于debug</li>
<li>disabled：关闭，SELinux没有运作</li>
</ul>
<p><code>getenforce</code>获取目前的SELinux的模式</p>
<p><code>sestatus [-vb]</code>查看SELinux的政策</p>
<p>-v    检查/etc/sestatus.conf    内的文件与程序的安全性文本内容</p>
<p>-b    将目前政策的规则逻辑值取出，1/0 表示某些规则是否启动</p>
<p>更改SELinux的设定：</p>
<p>直接更改文件<code>/etc/selinux/config</code></p>
<p>改变政策后要重新开机才能生效</p>
<p>在Enforcing模式也可能因为一些设定导致SELinux让某些服务无法正常运作。此时可以把Enforcing模式改为permissive模式</p>
<p><code>setenforce [0|1]</code></p>
<p>0    permissive模式</p>
<p>1    Enforcing模式</p>
<p>无法在disable模式下切换</p>
<p>查询系统上面的全部规则启动与否。</p>
<p><code>sestatus -b</code>  <code>getsebool -a</code>列出目前系统上面所以SELinux规则的逻辑值</p>
<p>查询每个SELinux规则下的具体内容<code>seinfo</code></p>
<p>安装时并没有默认安装seinfo，从光盘（iso）安装</p>
<p>将iso文件挂载到/mnt目录</p>
<p><code>mount /dev/sr0 /mnt</code></p>
<p><code>yum install /mnt/Packages/setools-console-*</code></p>
<p>安装完成后就可以使用seinfo了</p>
<p><code>seinfo [-trub]</code></p>
<p>–all    列出SELinux的状态、规则逻辑值、身份识别、角色、类别等所以资讯</p>
<p>-u    列出所有身份识别的种类</p>
<p>-r    列出所有角色种类</p>
<p>-t    列出所有类别种类</p>
<p>-b    列出所有规则的逻辑值</p>
<p>查询主体类别能够读取的档案类型</p>
<p><code>sesearch [-A] [-s SubjectType] [-t ObjectType] [-b Boolean]</code></p>
<p>-A    列出后面信息中，允许【读取或放行】的相关信息</p>
<p>-b    后面还要接SELinux的规则</p>
<p><code>sesearch -A -s crond_t | grep spool</code>找出crond_t能够读取的档案类型</p>
<p><code>sesearch -A -s crond_t | grep admin_home_t</code>在用户根目录下建立的checktime为名的cron格式文件类型为admin_home_t，查询cron_t类型是否能读取。</p>
<p>发现居然可以读取，但是这是总体的咨询，没有针对某些规则读取，所以还是不能确定checktime能够被读取</p>
<p><code>semanage boolean -l | grep httpd_enable_homedirs</code></p>
<p><code>sesearch -A -b httpd_enable_homedirs</code></p>
<p>修改SELinux规则的Boolean值，setsebool</p>
<p><code>getsebool [policyname]</code></p>
<p><code>sersebool [-P] [policyname] [0|1]</code></p>
<p>SELinux安全文本修改</p>
<p><code>chcon [-R] [-t type] [-u user] [-r role] file\dir</code>手动修改</p>
<p>-R    连同此目录也同时修改</p>
<p>-t    后面接安全性文本的类型</p>
<p>-u    后面接身份识别</p>
<p>-r    后面接角色</p>
<p>-v    详细显示</p>
<p><code>chcon [-R] --reference=examplefile file\dir</code></p>
<p>–reference=    那某个文件作文范例</p>
<p>让SELinux预设目录下的SELinux type（恢复默认设置）</p>
<p><code>restorecon [-Rv] file/dir</code></p>
<p>-R    连同次目录</p>
<p>-v    verbose</p>
<p>预设目录安全性文本查询与修改</p>
<p><code>semanage {login|user|port|interface|fcontext|translation} -l</code></p>
<p><code>semanage fcontext -{a|d|m} [-frst] file_spec</code></p>
<p>fcontext    用于安全性文本方面的用途</p>
<p>-l    查询</p>
<p>-a    增加</p>
<p>-m    修改</p>
<p>-d    删除</p>
<p>将mycron文件夹预设值改为system_cron_spool_t</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">semanage fcontext -a -t system_cron_spool_t <span class="string">"/srv/mycron(/.*)?"</span></span><br><span class="line">semanage fcontext -l | grep <span class="string">'^/srv/mycron'</span></span><br></pre></td></tr></table></figure>
<p>setroubleshoot –&gt; 将错误信息写入 /var/log/messages与/var/log/setroubleshoot/*</p>
<p><code>rpm -qa | grep setroubleshoot</code>查询setroubleshoot是否安装</p>
<p>搭建一个FTP来实践SELinux，详细</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">useradd -s /sbin/nologin ftptest</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"myftp123"</span> | passwd --stdin ftptest</span><br><span class="line"></span><br><span class="line">yum install /mnt/Packages/vsftpd-3*</span><br><span class="line">systemctl start vsftpd</span><br><span class="line">systemctl <span class="built_in">enable</span> vsftpd</span><br><span class="line">netstat -tlnp</span><br><span class="line"></span><br><span class="line">cp -a /etc/securetty /etc/sysctl.conf /var/ftp/pub</span><br><span class="line"></span><br><span class="line">curl ftp://localhost/pub/</span><br><span class="line">curl ftp://localhost/pub/sysctl.conf	<span class="comment"># 可以查看</span></span><br><span class="line">curl ftp://localhost/pub/securetty		<span class="comment"># 不能查看</span></span><br><span class="line">chmod a+r /var/ftp/pub/securetty		<span class="comment"># 更改权限</span></span><br><span class="line">curl ftp://localhost/pub/securetty		<span class="comment"># 可以查看了</span></span><br><span class="line"><span class="comment"># 可见不能读取不一定是SELinux的问题</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"testing"</span> &gt; ~ftptest/test.txt</span><br><span class="line">cp -a /etc/hosts /etc/sysctl.conf ~ftptest/</span><br><span class="line">curl ftp://ftptest:myftp123@localhost/~/</span><br><span class="line">curl ftp://ftptest:myftp123@localhost/~/test.txt	<span class="comment"># 没有权限</span></span><br><span class="line">setenforce 0</span><br><span class="line">curl ftp://ftptest:myftp123@localhost/~/test.txt	<span class="comment"># 可以下载了</span></span><br><span class="line">setenforce 1</span><br></pre></td></tr></table></figure>
<p>一系列的遇到无法下载问题如何寻找原因的操作</p>
<p>包含：</p>
<ul>
<li><p>匿名者无法下载的问题</p>
</li>
<li><p>无法从家目录下载文件问题的分析和解决</p>
</li>
<li>一般账户从非正规目录上传、下载文件</li>
<li>无法变更FTP连接端口的问题分析与解决</li>
</ul>
<p>超出预计时间12分钟完成。下次要加油呀！</p>
<hr>
<h3 id="2018-7-28"><a href="#2018-7-28" class="headerlink" title="2018-7-28"></a>2018-7-28</h3><p>进个城不容易呀，九点钟整理了这周的指令进了 <a href="/2018/07/20/2018-07-20-Linuxcommands/">指令整理</a>，明天打扫打扫宿舍，带朋友转转嘉定，游个泳，下周再继续努力吧！</p>
<hr>
<h3 id="2018-7-27"><a href="#2018-7-27" class="headerlink" title="2018-7-27"></a>2018-7-27</h3><blockquote>
<p>不积跬步，无以至千里；不积小流，无以成江海。</p>
</blockquote>
<p>放大LVM的容量：</p>
<ul>
<li>VG中有剩余的容量，可以用vgextend加入新的PV</li>
<li>使用lvresize把多余的容量加入LV</li>
<li>文件系统的放大，EXT、XFS都支持放大，但只要EXT支持缩小。xfs_growfs即可</li>
</ul>
<p><code>lvresize -L +500M /dev/captainvg/captainlv</code></p>
<p><code>xfs_growfs /srv/lvm</code>  不用卸载设备也能操作</p>
<p>LVM thin Volume 时用时取的磁盘容量池，用多少容量分配多少容量</p>
<ul>
<li>从captainvg的剩余容量中取出1G，制作一个 lvpool</li>
<li>由captainvg内的lvpool产生名为captainthin的10GBLV装置</li>
<li>格式化为xfs文件系统，挂载于/srv/thin目录</li>
</ul>
<p><code>lvcreate -L 1G -T captainvg/lvpool</code></p>
<p><code>lvcreate -V 10G -T captainvg/lvpool -n captainthin</code></p>
<p>建立快照</p>
<ul>
<li>查看剩余容量：<code>vgdisplay captainvg</code></li>
<li>建立快照区：<code>lvcreate -s -l 26 -n captainsnap1 /dev/captainvg/captainlv</code>26是剩余的PE数量</li>
</ul>
<p>快照相当于原来LV的备份，建立后的容量和内容都会和原来的LV相同</p>
<p>快照挂载：<code>mount -o nouuid /dev/captainvg/captainsnap1 /srv/snapshot1</code></p>
<p>因为XFS不允许相同的UUID文件系统挂载，所以要加入nouuid参数</p>
<p>使用快照恢复系统</p>
<p>要恢复的文件量不能高于快照区所能承载的实际容量</p>
<p><img src="/images/Vbird/13-5.1.png" alt=""></p>
<p>移除LVM（重要啊）：</p>
<ul>
<li>卸载已挂载的LVM文件系统</li>
<li>使用 lvremove移除LV</li>
<li>使用 vgchange -a n VGname 让VG不再有Active标志</li>
<li>使用 vgremove 移除VG</li>
<li>使用 pvremove 移除PV</li>
<li>使用gdisk修改system ID</li>
</ul>
<p><code>umount /srv/thin/ /srv/lvm/;lvs captainvg;</code></p>
<p>删除顺序：thin -&gt; pool -&gt; LV</p>
<p><code>lvremove /dev/captainvg/captainthin /dev/captainvg/lvpool</code></p>
<p><code>lvremove /dev/captainvg/captainlv</code></p>
<p><code>vgchange -a n captainvg</code></p>
<p><code>vgremove captainvg</code></p>
<p><code>pvremove /dev/sda{4,5,6,7}</code></p>
<p><code>gdisk /dev/sda</code></p>
<p><strong>在RAID上面架构LVM系统</strong></p>
<p><code>gdisk /dev/sda</code> –&gt; fd00 sda{4,5,6}</p>
<p><code>mdadm --create /dev/md0 --auto=yes --level=5 --raid-devices=3 /dev/sda{4,5,6}</code></p>
<p><code>mdadm --detail /dev/md0 | grep UUID</code>复制UUID</p>
<p><code>vim /etc/mdadm.conf</code>增加<code>ARRAY /dev/md0 UUID=...</code></p>
<p><code>pvcreate /dev/md0</code></p>
<p><code>vgcreate raidvg /dev/md0</code></p>
<p><code>lvcreate -L 1.5G -n raidlv raidvg</code></p>
<p><code>lvscan</code></p>
<p><code>mkfs.xfs /dev/raidvg/raidlv</code></p>
<p><code>blkid /dev/raidvg/raidlv</code>复制UUID</p>
<p><code>vim /etc/fstab</code>添加<code>UUID=...    /srv/raidlvm    xfs    defaults    0 0</code></p>
<p><code>mkdir /srv/raidlvm</code></p>
<p><code>mount -a</code></p>
<p><code>df -Th</code></p>
<h4 id="第十五章-例行性工作-crontab"><a href="#第十五章-例行性工作-crontab" class="headerlink" title="第十五章 例行性工作 crontab"></a>第十五章 例行性工作 crontab</h4><p>Linux工作排程种类：at cron</p>
<p>at 处理一次性工作，需要atd服务支持，CentOS默认是开启的</p>
<p>crontab 处理例行性工作，循环执行某些工作。由crond服务支持</p>
<p>常见的例行性工作</p>
<ul>
<li>定时清理登录记录</li>
<li>通过logwatch分析登录记录</li>
<li>建立locate数据库，定时运行updatedb</li>
<li>建立mandb，自动更新man page的资料库</li>
<li>RPM软件登录记录</li>
<li>移除临时文件，定时执行tmpwatch命令</li>
<li>分析网络服务，WWW服务器软件，分析登录记录</li>
</ul>
<p>手动启动atd服务</p>
<p><code>systemctl restart atd</code>重启atd服务</p>
<p><code>systemctl enable atd</code>让服务开机自启</p>
<p><code>systemctl status atd</code>查看atd当前状态</p>
<p>at的工作方式</p>
<p>通过<code>at</code>指令或写入/var/spool/at目录</p>
<p>通过/etc/at.allow和/etc/at.deny两个档案进行at的使用限制</p>
<ul>
<li>在/etc/at.allow文件中的用户才能使用at</li>
<li>如果allow文件不存在，则寻找at.deny文件，不在这个文件中的用户就能使用at</li>
<li>如果两个文件都不存在，则只要root可以使用at</li>
</ul>
<p>一般的distribution中通常只保留一个at.deny空文件</p>
<p>实际运用：</p>
<p><code>at [-mldv] TIME</code></p>
<p>-m     at工作完成后，以email通知使用者工作已完成</p>
<p>-l    列出目前系统上所有用户的at排程</p>
<p>-d    取消一个在at排程中的工作</p>
<p>-v    可以使用较为明显的格式列出at排程中的工作列表</p>
<p>TIME格式：</p>
<p>HH:MM    在今日的HH：MM时刻运行，若今日的此时刻已经错过，则在明日的此时刻进行工作</p>
<p>HH:MM YYYY-mm-dd    在某年某月某日进行工作</p>
<p>HH:MM[am|pm] [Month][Date]同上</p>
<p>HH:MM[am|pm] +number [mins|hours|days|weeks] 在某个时间点，在加几个时间后进行</p>
<p><code>at -c [workcode]</code></p>
<p>-c    可以列出后面接的工作的指令内容</p>
<p>输入<code>at TIME</code>之后就可以开始写指令，使用指令时最好用绝对路径，按^D结束输入</p>
<p>at执行与终端环境无关，所有的stdin和stdout都会传送到执行者的邮箱中，想要在终端输出数据，可以使用<code>echo &quot;hello&quot; &gt; /dev/tty1</code>输出到制定的终端机</p>
<p>at的优点：可以在后台运行指令，不怕系统突然宕机</p>
<p>移除既定的事件：</p>
<p><code>atq</code>查询目前有多少工作安排</p>
<p><code>strm [jobnumber]</code>移除第jobnumber个工作</p>
<p><code>batch</code>：在系统空闲时才进行工作，CPU负载小于0.8</p>
<p><code>echo &quot;scale=100000; 4*a(1)&quot; | bc -lq &amp;</code>计算PI（用来使CPU负载）</p>
<p><code>uptime</code>查看工作负载</p>
<p><code>jobs</code>查看后台工作</p>
<p><code>kill -9 %1 %2..</code>删除工作</p>
<p>在系统平均负载低于0.8之后，batch设定的指令就会自动执行</p>
<p>循环执行的例行性工作排程</p>
<p>crond服务控制</p>
<p>同样有限制使用cron的账号列表</p>
<ul>
<li>/etc/cron.allow</li>
<li>/etc/cron.deny</li>
</ul>
<p>crontab的记录目录：/var/spool/cron，是以脚本的形式记录的，但是不要用vim直接编辑，会导致无法使用cron</p>
<p><code>crontab [-u username] [-l|-e|-r]</code></p>
<p>-u    只有root可以使用的参数。给其他用户建立/删除crontab工作</p>
<p>-e    编辑crontab的工作内容</p>
<p>-l    查阅crontab的工作内容</p>
<p>-r    移除所有的crontab工作内容，如果只想移除一项，请使用-e去编辑</p>
<p>输入<code>crontab -e</code>可以开始编辑例行命令。</p>
<p>格式</p>
<ul>
<li><code>分钟    小时    日期    月份    周    指令</code></li>
<li>周的0和7都代表星期天</li>
</ul>
<p>辅助字符：</p>
<p>*    此项的任意时刻都执行</p>
<p>,    时间点的分隔符：0 3,5 <em> </em> *表示每天的3点和5点时执行</p>
<p>-    表示时间端：0 8-12 <em> </em> *表示每天的8点到12点这段时间内，每个整点都执行一次command</p>
<p>/n    n代表数字，每隔n单位间隔的意思：<em>/5 </em> <em> </em> * 表示每五分钟执行一次</p>
<p>/etc/crontab文件结构</p>
<p>每一行比直接使用 crontab -e 要在命令前多加一个使用者的名称</p>
<p>MAILTO=root    如果例行性工作的指令发生错误时，将错误信息发给root</p>
<p>crond有三个执行脚本设置文件：</p>
<ul>
<li>/etc/crontab</li>
<li>/etc/cron.d/*</li>
<li>/etc/spool/cron/*</li>
</ul>
<p>/etc/cron.d/0hourly 设置在大约5分钟内的随机时间来执行 /etc/cron.hourly目录内的所以可执行文件，因此，放在/etc/cron.hourly中的文件必须是可以被直接执行的脚本</p>
<p>总结</p>
<ul>
<li>个人定制的例行性工作使用<code>crontab -e</code>来建立</li>
<li>系统维护使用<code>vim /etc/crontab</code>，重要系统工作，这样可以方便管理</li>
<li>自己开发的软件使用<code>vim /etc/cron.d/newfile</code>使用全新的设定文件</li>
</ul>
<p>注意事项：</p>
<ul>
<li>很多crontab同时启动会使系统非常繁忙，所以交错地设置启动时间可以减轻系统的压力</li>
<li>取消不必要的输出，可以使用 2&gt; /dev/null 把一些错误信息扔掉</li>
<li>经常性地检查/var/log/cron的内容来看看是不是有木马之类的东西混入</li>
<li>周的设定不可以与日月的设定共存</li>
</ul>
<p>anacron 执行关机期间未执行但还是需要的crontab</p>
<p>是由crontab来读取的，每小时主动执行一次</p>
<p>在 /etc/cron.hourly中</p>
<p><code>anacron [-sfn] [job]</code></p>
<p>-s    开始连续地执行各项工作，依据时间记录文件判断是否执行</p>
<p>-f    强制执行，不去判断时间记录文件的时间戳</p>
<p>-n    立即进行未进行的任务</p>
<p>job    由 /etc/anacrontab 定义的各项工作名称</p>
<p><code>anacron -u [job]</code></p>
<p>-u    仅更新时间记录文件的时间戳而不进行工作</p>
<p>anacron的执行流程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">由 /etc/anacrontab 分析到 cron.daily 這項工作名稱的天數為 1 天；</span><br><span class="line">由 /var/spool/anacron/cron.daily 取出最近一次執行 anacron 的時間戳記；</span><br><span class="line">由上個步驟與目前的時間比較，若差異天數為 1 天以上 (含 1 天)，就準備進行指令；</span><br><span class="line">若準備進行指令，根據 /etc/anacrontab 的設定，將延遲 5 分鐘 + 3 小時 (START_HOURS_RANGE 的設定)；</span><br><span class="line">延遲時間過後，開始執行後續指令，亦即『 run-parts /etc/cron.daily 』這串指令；</span><br><span class="line">執行完畢後， anacron 程式結束。</span><br></pre></td></tr></table></figure>
<p>如果CentOS有一段时间未开机，那么开机后就会有一段时间的系统忙碌，就是anacron在执行之前 未执行的各项工作</p>
<p>crond与anacron的关系：</p>
<ol>
<li>crond主动去读取 /etc/crontab, /var/spool/cron/*, /etc/cron.d/* 等设定文件，依据 分 时 日 月 周的时间设定去安排工作流程</li>
<li>依据 /etc/cron.d/0hourly 的设定，去 /etc/cron.hourly 目录下，执行所以该目录下的可执行文件</li>
<li>因为存在 /etc/cron.hourly/0anacron 文件的存在，crond每小时主动执行anacron，并呼叫 /etc/anacrontab 的设定文件</li>
<li>根据 /etc/anacrontab 的设定，依据天 月 周，去分析 /etc/cron.daily, /etc/cron.weekly, /etc/cron.monthly 内的执行文件，进行固定周期需要执行的命令</li>
</ol>
<p>个人实验：</p>
<ul>
<li>目的：在搭建了SS的VPS上建立一个crontab，在每天的12：00给我的邮箱发送ss昨天的log文件</li>
</ul>
<p>使用的系统是Ubuntu，安装mail<code>apt install mailutils</code></p>
<p>添加脚本 <code>~/scripts/mail.sh</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># This program will send a email to jakob</span></span><br><span class="line"><span class="comment"># The content of the mail is last 30 lines of ss's log file.</span></span><br><span class="line"></span><br><span class="line">PATH=/usr/<span class="built_in">local</span>/sbin:/usr/<span class="built_in">local</span>/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/<span class="built_in">local</span>/games:/snap/bin</span><br><span class="line"><span class="built_in">export</span> PATH</span><br><span class="line"></span><br><span class="line">Yesterday=$(date -d yesterday +%Y<span class="string">'-'</span>%m<span class="string">'-'</span>%d)</span><br><span class="line"></span><br><span class="line">cp mail.txt mail2.txt</span><br><span class="line"></span><br><span class="line">tail -n 10000 /var/<span class="built_in">log</span>/shadowsocks.log | grep <span class="variable">$Yesterday</span> | sed <span class="string">"s/<span class="variable">$Yesterday</span>//g"</span> | sed <span class="string">'s/:[0-9]*$//g'</span> | sed <span class="string">'s/[0-9]\&#123;2\&#125;:[0-9]\&#123;2\&#125;:[0-9]\&#123;2\&#125;//g'</span> | grep -v <span class="string">"Decrypt failed"</span> | uniq &gt; mail.txt</span><br><span class="line"></span><br><span class="line">unix2dos mail.txt</span><br><span class="line"></span><br><span class="line">DIFFERENT=$(diff mail.txt mail2.txt)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">"<span class="variable">$DIFFERENT</span>"</span> == <span class="string">""</span> ]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"There is no Log of yesterday detected. Or this scripts has been run twice today."</span> | mailx -s <span class="string">"Daily Log"</span> jakobzcooper@gmail.com</span><br><span class="line">        <span class="built_in">exit</span> 0</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"VPS Log of <span class="variable">$Yesterday</span>.\n Sent time: <span class="variable">$(date +%H:%M)</span>"</span> | mailx -s <span class="string">"Daily Log"</span> -A mail.txt jakobzcooper@gmail.com</span><br></pre></td></tr></table></figure>
<p>加入crontab</p>
<p><code>crontab -e</code></p>
<p><code>0 12 * * * bash /root/scripts/mail.sh</code></p>
<p>注意使用<code>timedatectl set-timezone Asia/Shanghai</code>指令把VPS的时区调成上海的</p>
<hr>
<h3 id="2018-7-26"><a href="#2018-7-26" class="headerlink" title="2018-7-26"></a>2018-7-26</h3><h4 id="第十四章-磁碟配额-Quota-与进阶文件系统管理"><a href="#第十四章-磁碟配额-Quota-与进阶文件系统管理" class="headerlink" title="第十四章 磁碟配额(Quota)与进阶文件系统管理"></a>第十四章 磁碟配额(Quota)与进阶文件系统管理</h4><p>一般用途(网络)：</p>
<ul>
<li>针对 www server</li>
<li>针对 mail server</li>
<li>针对 file server</li>
</ul>
<p>主机：</p>
<ul>
<li>限制群组所能使用的配额</li>
<li>限制某一使用者的配额</li>
<li>以link方式，使邮件可以作为配额限制</li>
</ul>
<p>Quota的局限性</p>
<ul>
<li>EXT文件系统只能针对整个filesystem。XFS可以使用project模式来设计不同目录的配额</li>
<li>核心必须支持Quota</li>
<li>只对一般身份用户有效</li>
<li>SELinux下，进行了Quota限制，只能对/home进行设定</li>
</ul>
<p>XFS文件系统不需要额外的记录文件</p>
<p>Quota对XFS文件系统的限制：</p>
<ul>
<li>分别针对用户，群组和目录</li>
<li>容量限制和文件数量限制<ul>
<li>限制inode用量</li>
<li>限制block用量</li>
</ul>
</li>
<li>警告和禁止（soft/hard）<ul>
<li>hard：绝不能超过此限额，超过会锁住该用户的磁盘使用权</li>
<li>soft：每次登入系统时，会收到磁盘即将满的警告信息，并且给予宽限时间</li>
</ul>
</li>
<li>宽限时间（grace time）如果在宽限时间内不进行磁盘处理，soft将变为hard，从而锁住磁盘</li>
</ul>
<p>实际操作：</p>
<ul>
<li>账号：五个账号，用户名从myquota1到myquota5，密码都是passwd，初始群组都是myquotagrp<ul>
<li>使用下方脚本可以自动创建</li>
</ul>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/<span class="built_in">local</span>/bin:/usr/<span class="built_in">local</span>/sbin:~/bin</span><br><span class="line"><span class="built_in">export</span> PATH</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create new group</span></span><br><span class="line">groupadd myquotagrp</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> username <span class="keyword">in</span> $(seq 1 5)</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">	user=<span class="string">"myquota<span class="variable">$username</span>"</span></span><br><span class="line">	useradd -g myquotagrp <span class="variable">$user</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="string">"password"</span> | passwd --stdin <span class="variable">$user</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<ul>
<li>容量限制：每个用户300MB磁盘容量，超过250MB开始警告，文件数量不限<ul>
<li>群组限制：限制myquotagrp磁盘容量为1GB</li>
<li>共享目录限制：共享目录设置为： /home/myquota/ ，限制容量为500MB</li>
<li>以上两个限制不能同时存在</li>
</ul>
</li>
<li>宽限时间设置：14天</li>
</ul>
<p>创建共享目录：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir /home/myquota</span><br><span class="line">chgrp myquotagrp /home/myquota</span><br><span class="line">chmod 2770 /home/myquota</span><br></pre></td></tr></table></figure>
<p>重启Quota以设置</p>
<p>XFS文件系统，检查文件系统：<code>df -hT /home</code></p>
<p>以前版本的文件系统可以使用<code>mount -o remount</code>重新挂载来启动Quota</p>
<p>XFS在挂载时就宣告了Quota的使用，无法使用<code>remount</code>来重新启动Quota</p>
<p>在/etc/fstab 中/home的第四栏加入下面的两个项目，然后重新挂载/home，才能重启Quota</p>
<p><code>/dev/mapper/centos-home  /home  xfs  defaults,usrquota,grpquota   0 0</code></p>
<p><code>umount /home</code></p>
<p><code>mount -a</code></p>
<p><code>mount | grep home</code></p>
<p>Quota限制项目</p>
<ul>
<li>uquota/usrquota/quota：针对用户的限制</li>
<li>gquota/grpquota：针对群组的限制</li>
<li>pquota/prjquota：针对目录的限制</li>
</ul>
<p>XFS文件系统Quota最重要命令：</p>
<p><code>xfs_quota -x -c &quot;command&quot; [mountpoint]</code></p>
<p>-x ：专家模式，开启后才能输入指令</p>
<p>-c ：后面加指令：</p>
<ul>
<li>print：列出主机内文件系统参数等</li>
<li>df：和<code>df</code>功能相同，列出磁盘使用情况及挂载点等</li>
<li>report：列出Quota项目，有-ugr，user，group，project，及-bi等参数</li>
<li>state：说明目前支持Quota的文件系统的信息</li>
</ul>
<p><code>xfs_quota -x -c &quot;df -h&quot; /home</code>列出/home挂载的设备，空间使用状态</p>
<p><code>xfs_quota -x -c &quot;report -ubih&quot; /home</code>列出/home的所有用户的Quota限制值</p>
<p><code>xfs_quota -x -c &quot;state&quot;</code>列出当前支持Quota的文件系统是否启动了Quota功能</p>
<p>设置容量限制：</p>
<p><code>xfs_quota -x -c &quot;limit [-ug] b[soft|hard]=N i[soft|hard]=N name&quot;</code></p>
<p>针对user/group来限制</p>
<ul>
<li>bsoft/bhard：block的限制值，也就是磁盘容量的限制值，可以加单位</li>
<li>isoft/ihard：inode的限制值</li>
<li>name：username groupname</li>
</ul>
<p>设置宽限时间：</p>
<p><code>xfs_quota -x -c &quot;timer [-ug] [-bir] Ndays&quot;</code></p>
<p>脚本：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/<span class="built_in">local</span>/bin:/usr/<span class="built_in">local</span>/sbin:~/bin</span><br><span class="line"><span class="built_in">export</span> PATH</span><br><span class="line"></span><br><span class="line"><span class="comment"># This Program will set the quota to</span></span><br><span class="line"><span class="comment">#	 user:</span></span><br><span class="line"><span class="comment">#		myquota1~5 bsoft=250M bhard=300M no inode limit</span></span><br><span class="line"><span class="comment">#	 group:</span></span><br><span class="line"><span class="comment">#	 	myquotagrp bsoft=950M bhard=1G   no inode limit auch</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># History	20180726	First release</span></span><br><span class="line"><span class="comment"># Author	Captainxu</span></span><br><span class="line"><span class="keyword">for</span> username <span class="keyword">in</span> $(seq 1 5)</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">	user=<span class="string">"myquota<span class="variable">$username</span>"</span></span><br><span class="line">	xfs_quota -x -c <span class="string">"limit -u bsoft=250M bhard=300M <span class="variable">$user</span>"</span> /home</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line">xfs_quota -x -c <span class="string">"limit -g bsoft=950M bhard=1G myquotagrp"</span> /home</span><br><span class="line"></span><br><span class="line">xfs_quota -x -c <span class="string">"timer -ug -b 14days"</span> /home</span><br><span class="line"></span><br><span class="line"><span class="comment"># Echo output</span></span><br><span class="line"></span><br><span class="line">xfs_quota -x -c <span class="string">"report -ubih"</span> /home</span><br><span class="line">xfs_quota -x -c <span class="string">"report -gbih"</span> /home</span><br><span class="line">xfs_quota -x -c <span class="string">"state"</span> /home</span><br></pre></td></tr></table></figure>
<p>针对目录限制</p>
<p>更改/etc/fstab的值，删除grpquota，加入prjquota，卸载/home重新挂载</p>
<p><code>xfs_quota -x -c &quot;state&quot;</code>来查看是否打开project的Quota功能</p>
<p>目录的设定需要 专案名称、专案识别码 来规范（专案=专用文件？）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"11:/homr/myquota"</span> &gt;&gt; /etc/projects 	<span class="comment"># 指定专案识别码与目录对</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"myquotaproject:11"</span> &gt;&gt; /etc/projid		<span class="comment"># 专案名称与识别码对</span></span><br><span class="line"></span><br><span class="line">xfs_quota -x -c <span class="string">"project -s myquotaproject"</span>	<span class="comment"># 初始化专案名称</span></span><br></pre></td></tr></table></figure>
<p>目录设置限制 450M/500M</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xfs_quota -x -c <span class="string">"limit -p bsoft=450M bhard=500M myquotaproject"</span> /home</span><br><span class="line">xfs_quota -x -c <span class="string">"report -pbih"</span> /home</span><br></pre></td></tr></table></figure>
<p>对目录的限制，即使root也受影响</p>
<p>xfs_quota 其他指令</p>
<ul>
<li>-c “disable” 暂时取消quota限制，但系统其实还是在计算quota</li>
<li>-c “enable” 启用Quota，是对disable的恢复</li>
<li>-c “off” 完全关闭Quota限制</li>
<li>-c “remove” 移除quota的限制设定。取消project的设定只需要<code>xfs_quota -x -c &quot;remove -p&quot; /home</code></li>
</ul>
<p>EXT文件系统可以参考上一般的鸟哥Linux</p>
<p>将不在一个分区的目录共同限制一个Quota，例子：</p>
<ol>
<li>将/var/spool/mail目录完整复制到/home 下</li>
<li>利用 <code>ln -s /home/mail/ /var/spool/mail</code>建立链接</li>
<li>给/home设置Quota限额</li>
</ol>
<p>磁盘阵列RAID（Redundant Arrays of Independent Disks）</p>
<p>RAID-0 等量模式，效能最佳</p>
<ul>
<li>把磁盘分割为等量的区块</li>
<li>放入文件时，文件会等量地被放在多个磁盘中</li>
<li>如果有一个磁盘损毁，就会导致整个文件损毁</li>
<li>当较小容量的磁盘被用完后，存储效能就会变差</li>
</ul>
<p>RAID-1映射模式，完整备份</p>
<ul>
<li>会在两个磁盘上完整的放入同样的文件，因此被称为mirror</li>
<li>软件磁盘整列的情况下效能会很差</li>
<li>硬件磁盘阵列下效能会好一些</li>
</ul>
<p>兼顾效能与安全性：</p>
<p>RAID 1+0，RAID 0+1</p>
<p>RAID 1+0</p>
<ul>
<li>共四个硬盘</li>
<li>每两个组成两个RAID1</li>
<li>再将两个RAID1组成RAID0</li>
</ul>
<p>RAID 0+1则相反</p>
<p>RAID-5</p>
<ul>
<li>至少三个磁盘</li>
<li>加入同位检查资料（Parity），这个资料会记录其他磁盘的备份资料</li>
<li>每次写入时，都会有Parity被记录在不同的硬盘</li>
<li>RAID-5的总体容量是：总容量 - 一个磁盘的容量</li>
<li>仅能支撑一个磁盘损毁的情况</li>
</ul>
<p>RADI-6：在RAID-5的基础上，可以支撑两个硬盘损毁，硬盘容量也会少两颗</p>
<p>Spare Disk：平时不再磁盘阵列中的一颗磁盘，当有磁盘损坏时，自动使用这颗磁盘代替，如果有热插拔功能就可以再磁盘工作时，取下坏掉的硬盘，安装一颗好的硬盘，再次设置为 Spare Disk</p>
<p>磁盘阵列的优点：</p>
<ul>
<li>保证资料安全性</li>
<li>读写效能提升 RAID 0</li>
<li>增大容量</li>
</ul>
<p>软件RAID、硬件RAID</p>
<p>硬件磁盘阵列通过磁盘阵列卡达成阵列。通过磁盘阵列卡来处理RAID任务，效能方面会很好。但是好的磁盘阵列卡很贵，便宜的磁盘阵列卡又不能支持高级功能。因此又产生了软件磁盘阵列。</p>
<p>软件RAID的设备名一般是/dev/md[01234]</p>
<p>CentOS 提供mdadm来进行软件磁盘阵列搭建。以分区为单位，支持RAID 0 RAID 1 RAID 5 Spare Disk等，拥有热插拔功能</p>
<p>设置软件RAID</p>
<p><code>mdadm --detail /dev/md0</code>显示详细信息</p>
<p><code>mdadm --create /dev/md[0-9] --auto=yes --level=[015] --chunk=NK --raid-devices= N --spare-devices=N /dev/sdx /dev/hdx</code>建立RAID</p>
<p>–auto=yes  决定后面接的软件RAID装置，即/dev/md0, /dev/md1..</p>
<p>–chunk=NK  设置chunk 的大小，一般64K或512K</p>
<p>–raid-devices=N  使用几个分区作为RAID的装置</p>
<p>–spare-devices=N  使用几个分区作为 Spare Disk</p>
<p>–level=[015]  设置RAID的等级，建议只用0，1，5即可</p>
<p>实际搭建RAID 5：</p>
<ul>
<li>使用4个分区，每个分区1GB</li>
<li>使用1个分区作为Spare Disk，同样1GB</li>
<li>chunk 设置为512K</li>
<li>将RAID5 挂载到 /srv/raid下</li>
</ul>
<p><code>gdisk /dev/sda</code>在剩余的9G中进行实验</p>
<p>文档code为 FD00</p>
<p><code>partprobe</code> <code>lsblk</code></p>
<p>查看分区情况</p>
<p>开始建立RAID</p>
<p><code>mdadm --create /dev/md0 --auto=yes --level=5 --chunk=256K --raid-devices=4 --spare-devices=1 /dev/sda{4,5,6,7,8}</code></p>
<p><code>mdadm --detail /dev/md0</code> </p>
<p><code>cat /proc/mdstat</code>都可以查看RAID情况</p>
<blockquote>
<p> 第一行部分：指出 md0 為 raid5 ，且使用了 vda8, vda7, vda6, vda5 等四顆磁碟裝置。每個裝置後面的中括號 [] 內的數字為此磁碟在 RAID 中的順序 (RaidDevice)；至於 vda9 後面的 [S] 則代表 vda9 為 spare 之意。</p>
</blockquote>
<blockquote>
<p> 第二行：此磁碟陣列擁有 3142656 個block(每個 block 單位為 1K)，所以總容量約為 3GB， 使用 RAID 5 等級，寫入磁碟的小區塊 (chunk) 大小為 256K，使用 algorithm 2 磁碟陣列演算法。 [m/n] 代表此陣列需要 m 個裝置，且 n 個裝置正常運作。因此本 md0 需要 4 個裝置且這 4 個裝置均正常運作。 後面的 [UUUU] 代表的是四個所需的裝置 (就是 [m/n] 裡面的 m) 的啟動情況，U 代表正常運作，若為 _ 則代表不正常。</p>
</blockquote>
<p>格式化并挂载</p>
<p><code>mkfs.xfs -f -d su=256k,sw=3 -r extsize=768k /dev/md0</code></p>
<p><code>mkdir /srv/raid</code></p>
<p><code>mount /dev/md0 /srv/raid</code></p>
<p><code>df -Th /srv/raid</code></p>
<p>RAID出错处理</p>
<p><code>mdadm --manage /dev/md[0-9] [--add device] [--remove device] [--fail device]</code></p>
<p>–add        将后面的设备加入这个RAID</p>
<p>–remove    将后面的设备从这个RAID移除</p>
<p>–fail        将后面的设备设置为出错状态</p>
<p>当一个磁盘坏掉后，</p>
<ul>
<li>–remove the disk</li>
<li>关机，拔出坏的磁盘，插上好的</li>
<li>–add the new disk</li>
</ul>
<p>开机自动启动RAID并自动挂载：</p>
<p>获取RAID的UUID：<code>mdadm --detail /dev/md0</code></p>
<p>进入设定文件 /etc/mdadm.conf</p>
<p>添加<code>ARRAY /dev/md0 UUID=...</code></p>
<p>添加开机自动挂载</p>
<p><code>blkid /dev/md0</code>获取UUID，和上一个不同</p>
<p><code>vim /etc/fstab</code>添加<code>UUID=...    /srv/raid    xfs    defaults    0 0</code></p>
<p>测试成功即可</p>
<p>关闭RAID</p>
<p><code>umount /srv/raid</code>卸载</p>
<p><code>vim /etc/fstab</code>    删除刚刚添加的行</p>
<p>覆盖RAID的metadata和XFS的superblock</p>
<p><code>dd if=/dev/zero of=/dev/md0 bs=1M count=50</code></p>
<p><code>mdadm --stop /dev/md0</code>关闭</p>
<p>覆盖掉记录在其他磁盘上的RAID的信息</p>
<p><code>dd if=/dev/zero of=/dev/sda[45678] bs=1M count=10</code></p>
<p><code>cat /proc/mdstat</code>上面都成功之后会显示unused devices: \&lt;none></p>
<p>删除/etc/mdadm.conf 里面新增的行（或者注释掉）</p>
<p>LVM(Logical Volume Manager) 可以弹性调整file system的容量。</p>
<p>逻辑卷轴管理员</p>
<ul>
<li>PV，Physical Volume 实体卷轴：LVM最底层的卷轴</li>
<li>VG，Volume Group    卷轴群组，将许多PV整合成一个VG</li>
<li>PE，Physical Extent     实体范围区块，默认4MB，是LVM的最小储存区块</li>
<li>LV，Logical Volume      逻辑卷轴，VG被切成LV，和磁盘分区有同样的性质</li>
</ul>
<p>LVM的弹性变更原理是：把原本LV内的PE转移到别的设备中以降低LV容量，把别的设备的PE加进来以增加容量</p>
<p>磁盘-&gt;PV-&gt;VG-&gt;LV-&gt;格式化-&gt;挂载</p>
<p>资料写入LV的方式</p>
<ul>
<li>线性方式（linear）：完整地写入设备，一个设备容量用完后才使用下一个</li>
<li>交错方式（triped）：将资料拆分，分别写入不同的设备，效能较高，安全性差，尽量别用（可以RAID追求效能）</li>
</ul>
<p>LVM的最重要的要点是可以弹性地管理磁盘容量，所以不求高效能低稳定性</p>
<p>实际操作：</p>
<ul>
<li>更改之前的RAID分区，system ID改为8E00（如果没有做前面的则新建分区即可）</li>
<li>将全部分区整合为一个VG，名称设为captainvg，PE大小为16MB</li>
<li>建立名为captainlv的LV，容量为2G</li>
<li>格式化为xfs文件系统，挂载在/srv/lvm中</li>
</ul>
<p><code>gdisk /dev/sda</code> -&gt; <code>t</code> -&gt; <code>[45678]</code> -&gt; <code>8E00</code> -&gt; <code>w</code></p>
<p>PV阶段：</p>
<ul>
<li>pvcreate   将分区建立为PV</li>
<li>pvscan      搜索目前任何具有PV的磁碟</li>
<li>pvdisplay   显示出目前系统的PV状态</li>
<li>pvremove  移除PV属性</li>
</ul>
<p><code>pvscan</code>会发现之前虽然没有创建过PV，但是也有一个LVmh存在</p>
<p><code>pvcreate /dev/sda{4,5,6,7}</code></p>
<p><code>~这一步发生了问题，显示 Device /dev/sda[4567] excluded by a filter</code></p>
<p>根据网上的信息：</p>
<ol>
<li>尝试重新格式化</li>
</ol>
<p><img src="/images/Vbird/13-3.1.png" alt=""></p>
<p>在做后面的题目时发现在将[4567]四个分区的 system ID改回fd00后，使用<code>lsblk</code>查看磁盘分区情况，发现之前的md0还在，说明在关闭RAID时出现一些问题，现在重新关闭一次。</p>
<p>重新执行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@study ~]<span class="comment"># dd if=/dev/zero of=/dev/md0 bs=1M count=50</span></span><br><span class="line">[root@study ~]<span class="comment"># mdadm --stop /dev/md0</span></span><br><span class="line">mdadm: stopped /dev/md0</span><br><span class="line">[root@study ~]<span class="comment"># dd if=/dev/zero of=/dev/vda5 bs=1M count=10</span></span><br><span class="line">[root@study ~]<span class="comment"># dd if=/dev/zero of=/dev/vda6 bs=1M count=10</span></span><br><span class="line">[root@study ~]<span class="comment"># dd if=/dev/zero of=/dev/vda7 bs=1M count=10</span></span><br><span class="line">[root@study ~]<span class="comment"># dd if=/dev/zero of=/dev/vda8 bs=1M count=10</span></span><br><span class="line">[root@study ~]<span class="comment"># dd if=/dev/zero of=/dev/vda9 bs=1M count=10</span></span><br></pre></td></tr></table></figure>
<p>后再次尝试创建PV</p>
<p><img src="/images/Vbird/13-4.1.png" alt=""></p>
<p>看到这个success我眼泪都出来了。。</p>
<p>那么继续吧</p>
<p><code>pvdisplay /dev/sda5</code>查看一下，Allocatable表示是否已被分配</p>
<p>VG阶段：</p>
<ul>
<li>vgcreate 建立VG</li>
<li>vgscan 搜寻存在的VG</li>
<li>vgdisplay  显示系统上面的VG状态</li>
<li>vgextend   在VG内增加额外的PV</li>
<li>vgreduce    在VG内删除PV</li>
<li>vgchange    设定VG是否启动</li>
<li>vgremove    删除一个VG</li>
</ul>
<p><code>vgcreate [-s N[mgt]] VGname PVname</code></p>
<p>-s   后接PE的大小，单位可以是m g t都行</p>
<p><code>vgcreate -s 16M captainvg /dev/vda{4,5,6}</code></p>
<p> 显示  Volume group “captainvg” successfully created</p>
<p><code>vgextend captainxu /dev/sda7</code>把sda7也加入VG</p>
<p>LV阶段：</p>
<ul>
<li>lvcreate  建立LV</li>
<li>lvscan      搜寻已有的LV</li>
<li>lvdisplay  显示LV的信息</li>
<li>lvextend   增加LV容量</li>
<li>lvreduce    减少LV容量</li>
<li>lvremove   删除一个LV</li>
<li>lvresize      对LV进行大小调整</li>
</ul>
<p><code>lvcreate [-L/l N[mgt]] [-n LVname] VGname</code></p>
<p>-L   接容量，必须是PE的倍数</p>
<p>-l     接个数，也就是PE的个数</p>
<p>-n    接LV的名称</p>
<p><code>lvcreate -L 2G -n captainlv captainvg</code></p>
<p><code>lvdisplay /dev/captainvg/captainlv</code></p>
<p>文件系统阶段：</p>
<p><code>mkfs.xfs /dev/captainvg/captainlv</code></p>
<p><code>mkdir /srv/lvm</code></p>
<p><code>mount /dev/captainvg/captainlv /srv/lvm</code></p>
<p><code>df -Th /srv/lvm</code></p>
<p>看到：14.3.3 放大LV的容量</p>
<hr>
<h3 id="2018-7-25"><a href="#2018-7-25" class="headerlink" title="2018-7-25"></a>2018-7-25</h3><p><strong>账号管理</strong></p>
<p><code>useradd [-u UID] [-g initgroup] [-G minorgroup] [-mM] [-c info] [-d homedir] [-s shell] username</code></p>
<p>-u 指定UID、-g 初始组、-G 次要组、-c  /etc/passwd第五栏的说明（info）、-d 指定home路径、-s 指定shell，默认bash</p>
<p>-M  强制不要创建home目录（系统账号默认）</p>
<p>-m  强制创建home目录（一般账号默认）</p>
<p>-e date  格式为YYYY-MM-DD的日期，可写入/etc/shadow的第八字段，即账号失效日期</p>
<p>-f   指定密码是否会失效，0为立即失效，-1为永不失效</p>
<p>-r   创建系统账号</p>
<p>创建的home目录默认权限为700</p>
<p>简单的使用<code>useradd username</code>来创建账号就好了，有很多默认值</p>
<p>用户自己创建的系统账号一般UID是从100起算的（</p>
<p><strong>但是我创建的系统账号UID=699</strong>，之前创建的三个账号UID也是从1000开始的，可能我使用的CentOS 7 保留的系统UID是1-999</p>
<p><code>useradd -D</code>可以打印出<code>useradd</code>的参考文件/etc/default/useradd</p>
<ul>
<li>可以更改里面的内容例如HOME 是<code>~</code>目录的父目录</li>
</ul>
<p>GID=100的群组为user，默认创建账户初始群组为user</p>
<ul>
<li>私有群组机制：系统自动创建一个与用户名相同的群组，这样配置的保密性更高。</li>
<li>公共群组机制：以GROUP=100为新账号的初始群组，因此每个账户都属于user组，可以共享/home目录内的数据</li>
</ul>
<p>HOME=/home：表示用户目录的基准目录</p>
<p>INACTIVE=-1：密码失效的天数</p>
<p>EXPIRE=：账户失效的日期</p>
<p>SHELL=/bin/bash：默认使用的shell程序名</p>
<p>SKEL=/etc/skel：创建用户目录的样本目录（/home/captain1在创建时就是用这个目录完全地复制过去）</p>
<p>CREATE_MAIL_SPOOL=yes：创建使用者的 mailbox，也就是在/var/spool/mail/目录下创建一个账户文件</p>
<p>UID/GID 样本文件：/etc/login.defs</p>
<p>文件内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">MAIL_DIR        /var/spool/mail	&lt;==用户默认邮件信箱放置目录</span><br><span class="line"></span><br><span class="line">PASS_MAX_DAYS   99999	&lt;==/etc/shadow 内的第 5 栏，多久需变更口令日数</span><br><span class="line">PASS_MIN_DAYS   0	&lt;==/etc/shadow 内的第 4 栏，多久不可重新配置口令日数</span><br><span class="line">PASS_MIN_LEN    5	&lt;==口令最短的字符长度，已被 pam 模块取代，失去效用！</span><br><span class="line">PASS_WARN_AGE   7	&lt;==/etc/shadow 内的第 6 栏，过期前会警告的日数</span><br><span class="line"></span><br><span class="line">UID_MIN         500	&lt;==使用者最小的 UID，意即小于 500 的 UID 为系统保留</span><br><span class="line">UID_MAX       60000	&lt;==使用者能够用的最大 UID</span><br><span class="line">GID_MIN         500	&lt;==使用者自定义组的最小 GID，小于 500 为系统保留</span><br><span class="line">GID_MAX       60000	&lt;==使用者自定义组的最大 GID</span><br><span class="line"></span><br><span class="line">CREATE_HOME     yes	&lt;==在不加 -M 及 -m 时，是否主动创建用户家目录？</span><br><span class="line">UMASK           077     &lt;==用户家目录创建的 umask ，因此权限会是 700</span><br><span class="line">USERGROUPS_ENAB yes     &lt;==使用 userdel 删除时，是否会删除初始群组</span><br><span class="line">MD5_CRYPT_ENAB yes      &lt;==口令是否经过 MD5 的加密机制处理</span><br></pre></td></tr></table></figure>
<p>新创建的账户密码为空，此时是被锁定的，无法登录，需要设置密码</p>
<p><code>passwd [--stdin]</code>所有用户都可以使用，用来更改自己的密码</p>
<p><code>passwd [-l][-u][--stdin][-S][-n days][-x days][-w days][-i date] user</code></p>
<p>此指令只能由root下达</p>
<p>–stdin：可以通过一个管线来作为要更改的密码输入</p>
<p>-l  ：lock，使密码失效，会在/etc/shadow第二栏加上！</p>
<p>-u ：unlock，解锁</p>
<p>-S ：列出口令相关的参数</p>
<p>-n ：不可修改密码的天数，shadow第4字段</p>
<p>-x ：必须修改密码的天数，shadow第5字段</p>
<p>-w：密码过期的警告天数，shadow第6字段</p>
<p>-i  ：密码失效日期，shadow第7字段</p>
<p><code>chage [-ldEImMW] username</code>详细显示口令参数</p>
<p><code>-l</code> ：列出该账户的详细口令参数</p>
<p>-d YYYY-MM-DD：修改shadow第3字段（最近修改密码日期），</p>
<p>-E YYYY-MM-DD：修改shadow第8字段（账户失效日）</p>
<p><code>-I days</code>：修改shadow第7字段（密码失效日）</p>
<p>-m ：修改第4字段（口令最短保留天数）</p>
<p>-M ：修改第5字段（口令多久需要变更）</p>
<p>-W ：修改第6字段（口令过期前警告天数）</p>
<p>以上：口令==密码</p>
<p>想要让使用者在第一次登录时强制更改口令：<code>chage -d 0 username</code></p>
<p>不小心设置错了参数，可以到/etc/passwd 和 /etc/shadow中去修改对应的字段</p>
<p>也可以使用指令<code>usermod</code></p>
<p><code>usermod [-cdegGlsuLU] username</code>修改用户参数</p>
<p>-c  账户说明，passwd文件第5栏</p>
<p>-d  <code>~</code>目录，passwd文件第6栏</p>
<p>-e YYYY-MM-DD shadow第八字段</p>
<p>-f  days shadow第七字段</p>
<p>-g  初始群组，passwd的GID字段</p>
<p>-G  次要群组，group文件</p>
<p>-a   添加次要群组的支持</p>
<p>-l    修改账号名称，passwd第一栏</p>
<p>-s    shell的文件路径</p>
<p>-u    UID数字，passwd第三栏</p>
<p>-L    冻结用户口令，lock</p>
<p>-U   解冻用户口令，unlock</p>
<p><code>usermod -a -G vbird1,vbird2,vbird3 dmtsai</code>可以不影响对原本已经支持的次要群组的情况下，加入新的群组</p>
<p><code>userdel [-r] username</code>删除用户及其数据</p>
<p>-r   连同~目录一起删除</p>
<p>一般可以使用<code>find / -user username</code>找出用户的所有文件，并删除</p>
<p><code>finger</code>命令（为什么我的CentOS 7没有这个命令）</p>
<p><code>finger [-s] username</code></p>
<p>-s  仅列出用户的账号，全名、终端机代号与登录时间等</p>
<p><code>chfn</code>change finger information，没有finger命令但是有这个命令</p>
<p><code>chfn [-foph] username</code></p>
<p>-f   接全名</p>
<p>-o  办公室房间号码</p>
<p>-p  办公室电话号码</p>
<p>-h  家里电话号码</p>
<p>。。。。。一般用不到吧</p>
<p><code>chsh</code>change shell</p>
<p><code>chsh [-ls]</code></p>
<p><code>-l</code> 列出系统上所有的shell</p>
<p>-s    配置修改自己的shell</p>
<p><code>id</code>列出正在使用的用户的所有相关信息</p>
<p><code>id username</code>列出其他用户。。。</p>
<p><code>groupadd [-g GID] [-r] groupname</code>新增群组</p>
<p>-r  创建系统群组</p>
<p><code>groupmod [-g GID] [-n groupname] groupname</code></p>
<p>-n  修改组名</p>
<p>不要随意更改GID，会导致系统资源错乱</p>
<p><code>groupdel groupname</code>删除群组</p>
<p>不能删除某个用户的有效群组（主组）</p>
<p><code>gpasswd</code>群组管理员创建</p>
<p><code>gpasswd [-A user1, ...] [-M user3, ...] groupname</code></p>
<p><code>gpasswd [-rR] groupname</code></p>
<p>无参数时 表示给group一个口令</p>
<p>-A 将后面的user设为 group的群组管理员</p>
<p>-M  将某些账号加入这个群组</p>
<p>-r    将group的口令移除</p>
<p>-R    让group的口令栏失效</p>
<p>群组管理员可用：</p>
<p><code>gpasswd [-ad] user groupname</code></p>
<p>-a   将某位使用者加入group中</p>
<p>-d   将某位使用者移除</p>
<p>添加组testgroup，设置captainxu为管理员，并把captain1加入组中</p>
<p><img src="/images/Vbird/12-2.1.png" alt=""></p>
<p><img src="/images/Vbird/12-2.2.png" alt=""></p>
<p>将用户的shell指定为 <code>/sbin/nologin</code>后，用户就无法登录主机了</p>
<p>让三个用户可以在同一个目录工作，并且他们还都拥有各自的~目录和私有群组</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">groupadd projecta</span><br><span class="line"></span><br><span class="line">useradd -G projecta -c <span class="string">"projecta user"</span> pro1</span><br><span class="line">useradd -G projecta -c <span class="string">"projecta user"</span> pro2</span><br><span class="line">useradd -G projecta -c <span class="string">"projecta user"</span> pro3</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"password"</span> | passwd --stdin pro1</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"password"</span> | passwd --stdin pro2</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"password"</span> | passwd --stdin pro3</span><br><span class="line"></span><br><span class="line">mkdir /srv/projecta</span><br><span class="line">chgrp projecta /srv/projecta</span><br><span class="line">chmod 2770 /srv/projecta <span class="comment"># 添加SGID</span></span><br><span class="line">ll -d /srv/projecta</span><br></pre></td></tr></table></figure>
<p><strong>ACL(access control list)的使用</strong></p>
<p>目的：提供对使用者、群组、目录默认属性的rwx权限设置</p>
<p>查看文件系统对ACL的支持：</p>
<p><code>mount | grep &#39;/ type&#39;</code> </p>
<p><code>dumpe2fs -h /dev/mapper/centos-root</code></p>
<p>取得某个文件/目录的ACL配置项目</p>
<p><code>setfacl [-bkRd] [{-m|-x} acl参数] 目标文件名</code></p>
<p>-m  配置后续的 ACL 参数 给文件</p>
<p>-x    删除后续的 ACL 参数</p>
<p>-b    移除所有的 ACL 参数</p>
<p>-k     移除默认的 ACL 参数</p>
<p>-R     递归配置 ACL == 此目录也一同配置</p>
<p>-d     配置默认 ACL 参数</p>
<p><code>setfacl -m u:captainxu:rx file1</code></p>
<p><code>getfacl filename</code>可以查看文件详细的权限信息</p>
<p>参数相同</p>
<p>其中，mask表示有效权限，只有在其中的权限，用户才能拥有</p>
<p>通过<code>setfacl -m m:rwx file1</code>来设置</p>
<p>将用户对目录的权限设为r-x之后，就可以让该用户只能进入而不能改变其中的文件了</p>
<p>让目录的子目录和文件继承ACL：</p>
<p><code>setfacl -m d:u:myuser1:rx /srv/project1</code></p>
<p>d: 设置后，产生了新的default属性</p>
<p><code>setfacl -b dirname</code>取消ACL属性</p>
<p>身份切换的必要性：</p>
<ul>
<li>平时使用一般账号，能避免一些严重错误的指令（<code>rm -rf /*</code>），只有在配置系统时才使用root账号</li>
<li>以较低权限启动服务，避免apache之类的程序被crack后导致系统崩溃</li>
<li>软件限制：telnet  ssh等可以限制root登录</li>
</ul>
<p><code>su [-lm] [-c command] username</code>切换用户</p>
<p>-   ：一条短杠加用户名代表使用 login-shell变量文件读取登录系统，没有用户名默认为root</p>
<p><code>-l</code>：类似 -</p>
<p>-m ：== -p  表示使用目前的环境配置</p>
<p>-c  ：仅进行一次命令</p>
<p>不加任何参数表示使用 non-login shell方式，PATH、MAIL等变量都将保持为当前用户的</p>
<p><code>sudo [-b] [-u user] command</code></p>
<p>-b   后台运行命令</p>
<p>-u   使用user的身份运行命令，默认为root</p>
<p>可以在上面的command使用<code>sh -c &quot;commands&quot;</code>执行多个命令</p>
<p><code>visudo</code>和 /etc/sudoers</p>
<p>只有在 /etc/sudoers 文件中的用户才能使用sudo</p>
<p>可以用<code>visudo</code>来修改/etc/sudoers，用法与vim相同</p>
<p>在含有：root ALL=(ALL) ALL 的行下方，增加形如：captainxu  ALL=(ALL)  ALL ，就可以让用户captainxu可以使用sudo</p>
<p>上面的四个值的含义是：使用者账号、登录者来源主机名、（可切换的身份）、可下达的指令</p>
<p>注意，注释可下达的指令时，必须使用绝对路径</p>
<p>在使用者账号前加上%表示群组，添加群组后，在此群组中的用户也可以使用sudo</p>
<p>增加NOPASSWD，可以免除输入密码使用sudo</p>
<p><code>%wheel    ALL=(ALL)    NOPASSWD:ALL</code></p>
<p>注意在给与：passwd等命令的root权限时，用户是可以改变root的密码的，所以要限制用户的命令参数</p>
<p><code>myuser1    ALL=(root)    !/usr/bin/passwd, /usr/bin/passwd [A-Za-z]*, !/usr/bin/passwd root</code>    对passwd root的限制一定要在 允许 passwd [a-zA-Z]* 后面</p>
<p>以上加上<code>！</code>代表不能运行的命令和参数</p>
<p>这样就不能运行<code>passwd</code> 和 <code>passwd root</code>了，也就不能改变root 的密码了</p>
<p>账户别名、命令别名、主机别名</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">User_Alias ADMPW = pro1, pro2, pro3, myuser1, myuser2 <span class="comment"># 创建了账号ADMPW</span></span><br><span class="line">Cmnd_Alias ADMPWCOM = !/usr/bin/passwd, /usr/bin/passwd [A-Za-z]*, \</span><br><span class="line">                      !/usr/bin/passwd root <span class="comment"># 创建命令集合 ADMPWCOM</span></span><br><span class="line">ADMPW   ALL=(root)  ADMPWCOM  <span class="comment"># 使用创建的账户和命令集合来配置</span></span><br></pre></td></tr></table></figure>
<p>这样配置之后，以后只需要改ADMPW和ADMPWCOM就可以了</p>
<p>让一般用户可以输入<code>sudo su -</code>，和自己的密码，就可以切换为root账户</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">User_Alias	ADMINS = pro1, pro2, pro3, myuser1</span><br><span class="line">ADMINS	ALL=(root)	/bin/su -</span><br></pre></td></tr></table></figure>
<p>不过注意，加入的使用者必须是能够信任的用户</p>
<p>将用户的shell设置为/sbin/nologin，就可以让他们无法登录系统取得shell</p>
<p>等用户尝试登录时，就会显示 /etc/nologin.txt 的内容</p>
<p>PAM模块</p>
<p>应用程序编程接口（Application Programming Interface，API）</p>
<p>PAM仅是一套验证机制，可以在程序中引用，来使用PAM的验证功能</p>
<p>PAM拥有不同的模块来做不同的验证。</p>
<p>pam_cracklib.so 用来验证passwd尝试修改的口令是否是弱口令</p>
<p>程序调用PAM后，PAM会到/etc/pam.d寻找和程序同名的验证模块</p>
<p><code>/etc/pam.d/passwd</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@VbirdLinux-2018-7 ~]# cat /etc/pam.d/passwd </span><br><span class="line">#%PAM-1.0</span><br><span class="line">auth       include	system-auth</span><br><span class="line">account    include	system-auth</span><br><span class="line">password   substack	system-auth</span><br><span class="line">-password   optional	pam_gnome_keyring.so use_authtok</span><br><span class="line">password   substack	postlogin</span><br></pre></td></tr></table></figure>
<p>第一行表示PAM版本，其余以#开头的均为注释</p>
<p>每行有三个字段：验证类别( type )、控制标准( flag )、PAM模块与模块的参数</p>
<p>第二个字段的 include 表示调用后面的文件来作为这个类别的验证</p>
<p>验证类别：</p>
<ul>
<li>auth： authentication（认证）的缩写，用来验证用户身份</li>
<li>account： authorization（授权）的缩写，用来检验用户权限</li>
<li>session：会话，主要管理环境配置</li>
<li>password：口令，修改、变更口令</li>
</ul>
<p>控制标准（flag）：</p>
<ul>
<li>required：通过此验证则带有success标志、失败则带有failure标志，通过与否都会继续进行下面的验证</li>
<li>requisite：验证失败则回报failure标志，并终止后续验证流程，验证成功则带着success标志继续下面的验证</li>
<li>sufficient：验证成功则立即回传success标志给源程序，并终止后续验证流程，验证失败则带着failure标志继续后续的验证</li>
<li>optional：用于显示信息</li>
</ul>
<p>PAM的模块信息：</p>
<ul>
<li>/etc/pam.d/* ：每个程序个别的PAM配置文件</li>
<li>/lib/security/*：PAM模块文件的实际放置目录</li>
<li>/etc/security/*：其他PAM环境的配置文件</li>
<li>/usr/share/doc/pam-*：详细的PAM说明文件</li>
</ul>
<p>常用模块：</p>
<ul>
<li>pam_securetty.so：确保root只能从安全的终端登录：/etc/securetty</li>
<li>pam_nologin.so：限制一般用户能否登录主机，当文件/etc/nologin存在时，所有的一般用户都无法登录系统了，正常情况下不应该存在这个文件</li>
<li>pam_selinux.so： SELinux，针对程序来进行细部的权限管理，因为会对用户程序运行产生影响，所以此PAM模块用来将SELinux暂时关闭，验证完成后再打开</li>
<li>pam_console.so： 帮助处理文件权限问题，让用户可以通过特殊的console登录系统</li>
<li>pam_loginuid.so ：验证用户UID是真实的（一般用户UID必须大于500）</li>
<li>pam_env.so : 用来配置环境变量，可以参考 /etc/security/pam_env.conf 这个文件的说明</li>
<li>pam_unix.so ：拥有很多功能：验证中的认证功能、授权中的许可证管理、会话中的登录文件记录。。。</li>
<li>pam_cracklib.so ：弱口令检测</li>
<li>pam_limits.so ：ulimit提供的能力，限制内存和CPU的使用额度</li>
</ul>
<p>login PAM验证过程：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">[root@VbirdLinux-2018-7 ~]<span class="comment"># cat /etc/pam.d/login </span></span><br><span class="line"><span class="comment">#%PAM-1.0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 验证阶段</span></span><br><span class="line"><span class="comment"># 通过pam_securetty.so判断，如果是root，则参考/etc/securetty的配置</span></span><br><span class="line">auth [user_unknown=ignore success=ok ignore=ignore default=bad] pam_securetty.so</span><br><span class="line"><span class="comment"># 调用 system-auth ，内容在下方↓</span></span><br><span class="line">auth       substack     system-auth</span><br><span class="line">auth       include      postlogin</span><br><span class="line"></span><br><span class="line"><span class="comment"># 授权阶段</span></span><br><span class="line">account    required     pam_nologin.so <span class="comment"># 判断/etc/nologin是否存在，存在则不允许一般用户登录</span></span><br><span class="line"><span class="comment"># 第二次调用 system-auth，将在下方的注释中使用 #2 来表示</span></span><br><span class="line">account    include      system-auth</span><br><span class="line"></span><br><span class="line"><span class="comment"># 口令阶段</span></span><br><span class="line"><span class="comment"># 第三次调用 system-auth，使用 #3 表示</span></span><br><span class="line">password   include      system-auth</span><br><span class="line"></span><br><span class="line"><span class="comment"># 会话阶段 调用system-auth以#4表示</span></span><br><span class="line"><span class="comment"># pam_selinux.so close should be the first session rule</span></span><br><span class="line"><span class="comment"># 以 pam_selinux.so 暂时关闭SELinux</span></span><br><span class="line">session    required     pam_selinux.so close</span><br><span class="line">session    required     pam_loginuid.so <span class="comment"># 规范不同的UID权限</span></span><br><span class="line">session    optional     pam_console.so</span><br><span class="line"><span class="comment"># pam_selinux.so open should only be followed by sessions to be executed in the user context</span></span><br><span class="line">session    required     pam_selinux.so open <span class="comment"># 开启SELinux</span></span><br><span class="line">session    required     pam_namespace.so</span><br><span class="line">session    optional     pam_keyinit.so force revoke</span><br><span class="line"><span class="comment"># 调用 system-auth</span></span><br><span class="line">session    include      system-auth</span><br><span class="line">session    include      postlogin</span><br><span class="line">-session   optional     pam_ck_connector.so</span><br><span class="line">[root@VbirdLinux-2018-7 ~]<span class="comment"># cat /etc/pam.d/system-auth</span></span><br><span class="line"><span class="comment">#%PAM-1.0</span></span><br><span class="line"><span class="comment"># This file is auto-generated.</span></span><br><span class="line"><span class="comment"># User changes will be destroyed the next time authconfig is run.</span></span><br><span class="line">auth        required      pam_env.so <span class="comment"># 配置额外的环境变量</span></span><br><span class="line">auth        required      pam_faildelay.so delay=2000000</span><br><span class="line">auth        sufficient    pam_fprintd.so</span><br><span class="line"><span class="comment"># pam_unix.so 检验口令，通过则回传成功</span></span><br><span class="line"><span class="comment">#2 用pam_unix.so来进行账户管理</span></span><br><span class="line">auth        sufficient    pam_unix.so nullok try_first_pass</span><br><span class="line"><span class="comment"># 未通过则调用下面的pam_succees_if.so判断UID是否大于500，小于500则回传失败</span></span><br><span class="line"><span class="comment">#2 判断UID小于500则不记录登录信息</span></span><br><span class="line">auth        requisite     pam_succeed_if.so uid &gt;= 1000 quiet_success </span><br><span class="line"><span class="comment"># 调用pam_deny.so拒绝联机</span></span><br><span class="line">auth        required      pam_deny.so</span><br><span class="line"></span><br><span class="line">account     required      pam_unix.so </span><br><span class="line">account     sufficient    pam_localuser.so</span><br><span class="line">account     sufficient    pam_succeed_if.so uid &lt; 1000 quiet</span><br><span class="line">account     required      pam_permit.so <span class="comment">#2 允许该用户登录</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#3 此处是我的CentOS 7系统，鸟哥的简体教程上这里使用的是pam_cracklib.so</span></span><br><span class="line"><span class="comment">#3 繁体教程上是和我的系统环境相同</span></span><br><span class="line"><span class="comment">#3 这个模块的作用是，设定密码仅能尝试错误三次</span></span><br><span class="line">password    requisite     pam_pwquality.so try_first_pass local_users_only retry=3 authtok_type=</span><br><span class="line"><span class="comment">#3 以 pam_unix.so 通过sha512 和 shadow等功能进行密码检验，通过则返回程序</span></span><br><span class="line">password    sufficient    pam_unix.so sha512 shadow nullok try_first_pass use_authtok</span><br><span class="line"><span class="comment">#3 若密码检验失败则拒绝登录</span></span><br><span class="line">password    required      pam_deny.so</span><br><span class="line"></span><br><span class="line">session     optional      pam_keyinit.so revoke</span><br><span class="line"><span class="comment">#4 用pam_limits.so 设置账户能够操作的系统资源</span></span><br><span class="line">session     required      pam_limits.so</span><br><span class="line">-session     optional      pam_systemd.so</span><br><span class="line">session     [success=1 default=ignore] pam_succeed_if.so service <span class="keyword">in</span> crond quiet use_uid</span><br><span class="line">session     required      pam_unix.so</span><br></pre></td></tr></table></figure>
<p>从上面的分析可以看到，验证的过程是：</p>
<ul>
<li>根据type，使用不同的模组来验证，根据不同的返回结果决定下一步的验证</li>
<li>出现include 则转到后面的文件中去进行验证流程</li>
<li>完成所有type的验证，结束</li>
</ul>
<p>因为远程连接会使用 /dev/pts# 的动态终端机名称，不在/etc/securetty中，所以不能在调用了login的 PAM模块的程序中登录</p>
<p>总结：</p>
<ul>
<li>/etc/securetty 影响root可登录的终端机</li>
<li>/etc/nologin 影响到一般使用者是否能够登录</li>
<li>PAM配置文件在 /etc/pam.d</li>
<li>说明文件在 /usr/share/doc/pam-(version)</li>
<li>模块在 /lib/security中</li>
</ul>
<p>PAM常用配置文件：</p>
<ul>
<li>limits.conf</li>
</ul>
<p>管理ulimit功能</p>
<p>文件结构</p>
<ul>
<li>因为没有对我的Linux上用户（今天前只有root和captainxu）限制CPU和内存，所以下面是鸟哥机器的配置文件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">vbird1	soft		fsize		 90000</span><br><span class="line">vbird1	hard		fsize		100000</span><br><span class="line">#账号   限制依据	限制项目 	限制值</span><br><span class="line"># 第一字段为账号，或者是群组！若为群组则前面需要加上 @ ，例如 @projecta</span><br><span class="line"># 第二字段为限制的依据，是严格(hard)，还是仅为警告(soft)；</span><br><span class="line"># 第三字段为相关限制，此例中限制文件容量，</span><br><span class="line"># 第四字段为限制的值，在此例中单位为 KB。</span><br><span class="line"># 若以 vbird1 登陆后，进行如下的操作则会有相关的限制出现！</span><br></pre></td></tr></table></figure>
<p>我的机器上其实也有示例，但未启用（带有#）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#*               soft    core            0</span><br><span class="line">#*               hard    rss             10000</span><br><span class="line">#@student        hard    nproc           20</span><br><span class="line">#@faculty        soft    nproc           20</span><br><span class="line">#@faculty        hard    nproc           50</span><br><span class="line">#ftp             hard    nproc           0</span><br><span class="line">#@student        -       maxlogins       4</span><br></pre></td></tr></table></figure>
<p>输入<code>ulimit -a</code>可以列出所有的限制</p>
<p>添加限制项目：maxlogins 可以限制一个群组的登录用户数（只对初始群组有效，一个用户不能同时登录多个终端）</p>
<p>发生无法登录或是未知的错误时，PAM会把数据记录在 /var/log/secure中</p>
<p><strong>用户之间的信息传递</strong></p>
<p><code>last</code>查看用户的登录时间</p>
<p><code>w</code>or<code>who</code>可以查看目前已登录的用户</p>
<p><code>lastlog</code>可以查看每个账户最近的登录时间。</p>
<p><code>lastlog | grep -v &quot;\*\*.*\*\*&quot;</code>忽略从未登录的系统用户</p>
<p>用户聊天。。</p>
<p><code>write username usertty</code>打开聊天会话，^D结束</p>
<p><img src="/images/Vbird/12-6.1.png" alt=""></p>
<p>输入<code>mesg n</code> 就可以关闭聊天功能，将不接受write</p>
<p>但是如果是root的write会话，将无法拒绝</p>
<p>再次输入<code>mesg y</code>就可以打开</p>
<p>使用<code>wall &quot;&quot;</code>可以对所有用户广播</p>
<p>write和wall命令必须是用户在线的情况下才能收到信息</p>
<p><code>mail username@localhost -s &quot;title&quot;</code>可以寄出邮件，即使用户不在线 也可以收到</p>
<p>本机的使用者可以不加@。。。</p>
<p>打出命令后，即可键入邮件内容，输入<code>.</code>表示内容结束</p>
<p>可以先用vim编辑好信件，再用<code>&lt;</code>符号传输</p>
<p><code>mail</code>命令可以查阅信件</p>
<p><strong>手动新增用户</strong>（不使用系统默认设置）</p>
<p>检查工具</p>
<p><code>pwck</code>用来检查/etc/passwd，对比和/etc/shadow是否一致，如果passwd文件中的字段错误，就会提示用户修订</p>
<ul>
<li>用此命令会产生一些“正确的错误”，如：会提示系统用户的<code>~</code>目录不存在</li>
</ul>
<p>群组检查可以使用<code>grpck</code></p>
<p><code>pwconv</code>对比/etc/passwd 和 /etc/shadow</p>
<ul>
<li>若passwd存在的账号没有对应的/etc/shadow口令，pwconv会去/etc/login.defs取用口令数据，创建账号的shadow数据</li>
<li>若passwd存在加密的口令，则会被移动到shadow中，并将原来的passwd口令变成x</li>
</ul>
<p><code>pwunconv</code>会将shadow中的数据写会passwd，并删除shadow，最好不要使用</p>
<p><code>chpasswd</code>可以用来修改口令，可以从stdin读入数据<code>echo &quot;captainxu:123456&quot; | chpasswd -m</code>就可以以MD5加密，并修改好口令</p>
<p>不建议使用纯数字账号，因为会与UID误解</p>
<p>手动创建账号的步骤：</p>
<ol>
<li>先创建所需群组（vim /etc/group）</li>
<li>/etc/group与/etc/gshadow同步（grpconv）</li>
<li>创建账号的各个属性( vim /etc/passwd)</li>
<li>将 passwd与shadow同步（pwconv）</li>
<li>创建该账号的口令（passwd username）</li>
<li>创建<code>~</code>目录（cp -a /etc/skel /home/username）</li>
<li>更改<code>~</code>目录的属性（chown -R username.group /home/username）</li>
</ol>
<p>使用脚本大量建立用户：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/<span class="built_in">local</span>/bin:/usr/<span class="built_in">local</span>/sbin:~/bin</span><br><span class="line"><span class="built_in">export</span> PATH</span><br><span class="line"><span class="keyword">if</span> [ ! -f accounts.txt ]; <span class="keyword">then</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="string">"账号文件不存在，请在本目录创建账号文件，文件名为accounts.txt"</span></span><br><span class="line">	<span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">usernames=$(cat accounts.txt)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> username <span class="keyword">in</span> <span class="variable">$usernames</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">	useradd <span class="variable">$username</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="variable">$username</span> | passwd --stdin <span class="variable">$username</span></span><br><span class="line">	chage -d 0 <span class="variable">$username</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="2018-7-24"><a href="#2018-7-24" class="headerlink" title="2018-7-24"></a>2018-7-24</h3><p>继续学习shell scripts</p>
<p>条件判断</p>
<p>if [ 条件 ]; then</p>
<p>elif [ 条件2 ]; then</p>
<p>else</p>
<p>fi</p>
<p>此处的条件判断式中</p>
<p><code>[ &quot;$HOME&quot; == &quot;MAIL&quot; -o &quot;fname&quot; == &quot;2&quot; ]</code>可以写成<code>[ &quot;HOME&quot; == &quot;MAIL&quot; ] || [ &quot;fname&quot; == &quot;2&quot; ]</code></p>
<p><code>netstat</code>命令，可以查询到目前主机开启的网络服务端口</p>
<p><code>netstat -tuln</code>查询目前主机启动的服务</p>
<p>格式为：<code>封包格式    本地IP:端口    远程IP：端口    是否监听</code></p>
<p>常见端口和网络服务：</p>
<p>80：www</p>
<p>22：ssh</p>
<p>21：ftp</p>
<p>25：mail</p>
<p>111：RPC（远程程序呼叫）</p>
<p>631：CUPS（列印服务功能）</p>
<p>整数声明必须用：<code>declare -i</code></p>
<p>复习</p>
<p>`` = $() 执行命令</p>
<p>$((1+1))表示执行计算</p>
<p><code>case ... esac</code>判断，同时判断多个变量</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="variable">$var</span> <span class="keyword">in</span></span><br><span class="line">  <span class="string">"a"</span>) <span class="comment"># 变量值为a时执行下面的指令</span></span><br><span class="line">	指令</span><br><span class="line">	;;</span><br><span class="line">  <span class="string">"b"</span>) <span class="comment"># 变量值为b时执行下面的指令</span></span><br><span class="line">  	指令</span><br><span class="line">  	;;</span><br><span class="line">  *)   <span class="comment"># 代表变量为剩下的所以值时执行下面的指令</span></span><br><span class="line">  	指令</span><br><span class="line">  	<span class="built_in">exit</span> 1</span><br><span class="line">  	;;</span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure>
<p>重启<code>syslog</code>服务</p>
<p><code>/etc/init.d/syslog restart</code></p>
<p>bash函数</p>
<p><code>function fname(){ 指令 }</code></p>
<p>因为shell的执行顺序，函数必须放在最开头定义才能被使用</p>
<p><code>echo -n &quot;&quot;</code>可以让之后的输出不换行</p>
<p>函数也拥有内建变量：</p>
<ul>
<li>\$0表示函数名称</li>
<li>\$1 \$2 \$3 …. 表示函数的参数，和可执行文件的参数无关</li>
</ul>
<p><strong>循环</strong></p>
<p><code>while</code>循环，满足条件时循环</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> [ 循环条件 ]</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">	commands</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<p><code>until</code>循环，满足条件时停止</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">until [ 循环条件 ]</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">	commands</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<p><code>for</code>循环，已知循环次数</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> var <span class="keyword">in</span> con1 con2 con3</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">	commands</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> var <span class="keyword">in</span> $(seq 1 100)</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">	commands</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<p><code>seq 1 100</code>表示列出1到100</p>
<p>for循环的数值处理</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ((origin;restriction;step))</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">	commands</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<p>eg:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ((i=1;i&lt;=100;i=i+1)) <span class="comment"># 可以使用i++</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">	<span class="built_in">echo</span> i</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<p><strong>Debug！</strong></p>
<p>使用bash的相关参数来Debug</p>
<p><code>sh [-nvx] script.sh</code></p>
<p>-n 不运行脚本，仅检查语法问题</p>
<p>-v  运行脚本前，先输出脚本的内容</p>
<p>-x   将使用到的 脚本内容显示到屏幕上（脚本运行的全过程）</p>
<p><code>date --date=YYYYMMDD +%s</code>可以把当前时间转化成秒，但是一定要加年份</p>
<h4 id="第十三章-Linux账号管理与ACL权限设置"><a href="#第十三章-Linux账号管理与ACL权限设置" class="headerlink" title="第十三章 Linux账号管理与ACL权限设置"></a>第十三章 Linux账号管理与ACL权限设置</h4><p>每个用户都至少有两个ID：UID（User ID）GID（Group ID），都是数字组成的</p>
<p>系统获取UID和GID后，在 <code>/etc/passwd</code> 和 <code>/etc/group</code> 中找到对应的用户名和组名，再进行显示</p>
<p>登录时，还会查询密码存储的文件<code>/etc/shadow</code></p>
<p><code>/etc/passwd</code>文件结构，权限：644</p>
<p><code>账户名：密码（一般在/etc/shadow文件中，这里显示x）：UID：GID：用户信息说明：home目录：shell</code></p>
<p>UID:</p>
<p>0：管理员，如果需要添加管理员，只要把UID改为0即可</p>
<p>1~499：系统保留ID</p>
<p>500~65535：一般使用者账号，2.6.x版以上的Linux核心已经支持到4294967295</p>
<p>GID：初始群组的ID，登录系统时就有的群组权限，不需要在<code>/etc/group</code>的第四栏添加</p>
<ul>
<li><code>usermod -G users captainxu</code>管理员可以把captainxu加入users群组中</li>
</ul>
<p><code>/etc/shadow</code>文件结构，权限：000</p>
<p><code>账户名：加密密码：最近密码修改日期：密码不可更改的天数：密码需要变更的天数：密码需要变更前警告天数：密码过期后账号宽限时间（登录时必须更改密码）：账号失效日期（过期后账号不能再被使用）：保留字段</code></p>
<p>修改日期：到1970年1月1日的天数</p>
<p>使用<code>date --date=&quot;YYYYMMDD&quot; +%s</code>所显示的秒数也是从1970年1月1日以来的总秒数</p>
<p> <img src="/images/Vbird/12-1.1.png" alt=""></p>
<p>忘记密码找回：</p>
<ul>
<li>一般用户：使用root用户<code>passwd</code>即可</li>
<li>root用户：<ul>
<li>重启进入单人维护模式，以<code>passwd</code>更改密码</li>
<li>以Live CD启动后挂载根目录，修改/etc/shadow，清空root的密码，重启后root不需要密码也可以登录，但是记得即使设置密码</li>
</ul>
</li>
</ul>
<p><code>/etc/group</code>目录结构</p>
<p><code>组名：群组口令：GID：群组支持的账号名称（用,分隔，中间不要加空格）</code></p>
<p><code>groups</code>命令，用户可以输入此命令查看自己所在的群组，第一个输出的是有效群组</p>
<p>有效群组：创建文件时显示的群组</p>
<p><code>newgrp [群组名]</code>切换有效群组</p>
<p><code>/etc/gshadow</code>的目录结构</p>
<p><code>组名：口令栏（为！表示无群组管理员）：群组管理员账号：群组所属账号（与/etc/passwd文件相同）</code></p>
<ul>
<li>此目录的作用在于创建群组管理员</li>
</ul>
<p>看到 2.账号管理</p>
<hr>
<h3 id="2018-7-23"><a href="#2018-7-23" class="headerlink" title="2018-7-23"></a>2018-7-23</h3><blockquote>
<p>雪，</p>
<p>飘落在</p>
<p>世界上——</p>
</blockquote>
<p>^the 代表以the开头</p>
<p>\.$    代表以.结尾</p>
<p>搜索空白行：<code>&#39;^$&#39;</code>只有行首行尾，就代表空白行啦</p>
<p>.        代表绝对有任意一个字符</p>
<p>*        代表重复前一个字节任意次（从0次开始）</p>
<p>.*        就可以代表有任意个任意字符</p>
<p>在shell中，因为{}有特殊用法，所以在正则表达式中要转义使用</p>
<p>o\{2\}表示有2个o</p>
<p>o\{2,5\}表示有2-5个o</p>
<p>o\{2,\}表示有2个以上的o</p>
<p><code>sed</code>工具</p>
<ul>
<li>管线命令</li>
</ul>
<p><code>sed [-nefr] [action]</code></p>
<p>-n 使用安静模式</p>
<p>-e   直接在命令行模式进行sed动作编辑（有多个命令时需要用-e分开）</p>
<p>-f    将动作写入文件 -f filename可以运行filename里面的sed动作</p>
<p>-r    使sed动作支持延伸型正则表达式（默认支持基础）</p>
<p>-i     直接修改读取的文件内容</p>
<ul>
<li>动作</li>
<li>n1,n2function</li>
<li>n1,n2选择进行动作的行数（非必要），[10,20[动作]]<ul>
<li>$代表最后一行</li>
</ul>
</li>
<li>a 新增 +str，新增字串在下一行出现</li>
<li>c 取代 +str，可以取代n1到n2之间的行</li>
<li>d 删除</li>
<li>i  插入 +str，新增字串会在上一行出现</li>
<li>p 列印，将某个选择的数据印出，通常和安静模式-n一起使用</li>
<li>s 取代，可以搭配正则表达式</li>
</ul>
<p>使用 a，i动作也可以新增多行，就是在每一行的末尾用 \ 来换行输入，最后要带单引号 ’ 结尾</p>
<p> <code>sed &#39;s/str to be replaced/new str/g&#39;</code>使用sed取代</p>
<p>延伸的正则表达式 grep -E or egrep</p>
<p>| 在正则表达式中表示or</p>
<p>+ 重复一次及一次以上前一个字符</p>
<p>？重复0次或一次前一个字符</p>
<p>() 多个字符判断eg: ‘g(la|oo)d’ = glad | good</p>
<p>()+  表示有一个以上的()内的字符串</p>
<p>格式化输出：</p>
<p><code>printf &#39;格式&#39; content</code>不是管线命令</p>
<p>\a 警告声音输出</p>
<p>\b  backspace</p>
<p>\f  清屏（form feed）</p>
<p>\n 换行</p>
<p>\r  回车</p>
<p>\t  Tab</p>
<p>\v  垂直Tab</p>
<p>\x[0-9][0-9]  转换数字为字节（从今以后数字字母等将全部用正则表达式表示）</p>
<p>%[0-9]*s  表示多少个字节长度（数字+s）</p>
<p>%[0-9]*i    表示多少个数字</p>
<p>%[0-9]*\.[0-9]*f   表示浮点数，前一个数字表示共有多少位，后一个数字表示有多少位小数（小数点也占一个整数位）</p>
<p><code>printf &#39;%s\t %s\t %s\t %s\t %s\t \n&#39; $(cat printf.txt)</code></p>
<p><code>printf &#39;%10s %5i %5i %5i %8.2f \n &#39; $(cat printf.txt | grep -v Name)</code></p>
<p>printf 也可以吧ASCII码输出为对应字符</p>
<p><code>awk &#39;条件1{动作1} 条件2{动作2}&#39; filename</code></p>
<p><code>last -n 5 | awk &#39;{print $1 &quot;\t&quot; $3}&#39;</code></p>
<ul>
<li>使用了print动作</li>
<li>内容是由默认的空格或Tab分栏，每一栏都有对应的变量，\$1 \$2 \$3 \$4…</li>
<li>\$0代表一整列</li>
<li>内建变量（不需要\$符号，使用大写直接引用）<ul>
<li>NF 每行分出的栏数</li>
<li>NR 目前awk打印的是第几行</li>
<li>FS  目前的分栏字符，默认是空格</li>
</ul>
</li>
</ul>
<p>上面awk处理流程为：</p>
<ol>
<li>读入第一行，分栏，赋予变量\$0 \$1…</li>
<li>根据条件1、条件2……判断是否需要进行后面的动作1、动作2……</li>
<li>做完所有动作和条件</li>
<li>读取下一行，重复步骤1-3</li>
</ol>
<p><code>cat /etc/passwd | awk &#39;BEGIN {FS=&quot;:&quot;} $3 &lt; 10 {print $1 &quot;\t&quot; $3}&#39;</code></p>
<ul>
<li>BEGIN表示预先配置FS变量（分隔符），以保证在读取第一行时就以”：“作为分隔符</li>
</ul>
<p><code>cat pay.txt |awk &#39;NR==1{printf &quot;%10s %10s %10s %10s %10s\n&quot;,$1,$2,$3,$4,&quot;Total&quot; }NR&gt;=2{total = $2 + $3 + $4; printf &quot;%10s %10d %10d %10d %10.2f\n&quot;, $1, $2, $3, $4, total}&#39;</code></p>
<p>动作中有多个命令时要使用 ; 分隔或按回车分隔</p>
<p><code>diff [-bBi] from-file to-file</code>文件对比（按行比较）（文件都可以用 - 取代，表示stdin）</p>
<p>from-file 原始比对文件名</p>
<p>to-file      目的比对文件名</p>
<p>-b 忽略多个空格差异</p>
<p>-B 忽略空行</p>
<p>-i   忽略大小写</p>
<p>output：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@www test]# diff passwd.old passwd.new</span><br><span class="line">4d3    &lt;==左边第四行被删除 (d) 掉了，基准是右边的第三行</span><br><span class="line">&lt; adm:x:3:4:adm:/var/adm:/sbin/nologin  &lt;==这边列出左边(&lt;)文件被删除的那一行内容</span><br><span class="line">6c5    &lt;==左边文件的第六行被取代 (c) 成右边文件的第五行</span><br><span class="line">&lt; sync:x:5:0:sync:/sbin:/bin/sync  &lt;==左边(&lt;)文件第六行内容</span><br><span class="line">---</span><br><span class="line">&gt; no six line                      &lt;==右边(&gt;)文件第五行内容</span><br></pre></td></tr></table></figure>
<p>diff也可以比较两个不同目录的区别</p>
<p><code>cmp [-s] file1 file2</code>按位组比较，可用于二进制文件</p>
<p>-s  列出所有的不同位组（默认只输出第一个）</p>
<p><code>patch -pN &lt; patch_file</code>升级旧文件</p>
<p><code>patch -R -pN &lt; patch_file</code>还原文件</p>
<p><code>diff -Naur passwd.old passwd.new &gt; passwd.patch</code>使用diff制作的比较文件通常用patch作为后缀</p>
<p>使用patchfile升级旧文件：<code>patch -p0 &lt; passwd.patch</code></p>
<p>文件打印（print）准备：<code>pr</code></p>
<p><code>pr /etc/man_db.config</code>可以自动产生文件时间、文件名、页码</p>
<p>更多使用请man</p>
<p>获得IP</p>
<p><code>ifconfig ens33 | grep -v &#39;inet6&#39; | grep &#39;inet&#39; | sed &#39;s/^.*inet//g&#39;| cut -d &#39; &#39; -f2</code></p>
<h4 id="第十二章-学习Shell-Scripts"><a href="#第十二章-学习Shell-Scripts" class="headerlink" title="第十二章 学习Shell Scripts"></a>第十二章 学习Shell Scripts</h4><p>服务启动界面在 /etc/init.d目录下</p>
<p>管理主机每日任务：</p>
<p>查询登录文件、追踪流量、监控使用者主机状态、主机各项硬件设备状态、主机软件升级查询</p>
<p>shell scripts注意事项：</p>
<ol>
<li>命令从上而下，从左而右地运行</li>
<li>命令、选项、参数间的多个空白会被忽略</li>
<li>空行被忽略，Tab也被视为空格键</li>
<li>读到Enter符号：CR，就会尝试开始运行该行命令</li>
<li>可以使用 \ 将命令延伸至下一行</li>
<li>使用<code>#</code>来加注释</li>
</ol>
<p>如何运行脚本：需要有至少rx权限</p>
<ul>
<li>使用绝对路径eg: /home/shell.sh</li>
<li>相对路径eg: ./shell.sh</li>
<li>把目录加入PATH</li>
<li>使用bash来运行<code>bash shell.sh</code> <code>sh shell.sh</code></li>
</ul>
<p>开始写script：</p>
<p>第一行：<code>#!/bin/bash</code>宣告脚本使用的shell为bash，加载bash的环境配置</p>
<p>除了<code>#!</code>以外的以#开头的行都是注释</p>
<ul>
<li>注释使用，注释应包含此脚本的以下信息<ul>
<li>内容与功能</li>
<li>版本号</li>
<li>作者和联系方式</li>
<li>创建日期</li>
<li>历史记录</li>
<li>特殊的命令，使用绝对路径的方式下达</li>
<li>运行时需要的环境变量</li>
</ul>
</li>
</ul>
<p>环境变量宣告：</p>
<ul>
<li>主要声明 PATH 和 LANG 的值，可以直接下达外部指令</li>
</ul>
<p>主要程序部分</p>
<p>运行结果：回传值定义</p>
<ul>
<li>使用exit使程序中断（类似return？）</li>
</ul>
<p>\$((计算式))可以进行数值运算</p>
<p>可用的运算符号：</p>
<ul>
<li>+ - * / %（取余）</li>
</ul>
<p>脚本运行方式造成不同结果：</p>
<ul>
<li>使用bash或sh运行脚本时，是采用子程序bash来运行，因此在脚本中使用的变量不能在父程序中使用</li>
<li>使用<code>source</code>运行脚本，脚本将在父程序中运行，其中的配置都会在父程序中生效</li>
</ul>
<p><code>test</code>测试命令（与|| &amp;&amp; 符号搭配输出信息）</p>
<ol>
<li>类型判断：</li>
</ol>
<p>-e  测试是否存在，存在返回0</p>
<p>-f   测试是否存在且为文件</p>
<p>-d  测试是否存在且为目录</p>
<p>-b  测试是否存在且为block device</p>
<p>-c   …………………………character device</p>
<p>-S   …………………………socket 文件</p>
<p>-p   …………………………FIFO（pipe）文件</p>
<p>-L    …………………………link文件</p>
<ol start="2">
<li>权限判断：</li>
</ol>
<p>-r -w -x：测试是否存在，且具有可读、可写、可运行权限</p>
<p>-u -g -k ：…………………………SUID、SGID、SBIT属性</p>
<p>-s    ：………………………………是否为空白文件</p>
<ol start="3">
<li>文件比较：</li>
</ol>
<p>-nt：<code>test file1 -nt file2</code>1比2新？</p>
<p>-ot:  1比2旧？</p>
<ol start="4">
<li>整数判断：</li>
</ol>
<p>-eq <code>test n1 -eq n2</code>n1=n2？</p>
<p>-ne  n1!=n2?</p>
<p>-gt  n1&gt;n2?</p>
<p>-lt   n1&lt;n2?</p>
<p>-ge  n1&gt;=n2?</p>
<p>-le    n1&lt;=n2?</p>
<ol start="5">
<li>测试字符串：</li>
</ol>
<p><code>test -z str</code>str为空则为true</p>
<p><code>test -n str</code>str为空则为false（可省）</p>
<p><code>test str1=str2</code></p>
<p><code>test str1!=str2</code></p>
<ol start="6">
<li>逻辑判断：</li>
</ol>
<p><code>test -r file -a -x file</code>and</p>
<p><code>test -r file -o -x file</code>or</p>
<p><code>test ! -x file</code>not</p>
<p>判断符号<code>[]</code>，可以使用<code>test</code>的参数</p>
<p>注意使用格式，中括号的两端都需要空格来隔开</p>
<p><code>[ -z &quot;$HOME&quot; ]</code></p>
<p><code>[ &quot;$HOME&quot; == &quot;MAIL&quot; ]</code></p>
<p>常用在条件判断式中<code>if ...; then ... fi</code></p>
<p>可以使用 -a -o ! 表示and or not</p>
<p>shell script 默认变量</p>
<p>脚本名称 \$0</p>
<p>参数1  \$1</p>
<p>参数2  \$2</p>
<p>….</p>
<p>特殊：</p>
<p>$#：代表脚本后接的参数的个数</p>
<p>$@：代表[“\$1””\$2””\$3”…]</p>
<p>$*：代表[“\$1 \$2 \$3 …”]，空格可以是其他的分隔字符，空格为默认</p>
<p><code>shift</code>参数号码偏移</p>
<p><code>shift</code>使所有参数向左移一位，第一个参数被取消</p>
<p><code>shift 4</code>使。。。。。。4位，前4个参数被取消</p>
<p>看到 12.4 条件判断式</p>
<hr>
<h3 id="2018-7-21"><a href="#2018-7-21" class="headerlink" title="2018-7-21"></a>2018-7-21</h3><blockquote>
<p>Seize the day.</p>
<p>Carpe Diem.</p>
</blockquote>
<h4 id="第十一章-正则表达式和文件格式化处理"><a href="#第十一章-正则表达式和文件格式化处理" class="headerlink" title="第十一章 正则表达式和文件格式化处理"></a>第十一章 正则表达式和文件格式化处理</h4><p>不同的编码顺序抓取的结果不同！</p>
<p><code>LANG=C</code>的编码顺序是0-9…A-Z…a-z</p>
<p><code>LANG=zh_TW.big5</code>的编码顺序是0-9…aAbBcC…zZ</p>
<p>使用[a-z]得到的结果就会不同</p>
<p>特殊符号：使用这些符号可以免除不同语系编码导致的问题</p>
<p><code>[:alnum:]</code>英文大小写和数字</p>
<p><code>[:alpha:]</code>英文大小写</p>
<p><code>[:blank:]</code>空白字符：空格键和Tab键</p>
<p><code>[:cntrl:]</code>控制按键</p>
<p><code>[:digit:]</code>数字</p>
<p><code>[:graph:]</code>除了空白字符以外的所以按键</p>
<p><code>[:lower:]</code>小写字符</p>
<p><code>[:upper:]</code>大写字符</p>
<p><code>[:print:]</code>所以可以被打印的字符</p>
<p><code>[:punct:]</code>标点符号</p>
<p><code>[:space:]</code>所以可以产生空白的字符：空白字符，CR等</p>
<p><code>[:xdigit:]</code>16进制的数字：0-9，a-f,A-F</p>
<p><code>grep</code>进阶选项</p>
<p><code>grep [-A][-B][--color=auto] &#39;strtofind&#39; filename</code></p>
<p>-A # 列出搜寻行和它后续（after）的#行</p>
<p>-B # 列出搜寻行和它之前（before）的#行</p>
<p>-n     标出行号</p>
<p>-v      反向选择（没有某个字符串）</p>
<p>-i       忽略大小写</p>
<ul>
<li>CentOS 7默认，alias grep=grep –color=auto</li>
</ul>
<hr>
<h3 id="2018-7-20"><a href="#2018-7-20" class="headerlink" title="2018-7-20"></a>2018-7-20</h3><blockquote>
<p>Man is born free and everywhere he is in chains.</p>
</blockquote>
<p>Bash Shell</p>
<ol>
<li>命令记录位置~/.bash_history，记录上一次登录使用的命令</li>
<li>命令别名设置<code>alias lm=&#39;ls -al&#39;</code></li>
<li>可以后台执行命令</li>
<li>程序化脚本，Shell script</li>
<li>支持万能字符<code>*</code></li>
</ol>
<p>指令是否为Bash shell(内置指令还是后期添加的指令)：<code>type</code></p>
<p><code>type [-tpa] cmdname</code></p>
<p>参数</p>
<p>-t  显示file表示是外部指令，显示alias表示是别名，显示builtin表示是bash内置指令</p>
<p>-p 显示外部指令的完整文件名</p>
<p>-a 在PATH的路径中，显示含有后面指令的目录</p>
<p>快速删除、移动光标</p>
<p><code>^u  ^k</code>从光标向前删除指令，向后删除指令</p>
<p><code>^a  ^e</code>移动光标到指令最前，最后</p>
<p> 变量通常以大写来区分</p>
<p>显示变量<code>echo</code></p>
<p><code>echo $variable</code></p>
<p><code>echo ${PATH}</code></p>
<p>变量赋值：<code>变量=值</code>等号两边不能加空白字符</p>
<p>变量名称规则：</p>
<ul>
<li>只能是英文和数字，只能英文开头</li>
<li>若有空白字符，可以把变量用双引号或单引号引用起来<ul>
<li>双引号内的特殊字符（如引用变量$PATH）会保留为特殊字符的特性</li>
<li>单引号内的特殊字符会转化为字符串</li>
</ul>
</li>
<li>空白字符还可以用反斜线转义</li>
<li>在指令中还可以用  `指令   或   <code>$(指令)</code>的方式调用别的指令</li>
<li>可以使用<code>var=${var}content</code> 增加变量内容，如<code>PATH=${PATH}:/somepath</code></li>
<li>大写字符通常是系统默认变量，自定变量可以用小写设置</li>
<li>取消变量<code>unset varname</code>(注意！此处不加$符号)</li>
<li><code>export var</code>可以把变量设置成环境变量，在子程序下也可以使用，比如bash下再开一个bash</li>
</ul>
<p>可以在文件<code>~/.bashrc</code>中设置环境变量，每次开机后就可以直接使用</p>
<p><code>env</code>可以观察所有的环境变量</p>
<p><code>export</code>也可以观察所有的环境变量</p>
<p>常见环境变量</p>
<ul>
<li>HOME：代表使用者的主文件夹</li>
<li>SHELL：代表目前环境是那个shell</li>
<li>HISTSIZE：代表系统可以记录的指令历史数量</li>
<li>MAIL：使用mail指令收信时，读取的信箱文件</li>
<li>PATH：指令搜寻路径</li>
<li>LANG：语系数据</li>
<li>RANDOM：随机数，每次调用的值都不同，介于0-32767之间</li>
</ul>
<p><code>delcare -i number=${RANDOM}*10/32768</code>声明了number变量，是一个在0-9之间的随机数（-i参数表示在后面的声明中算术式子将会被执行）</p>
<p>用set观察所以环境变量</p>
<p>重要变量</p>
<p><code>PS1</code>命令提示符</p>
<ul>
<li>\d 可以显示 星期 月 日 的时间格式</li>
<li>\H 完整主机名称</li>
<li>\h 主机名称第一个小数点前的名字</li>
<li>\t 显示24小时格式时间“HH:MM:SS”</li>
<li>\T 显示12小时格式时间“HH:MM:SS”</li>
<li>\A 显示24小时格式时间”HH:MM”</li>
<li>\@ 显示12小时时间”am/pm”</li>
<li>\u  目前使用者的名称</li>
<li>\v  BASH的版本信息</li>
<li>\w  完整的工作目录名称</li>
<li>\W  只显示最后一个目录的工作目录</li>
<li>\ #  下达的第几个指令</li>
<li>\ $   提示符，root为#，一般用户为 \$</li>
</ul>
<p><code>$</code>本shell的PID</p>
<p>代表目前这个shell的线程代号</p>
<p><code>?</code>上一个指令的回传值</p>
<p>return 0代表正常，错误将显示错误代码</p>
<p><code>OSTYPE HOSTTYPE MACHTYPE</code>主机硬件与核心的等级</p>
<p>子程序只继承父程序的环境变量</p>
<p><code>locale -a</code>查询Linux到底支持多少语系</p>
<p>可以逐一设置语系有关的变量，但是如果其他语系变量都未设置，且LANG或LC_ALL被设置，那么其他语系变量都会被替代</p>
<p>在tty1-tty6的终端机中是无法显示中文的，所以会显示乱码</p>
<p>系统默认语系定义文件在：/etc/locale.conf</p>
<p><code>read</code>命令，可以等待用户从键盘键入变量</p>
<p><code>read [-pt] var</code></p>
<ul>
<li>-p 连接提示字符</li>
<li>-t  等待的秒数</li>
</ul>
<p><code>delare/typeset</code>声明变量的类型</p>
<p><code>declare [-aixr] var</code>（将选项的-变成+就可以取消选项）</p>
<ul>
<li>-a 定义数组</li>
<li>-i   定义整型数</li>
<li>-x  将后面的变量声明为全局变量</li>
<li>-r   将变量设置为静态变量，Read Only</li>
</ul>
<p>bash默认类型为字符串</p>
<p>bash不存在浮点数</p>
<p><code>var[index]=content</code>数组声明</p>
<p><code>ulimit [-SHacdfltu] [配额]</code>设置内存和CPU的使用限制</p>
<p>-H 严格设置，不能超过这个</p>
<p>-S  警告设置，超过后会发出警告</p>
<p>-a  可列出所以限制额度</p>
<p>-c   当某些程序出错时，系统会将该程序在内存中的信息写成文件</p>
<p>-f    此shell可以创建的最大文件大小</p>
<p>-d   程序可使用的最大断裂内存容量（segment）</p>
<p>-l     可用于锁定内存量</p>
<p>删除变量内容</p>
<p><code>${PATH#/*dir/bin:}</code></p>
<p>var表示要删除的变量</p>
<p># 表示从变量的最前面开始向后删除，还是符合取代文字最短的那一个</p>
<p>## 还是符合取代文字最长的那一个 </p>
<p>${var%:/*dir}</p>
<p>% 表示从变量的最后面开始向前删除，还是符合取代文字最短的那一个</p>
<p>%% 还是符合取代文字最长的那一个 </p>
<p>/<em>dir/bin 就是要删除的内容，\</em>表示任意字符</p>
<p>只保留文件名<code>${MAIL##/*/}</code></p>
<p>去掉文件名 <code>${MAIL%/*}</code></p>
<p>取代</p>
<p><code>${var/old/new}</code>会取代从左往右的第一个old</p>
<p><code>${var//old/new}</code>取代所有old</p>
<p>替换</p>
<p><code>var=${var1-content}</code>如果var1存在，则var=$var1,如果var1不存在，则var=content</p>
<p><img src="/images/Vbird/10-2.1.png" alt=""></p>
<p><code>var=${var1:-content}</code>如果var1不存在或者为空字符串，则var=content</p>
<p><img src="/images/Vbird/10-2.2.png" alt=""></p>
<p>命令别名设置</p>
<p><code>alias lm=&#39;ls -al|more&#39;</code></p>
<p>查询历史命令</p>
<p><code>history</code></p>
<p># 列出最近的#行命令</p>
<p>-c 清除shell中所有的history</p>
<p>-a [filename] 将从今往后的命令写入filename命名的文件中（默认<code>~/.bash_history</code>）</p>
<p>-r [filename]将文件的内容读到目前shell的history中</p>
<p>-w [filename]将目前的history写入文件中</p>
<p><code>![command]</code>搜寻最近的一个以[command]开头的指令</p>
<p><code>![number]</code>执行history中第number个指令</p>
<p>系统欢迎信息 /etc/issue   /etc/motd /etc/issue.net(远程登录提示)</p>
<p><code>man issue</code> <code>man agetty</code></p>
<p>\d 本地时间的日期</p>
<p>\l   显示第几个终端机接口</p>
<p>\m 显示硬件的等级</p>
<p>\n  显示主机的网络名称</p>
<p>\O  显示domain name</p>
<p>\r    显示操作系统版本</p>
<p>\t    显示本地时间</p>
<p>\S    显示操作系统名称</p>
<p>\v    显示操作系统版本</p>
<p>/etc/motd 中的信息会在用户登录后显示</p>
<p>login shell：需要完整登录流程来取得bash</p>
<p>non-login shell：不需要登录过程，比如x Window中开启终端</p>
<p>login shell读取的文件：</p>
<ol>
<li>/etc/profile</li>
<li>~/.bash_profile 或 ~/.bash_login 或 ~/.profile</li>
</ol>
<p>~/.bash_profile</p>
<ul>
<li>读取./bashrc这个文件</li>
<li>将/home/bin加入PATH</li>
<li>将PATH声明为全局变量</li>
</ul>
<p>login shell 读取过程：</p>
<ul>
<li>读取/etc/profile<ul>
<li>/etc/profile.d/*.sh<ul>
<li>/etc/locale.conf</li>
</ul>
</li>
</ul>
</li>
<li>读取~/.bash_profile<ul>
<li>~/.bashrc<ul>
<li>/etc/bashrc</li>
</ul>
</li>
</ul>
</li>
<li>开始操作bash</li>
</ul>
<p><code>source</code>读入环境配置文件的指令</p>
<p>因为login shell在登录时才会读取/etc/profile 和 ~/.bash_profile ，所以把偏好设置写入后，都要重新登录才能生效。</p>
<p>source指令可以直接读取配置文件而不用重新登录</p>
<p>用法<code>source [configfile]</code></p>
<p>non-login shell 会读取~/.bashrc</p>
<p>~/.bash_logout记录了登出bash时做的事</p>
<p><code>stty -a</code>可以列出终端机输入按键代表的意义</p>
<p>intr：给程序发送中断信号（以下有信号字样的列，省略 ‘给程序发送*’）</p>
<p>quit：quit信号</p>
<p>erase：向后删除字符</p>
<p>kill：删除目前命令行的文字</p>
<p>eof：结束输入</p>
<p>start：程序停止后，重新开始屏幕输出</p>
<p>stop：停止目前屏幕的输出</p>
<p>susp：stop信号</p>
<p>backspace = ^?</p>
<p><code>set</code>设置指令环境</p>
<p>-u  启用后使用未声明变量会报错</p>
<p>-v   启用后在信息被输出前会显示信息的原始内容</p>
<p>-x   启用后指令在被执行前，会先显示指令内容，指令前有+</p>
<p>-h -H   历史命令相关</p>
<p>-m  工作管理相关</p>
<p>-B   括号相关</p>
<p>-C    启用后，文件存在时，不会被覆盖</p>
<p>显示目前set的设置值<code>echo $-</code></p>
<p>可以使用+参数来取消设置<code>set +u</code></p>
<p>Bash万用字符</p>
<p>* 代表任意个任意字符</p>
<p>？代表有一个（不能没用）任意字符</p>
<p>[aswd] 代表有一个[]内的字符（不能没有）</p>
<p>[0-9] 代表有一个（不能没用）在编码顺序内的字符</p>
<p>[^asd] 代表一定没有^后的字符</p>
<p># 注释符号</p>
<p>\   转义字符</p>
<p>|   管线</p>
<p>；持续指令分隔</p>
<p>~  用户主文件夹</p>
<p>$  变量的前置字符</p>
<p>&amp;  工作控制，使指令在后台工作</p>
<p>！非</p>
<p>/  目录</p>
<p>> >&gt;  数据流输出导向，取代、累加</p>
<p>&lt;  &lt;&lt;  输入导向</p>
<p>‘  ‘  不能在内部调用变量</p>
<p>“  “ 可以调用变量</p>
<p>`  ` 可以优先执行的命令（命令嵌套时用）= $()</p>
<p>( )  子shell的起始和结束</p>
<p>{} 命令区块的组合</p>
<p>数据流导向：</p>
<ol>
<li>标准输入：代码为0 &lt;  &lt;&lt;</li>
<li>标准输出：代码为1 &gt;  &gt;&gt;</li>
<li>标准错误输出：代码为2  2&gt;   2&gt;&gt;</li>
</ol>
<p>垃圾桶：/dev/null，所有导向的信息都会消失</p>
<p>两股数据写入同一个文件：</p>
<p><code>&gt; list 2&gt;&amp;1</code></p>
<p><code>&amp;&gt; list</code></p>
<p>使用<code>cat &gt; file</code>可以创建一个文件，直接在命令行输入（^D结束创建）</p>
<p>可以使用文本文件代替键盘输入</p>
<p><code>cat &gt; catfile &lt; ~/.bashrc</code></p>
<p>&lt;&lt; 表示结束的输入字符</p>
<p><code>cat catfile &lt;&lt; &quot;eof&quot;</code>意思是：输入eof后结束输入</p>
<p><img src="/images/Vbird/10-4.1.png" alt=""></p>
<p>依序执行命令<code>cmd1;cmd2;cmd3</code></p>
<p><code>$?</code>命令回传值</p>
<p>正确运行时，命令回传0</p>
<p><code>cmd1 &amp;&amp; cmd2</code>若1回传0则运行2，否则不运行2</p>
<p><code>cmd1 || cmd2</code>若1回传0则不允许2，否则运行2</p>
<p>管线</p>
<p>必须是可以接受stdin和 stdout 的命令</p>
<p><code>cmd1|cmd2|cmd3</code>1的数据通过stdout stdin传给2</p>
<p>截取命令</p>
<p><code>cut</code>：逐行处理</p>
<p><code>cut -d &#39;:&#39; -f 1-4</code>以 ：为分隔符，截取第一个到第四个并显示</p>
<p><code>cut -d &#39;:&#39; -f 1,4</code>只显示第一个和第四个</p>
<p><code>cut -c 5-</code>从第五个字符开始显示</p>
<p><code>grep</code>：搜寻信息</p>
<p><code>grep [-acinv] &#39;str&#39; file</code></p>
<p>-a 将二进制文件以txt文件的方式搜寻</p>
<p>-c  计算找到str的次数</p>
<p>-i   忽略大小写的不同</p>
<p>-n  输出行号</p>
<p>-v   搜寻没有str的行</p>
<p>排序命令</p>
<p><code>sort [-fbMnrutk] [fileorstdin]</code></p>
<p>-f  忽略大小写</p>
<p>-b  忽略开头空格</p>
<p>-M  以月份名排序</p>
<p>-n  使用纯数字排序</p>
<p>-r   反向排序</p>
<p>-u   相同数据只显示一次</p>
<p>-t    分隔符（默认tab）</p>
<p>-k    以哪个区间来排序</p>
<p><code>uniq</code>重复的项目只显示一次</p>
<p>-c  显示重复的次数</p>
<p><code>last | cut -d &#39; &#39; -f1 | sort | uniq -c</code>分割出第一块后，按字母排序，之后只不显示重复的，并显示出重复的次数</p>
<p><code>wc</code>计算文件中有多少字符（word count）</p>
<p>-l  仅列出行</p>
<p>-w 仅列出多少字</p>
<p>-m 多少字符</p>
<p><code>last | grep [a-zA-Z] | grep -v &#39;wtmp&#39;| wc -l</code></p>
<p><code>tee</code>双向导向：将数据流另存为一个文件，同时把数据流继续以stdout传给下一个命令</p>
<p><code>ls -l /home | tee ~/homefile | more</code></p>
<p><code>ls -l /home | tee -a ~/homefile | more</code>有了a参数，就不会覆盖文件，而是在文件后面添加</p>
<p><code>tr [-ds] SET1</code>来删除或取代数据流的信息</p>
<p><code>last | tr [a-z] [A-Z]</code>把数据流中的小写字母换成大写字母</p>
<p>-d 删除信息中SET1这个字符串</p>
<p><code>tr -d &#39;\r&#39;</code>删除DOS文件行尾的^M</p>
<p><code>col [-xb]</code></p>
<p>-x  将tab键转换成空格键</p>
<p>-b  文字内有反斜杠时，仅保留反斜杠最后接的字符</p>
<p><code>join [-til2] file1 file2</code>默认情况下以” “分隔符，比对第一个字段，相同则将数据连成一行</p>
<p>-t  分隔符（默认以空格分隔）</p>
<p>-i   忽略大小写</p>
<p><code>-1</code>第一个文件用第几个字段来分析</p>
<p><code>-2</code>第二个文件用第几个字段来分析</p>
<p><code>paste [-d] file1 file2</code></p>
<p>-d  后面加分隔字符，默认Tab</p>
<p><code>paste /etc/passwd /etc/shadow</code></p>
<p><code>cat /etc/group | paste /etc/passwd - | head -n 3</code> <strong>-</strong> 表示从stdin读取数据</p>
<p><code>expand</code>可以将Tab换成空格键</p>
<p><code>expand -t # -</code> # 从把Tab转换成#个字符，- 从stdin中读取数据</p>
<p><code>split</code>分割</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">split [-bl] file PREFIX</span><br><span class="line">-b  ：后面可接欲分割成的文件大小，可加单位，例如 b, k, m 等；</span><br><span class="line">-l  ：以行数来进行分割。</span><br><span class="line">PREFIX ：代表前导符的意思，可作为分割文件的前导文字。</span><br></pre></td></tr></table></figure>
<p><code>xargs</code>参数代换</p>
<p><code>-</code>的用途</p>
<p>在使用到前一个命令的stdout来作为stdin时，可以使用 - 来替代</p>
<p><code>tar -cvf - /home | tar -xvf -</code> 前一个命令把/home打包的数据传送到 - ，也就是stdout中，后一个命令，通过 - ，获得stdout</p>
<ul>
<li>看完了第十章的内容，已经感觉到疲劳了，脖子和大脑都在抗议，今晚回去整理一下这一周的笔记，就不新开一章了。</li>
</ul>
<hr>
<h3 id="2018-7-19"><a href="#2018-7-19" class="headerlink" title="2018-7-19"></a>2018-7-19</h3><p>今天开始改变排版方式，每一行的行首不带 - 标记</p>
<p><code>bzip2</code></p>
<p>为了取代gzip并提供更好的压缩比而来，用法几乎和gzip相同</p>
<p>参数</p>
<ul>
<li>-c -d -v -# 与gzip相同</li>
<li>-k 保留源文件</li>
<li>-z 压缩（默认参数）</li>
</ul>
<p><code>bzip2</code>提供了更高的压缩比，但是在压缩大文件时速度比gzip要慢很多</p>
<p>可以使用<code>bzcat\bzless\bzmore</code>查看压缩包</p>
<p><code>xz</code></p>
<p>用法几乎也和gzip，bzip2相同</p>
<ul>
<li>-d -t -k -c -#与gzip/bzip2相同</li>
<li>-l 列出压缩文件的相关信息</li>
</ul>
<p>提供更高的压缩比，同时，耗时也更多</p>
<p>使用指令<code>time [gzip|bzip2|xz] -c services &gt; services.[gz|bz2|xz]</code>测试执行时间</p>
<p><img src="/images/Vbird/8-2.1.png" alt=""></p>
<p>看最后一个时间，可以看到三个指令的花费时间依次递增</p>
<p><code>tar</code>打包</p>
<p>gzip\bzip2\xz虽然可以对目录进行压缩，但是他们指的是把目录中的所有文件<strong>分别</strong>压缩</p>
<p>用法</p>
<ul>
<li>打包并压缩：<code>tar [-zjJ] [-cv] [-f + newfilename] filename</code><ul>
<li>-c 创建(create)打包文件，搭配-v可以查看被打包的文件名</li>
<li>-z -j -J 分别是用gzip  bzip2  xz压缩</li>
<li>-f  后面是新的文件名，注意用不同的压缩软件文件名不同，必须和文件名紧挨，中间的参数也会作为文件名</li>
<li>-p 保留源文件的权限和属性</li>
<li>-P 保留绝对路径（默认会去除根目录，如果保留绝对路径，解压缩时就会覆盖原来路径的数据）</li>
</ul>
</li>
<li>查看<code>tar -[zjJ]tv -f filename.tar.*z[2]</code><ul>
<li>-t 查看</li>
<li>-v 显示详细信息，如果不加可以只列出文件名</li>
</ul>
</li>
<li><p>解压缩<code>tar -[zjJ]xv  -f filename.tar.*z[2] -C [directry]</code></p>
<ul>
<li>-C 指定解压目录</li>
<li>-x 解压</li>
</ul>
<p>使用<code>rm -rf [directory]</code>删除目录</p>
</li>
</ul>
<p>解压某个文件</p>
<ul>
<li>先使用<code>tar -jtv -f [file]|grep &#39;filename2find&#39;</code>寻找要找到文件</li>
<li>在使用<code>tar -jxv -f filename.tar.bz2 filenamefinded</code>解压文件，注意，压缩包中的文件名不带根目录</li>
</ul>
<p><img src="/images/Vbird/8-3.1.png" alt=""></p>
<p>打包目录，但不包含其中某些文件</p>
<p><code>tar -jcv -f ~/system.tar.bz2 --exclude=/root/etc* --exclude=/root/system.tar.bz2 /etc /root</code></p>
<ul>
<li>过长的指令可以在中间使用反斜线 <code>\</code>来换行输入</li>
</ul>
<p>打包更加新的文件：更新备份时可以使用，就不用覆盖没有变化的文件了</p>
<p><code>tar -jcv -f newfile.tar.bz2 --newer-mtime[--newer]=&quot;time&quot; file2bzip</code></p>
<ul>
<li>–newer 表示后面输入的日期包含mtime和ctime</li>
<li>–newer-mtime 仅包含mtime</li>
</ul>
<p><code>tar -jtv -f newfile.tar.bz2|grep -v &#39;/$&#39;</code>输出不是以 / 结尾的文件，也就是排除了目录</p>
<ul>
<li>只进行了打包，以tar结尾的文件称为tarfile</li>
<li>打包并压缩为文件，以tar.gz\bz2\xz结尾的文件称为tarball</li>
</ul>
<p>使用<code>tar</code>来备份/etc的数据，复原后无法正常登录系统，大部分是因为/etc/shadow这个密码文件的SELinux类型在复原时被更改了。</p>
<p>恢复方法三种</p>
<ol>
<li>通过救援方式登录系统，修改/etc/selinux/config文件，将SELinux改成permissive模式，重启</li>
<li>复原系统后，不要立即重启，使用<code>restorecon -Rv /etc</code>自动修复一下SELinux类型即可</li>
<li>登录系统，创建/.authorelabel文件，重启后就会自动修复SELinux，再次重启恢复正常</li>
</ol>
<p>XFS filesystem备份和还原</p>
<p><code>xfsdump</code></p>
<p>第一次使用xfsdump备份后，就可以选择使用累计备份：新备份的数据只会记录差异文件</p>
<p>注意事项</p>
<ul>
<li>只能备份挂载的文件系统</li>
<li>必须使用root权限</li>
<li>只能备份XFS文件系统（人家叫xfsdump嘛）</li>
<li>备份数据只能用<code>xfsrestore</code>解析</li>
<li>通过文件的UUID分辨，不能备份两个具有相同UUID的文件系统</li>
</ul>
<p>用法</p>
<p><code>xfsdump [-L S_label] [-M M_label] [-l #] [-f backupfile] filetobackup</code></p>
<p><code>xfsdump -I</code></p>
<p>参数</p>
<ul>
<li>-L 可以填写对此文件系统的简要说明</li>
<li>-M 记录储存媒体的简要说明</li>
<li><code>-l</code>  指定备份等级（默认0，完整备份）</li>
<li>-f  后面接产生的文件，类似tar</li>
<li><code>-I</code>从 /var/lib/xfsdump/inventory 列出目前备份的信息状态</li>
</ul>
<p>备份/boot<code>xfsdump -L boot_all -M boot_all -l 0 /srv/boot.dump /boot</code></p>
<p>产生level 0文件系统</p>
<p>在/boot中创建一个新文件</p>
<p>备份差异文件<code>xfsdump -l 1 -L boot_2 -M boot_2 -f /srv/boot.dump1 .boot</code></p>
<p>产生level 1 文件系统</p>
<p><code>xfsrestore</code></p>
<p>参数</p>
<ul>
<li><code>-I</code>和xfsdump相同</li>
<li>-f  后面接备份文件</li>
<li>-L 接Label name</li>
<li>-s [file or directory] 复原某一个特定文件或目录</li>
<li>-r  一般不需要用，一个磁盘内有多个文件，需要使用</li>
<li>-i  进入互动模式，一般不用</li>
</ul>
<p>复原之前创建的备份<code>xfsrestore -f /sev/boot.dump -L boot_all /boot</code></p>
<p><code>xfsrestore -f /srv/boot.dump -L boot_all /tmp/boot</code></p>
<p><code>du -sm /boot /tmp/boot</code></p>
<p><code>diff -r /boot /tmp/boot</code></p>
<p>复原的结果是：同名的文件被覆盖，新的文件被保留</p>
<p><code>xfsrestore -f /srv/boot.dump -i /tmp/boot3</code>进入互动模式，进行少量复原</p>
<p>光盘写入</p>
<p><code>mkisofs</code>创建镜像文件</p>
<p>使用<code>mkisofs [-o xxxx.iso] [-Jrv] [-V vol] [-m excludefile] filetoiso</code></p>
<p>参数</p>
<ul>
<li>-o  输入你想产生的镜像名称</li>
<li>-J   产生和Windows相容的文件名结构，增加文件名长度到64个Unicode字符</li>
<li>-r   通过Rock Ridge 产生支持Unix/Linux 的文件数据，可记录更多信息</li>
<li>-v   显示创建过程</li>
<li>-V vol 创建Volume</li>
<li>-m file 不备份进去的文件</li>
</ul>
<p>光盘格式为<code>iso9660</code></p>
<p>默认情况下，所以文件都会放在iso文件的根目录下，所以使用-graft-point选项</p>
<ul>
<li>镜像文件中目录所在=时间Linux中目录所在</li>
<li>eg:</li>
<li>/movies/ = /srv/movies/</li>
<li>/linux/etc/ = /etc/</li>
</ul>
<p><code>mkisofs -r -v -o /tmp/system.img /root /home /etc</code></p>
<p><code>mkisofs -r -V &#39;linux_file&#39; -o /tmp/system.img -m /root/etc -graft-point /root=/root /home=/home /etc=/etc</code>设置ISO文件内的目录</p>
<p><code>isoinfo -d -i</code> 查看iso文件的内容</p>
<p><code>rsync -a source destination</code>可以完整地复制所有数据权限属性</p>
<p><code>cdrecord</code>光盘烧录，也可以使用<code>wodim</code></p>
<p><code>wodim -v dev=/dev/sr0 speed-4 -dummy -eject /emp/system.img</code></p>
<p>其他常见压缩和备份工具</p>
<p><code>dd</code></p>
<p>dd可以直接读取磁盘设备（直接读取扇区），然后将整个设备备份成一个文件</p>
<p><code>dd if=/etc/passwd of=/tmp/passwd.back</code></p>
<p>显示信息 4+1 records in 表示使用了4个完整的512B（默认） block，和一个未满的block</p>
<p>将img烧录到USB中<code>dd if=/tmp/system.iso of=/dev/sdb</code></p>
<p>将/boot分区备份<code>dd if=/dev/sda2 of=/tmp/sda2.img</code></p>
<p>dd 的好处是无论什么文件系统，只要在磁盘中记录，就可以备份</p>
<p>将分区拷贝到U盘：447页</p>
<p><code>cpio</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cpio -ovcB &gt; [file/device]</span><br><span class="line">cpio -ivcdu &lt; [file/device]</span><br><span class="line">cpio -ivct &lt; [file/device]</span><br></pre></td></tr></table></figure>
<p>参数</p>
<ul>
<li>-o  output</li>
<li>-B 让默认的block可以添加至5120B</li>
<li>-i    将数据文件或设备copy到系统中</li>
<li>-d   自动创建目录</li>
<li>-u   自动将较新的文件覆盖较旧的文件</li>
<li>-t     配合i参数，用以查看以cpio创建的文件或装置内容</li>
<li>-v    –verbose</li>
<li>-c    以一种新的 portable format 形式存储</li>
</ul>
<p><code>find /boot | cpio -ocvB &gt; /tmp/boot.cpio</code>将/boot备份</p>
<p><code>cpio -idvc &lt; /tmp/boot.cpio</code>解压在/root/boot</p>
<p><code>&lt;</code>标志和<code>&gt;</code>相反，可以把后面的文件传入前面</p>
<p>/home 分区必须直接登录root才能卸载，不能通过一般用户su - 登录root</p>
<h4 id="第九章-vim编辑器！"><a href="#第九章-vim编辑器！" class="headerlink" title="第九章 vim编辑器！"></a>第九章 vim编辑器！</h4><p><code>vi</code>正规的文本编辑器</p>
<p>很多软件的编辑接口都会主动调用vi</p>
<p><code>vim</code>既有程序编辑能力，可以以字体颜色辨别语法的正确性</p>
<ul>
<li><code>vi</code>的使用</li>
</ul>
<p><code>vi</code>具有三种模式：</p>
<ul>
<li>一般指令模式：移动光标，复制粘贴删除等</li>
<li>编辑模式：输入<code>iIoOaArR</code>中的一个字母之后进入编辑模式，左下角会出现INSERT，按下ESC退出编辑模式</li>
<li>命令行模式：输入<code>:/?</code>中的一个符号，可以将光标移动到最下面一列，可以搜索，读取，存盘，替代字符，离开，显示行号等，也可以按ESC离开，进入一般指令模式</li>
</ul>
<p><code>vi filename</code>打开新文件</p>
<p>最后一行是信息提示，上面的是文件内容</p>
<p>输入上面提到的任意英文字母进入编辑模式</p>
<p>按ESC退出</p>
<p>输入<code>:wq</code>保存退出，输入<code>:wq!</code>可以强制写入（账户能够改变权限的情况下）</p>
<p>一般指令模式的其他操作：</p>
<p>使用<code>hjkl</code>四个键可以分别向左下上右移动光标</p>
<p><code>^f</code>向下翻一页</p>
<p><code>^b</code>向上翻一页</p>
<p><code>^d</code>向下翻半页</p>
<p><code>^u</code>向上翻半页</p>
<p><code>+</code>光标移动到下一列（忽略空行）</p>
<p><code>-</code>光标移动到上一列（忽略空行）</p>
<p><code>#&lt;space&gt;</code>#代表数字，光标向后移动#个距离</p>
<p><code>0</code>移动到当前列开头</p>
<p><code>$</code>移动到当前列末尾</p>
<p><code>H</code>移动到屏幕最上一列开头</p>
<p><code>M</code>移动到屏幕中间一列的开头</p>
<p><code>L</code>移动到屏幕最下方一列的开头</p>
<p><code>G</code>移动到文件的最后一页</p>
<p><code>#G</code>移动到文件的第#列</p>
<p><code>gg</code>移动到文件的第一列</p>
<p><code>#&lt;Enter&gt;</code>光标向下移动#列</p>
<p>命令行模式基本操作</p>
<p>搜索和替代：</p>
<p><code>/word</code>向下搜索word字串</p>
<p><code>?word</code>向上搜索word字串</p>
<p><code>n</code>重复上次搜索</p>
<p><code>N</code>显示上一个搜索结果</p>
<p><code>:#1,#2s/word1/word2/g</code>在#1列和#2列之间寻找word1字串并取代为word2字串</p>
<p><code>:1,$s/word1/word2/g</code>从第一列到最后一列搜寻word1并替代为word2</p>
<p><code>:1,$s/word1/word2/gc</code>从第一列到最后一列搜寻word1并需要确认是否替代为word2</p>
<p><code>x</code>向后删除一个字符</p>
<p><code>X</code>向前删除一个字符</p>
<p><code>#x</code>向后删除#个字符</p>
<p><code>dd</code>删除光标所在的一整列</p>
<p><code>#dd</code>删除光标所在向下#列</p>
<p><code>d1G</code>删除光标所在到第一列的所有数据</p>
<p><code>dG</code>删除光标所在到最后一列的所有数据</p>
<p><code>d$</code>删除光标所在到该列的最后一个字符</p>
<p><code>d0</code>删除光标所在到该列的第一个字符</p>
<p><code>yy</code>复制光标所的那一列</p>
<p><code>nyy</code>复制光标所在的向下n列</p>
<p><code>y1G</code>复制光标所在列到第一列的所有数据</p>
<p><code>yG</code>复制光标所在列到最后一列的所有数据</p>
<p><code>y0</code>复制光标所在的那个字符到该行行首的所有数据</p>
<p><code>y$</code>复制光标所在的字符到改行行尾的所有数据</p>
<p><code>p P</code>将已复制的数据粘贴在光标的下一列、上一列</p>
<p><code>J</code>将光标所在列与下一列的数据结合成一列</p>
<p><code>c</code>重复删除多个数据</p>
<p><code>u</code>复原前一个动作</p>
<p><code>^r</code>重做上一个动作</p>
<p><code>.</code>重复前一个动作</p>
<p>进入编辑模式按钮</p>
<p><code>i I</code>在光标处插入；在光标列第一个非空白字符处开始插入</p>
<p><code>a A</code>在光标下一个字符处开始插入；从光标所在列最后一个字符处开始插入</p>
<p><code>o O</code>在光标所在的下一列插入新的一列；在光标所在上一列插入新的一列</p>
<p><code>r R</code>取代模式。只取代光标所在字符一次；一直取代光标所在字符，知道按下ESC</p>
<p>命令行界面</p>
<p><code>:w</code>写入改动</p>
<p><code>:w!</code>强制写入，没有文件的w权限时</p>
<p><code>:q :q!</code></p>
<p><code>:wq :wq!</code></p>
<p><code>ZZ</code>：有更改则存储后离开，没有更改则不存储离开</p>
<p><code>:w [filename]</code>存储为另一个文件</p>
<p><code>:r [filename]</code>将filename的文件读入光标所在列的后面</p>
<p><code>:#1,#2 w [filename]</code>将#1行到#2行的内容存储为filename文件</p>
<p><code>!command</code>可以暂时离开vi到命令行去执行command。</p>
<p><code>vim</code>环境</p>
<p><code>:set nu</code>显示行号</p>
<p><code>:set nonu</code>取消行号显示</p>
<p>练习：</p>
<p>6 -&gt; a</p>
<p>7 -&gt; 93</p>
<p>8 -&gt; 13</p>
<p>9 -&gt; u*13</p>
<p>10 -&gt; 66G 6yy G p</p>
<p>11 -&gt; :113,128 d</p>
<p>13 -&gt; 15x t</p>
<p>14 -&gt;  gg O I am a student… :wq</p>
<p>vim编辑时按下 ^z会进入后台执行</p>
<p>输入<code>ls -al</code>找到暂存盘</p>
<p>把swp文件删除即可（如果不想保存更改）</p>
<p>如果想继续之前的更改，进入vim，使用R模式</p>
<p>Vim的特殊性</p>
<p>输入<code>alias</code>可以显示命令别名，我们发现，执行vi的时候默认执行的是vim</p>
<p><strong>区块选择：</strong></p>
<p>在Vim中按下</p>
<p><code>v</code>光标经过的字符会被选择</p>
<p><code>V</code>光标经过的列会被选择</p>
<p><code>^v</code>用长方形的方式选择数据</p>
<p><code>y</code>复制</p>
<p><code>d</code>删除</p>
<p><code>p</code>粘贴</p>
<p>多文件编辑</p>
<p><code>:n</code>下一个文件</p>
<p><code>:N</code>上一个文件</p>
<p><code>:files</code>列出所有打开的文件</p>
<p><code>:sp [filename]</code>多窗口打开多个文件</p>
<ul>
<li><code>^w + ↑/↓/j/k</code>切换文件</li>
<li>可以互相复制粘贴</li>
<li><code>^w + q</code>离开</li>
</ul>
<p>vim的补齐功能</p>
<ul>
<li><code>^x -&gt; ^n</code>通过文件内容为关键字补齐</li>
<li><code>^x -&gt; ^f</code>通过文件名做关键字补齐</li>
<li><code>^x -&gt; ^o</code>通过扩展名作为语法补充</li>
</ul>
<p>一定要注意文件的扩展名，有扩展名才能补齐</p>
<p>使用<code>~/.vimrc</code>设置vim配置文件</p>
<p><img src="/images/Vbird/vim-commands.jpg" alt=""></p>
<p>只要源文件的编码和终端的编码相同，vim就不会乱码</p>
<p>设置系统编码：</p>
<p><code>LANG=zh_CH.gbk</code></p>
<p><code>export LC_ALL=zh_CH.gbk</code></p>
<p>就可以读取gbk编码的文件了</p>
<p><code>shell script</code>的行尾问题</p>
<p>Windows系统的行尾是CRLF（^M\$），Linux系统的行尾是LF（\$）</p>
<p>执行script的时候会出问题</p>
<p>使用dos2unix指令来转换</p>
<p>安装，需要网络或everything版本的CentOS iso</p>
<p><code>mount /dev/sr0 /mnt</code></p>
<p><code>rpm -ivh /mnt/Packages/dos2unix-*</code></p>
<p><code>umount /mnt</code></p>
<p><code>unix2dos -k man_db.conf</code></p>
<p><code>dos2unix -k -n man_db.conf man_db.conf.linux</code></p>
<p>使用<code>iconv-f 原编码 -t 新编码 filename [-o newfile]</code>转换文件编码</p>
<p>正确读取鸟哥网页的方式：</p>
<p><img src="/images/Vbird/8-5.1.png" alt=""></p>
<p>将繁体UTF8编码转换成简体UTF8编码：</p>
<p><code>iconv -f utf8 -t big5 vi.utf8 | iconv -f big5 -t gb2312 | iconv -f gb2312 -t utf8 -o vi.gb.utf8</code></p>
<h4 id="第十章-认识与学习BASH"><a href="#第十章-认识与学习BASH" class="headerlink" title="第十章 认识与学习BASH"></a>第十章 认识与学习BASH</h4><p>shell与kernel核心沟通，调用硬件，只是提供给使用者操作系统的一个接口，可以通过shell来操作其他应用程序</p>
<p>Linux使用的shell称为：”Bourne Again SHell”简称BASH</p>
<p>检查/etc/shells文件，可以看到有多少Linux可以使用的shell</p>
<p>看到10.1.4 Bash shell 的功能（水喝完了……出去买水）</p>
<hr>
<h3 id="2018-7-18"><a href="#2018-7-18" class="headerlink" title="2018-7-18"></a>2018-7-18</h3><ul>
<li>又是精力充沛的一天啊，珍惜这样的时日吧！</li>
<li><strong>指令查找</strong></li>
<li><code>which -a command</code><ul>
<li>-a 将所有在<strong>PATH目录</strong>中可以找到的指令均列出，不止第一个指令</li>
</ul>
</li>
<li>使用which寻找which的位置<code>which which</code></li>
<li>alias就是所谓的命令别名，如<code>ll</code> = <code>ls -l</code></li>
<li><strong>文件查找</strong></li>
<li><code>find</code>不常用，原因：慢，费硬盘</li>
<li>首先选择<code>whereis</code>或<code>locate</code>来查找，找不到才使用<code>find</code></li>
<li><code>whereis</code>在一些特定目录中寻找文件名</li>
<li>用法<code>whereis [-bmsu] fileordirname</code><ul>
<li>-l 可以列出whereis会去查询的几个目录</li>
<li>-b 只查找二进制文件</li>
<li>-m 只在说明文档manual路径下查找</li>
<li>-s 只查找source 来源文件</li>
<li>-u 搜寻不在上述三个项目中的其他特殊文件</li>
</ul>
</li>
<li>可以使用<code>whereis -l</code>列出whereis将查找的目录，主要是bin目录和man的目录</li>
<li><code>locate/updatedb</code></li>
<li><code>locate [-ir] keyword</code>找出所有和keyword相关的文件名<ul>
<li>-i 忽略大小写差异</li>
<li>-c 不输出文件名，仅输出数量</li>
<li>-l 仅输出几行，-l 5意思是输出5行</li>
<li>-S 输出locate所使用的数据库文件的相关信息，包括数据库记录的文件/目录数量</li>
<li>-r 后面可以接正则表达式</li>
</ul>
</li>
<li>找出5个和passwd相关的文件名<code>locate -l passwd</code></li>
</ul>
<p><img src="/images/Vbird/6-5.1.png" alt=""></p>
<ul>
<li>列出locate查询所使用的数据库文件<code>locate -S</code></li>
</ul>
<p><img src="/images/Vbird/6-5.2.png" alt=""></p>
<ul>
<li>locate搜寻的数据库mlocate.db，在CentOS系统中，将每天更新一次数据，只有在数据库中的文件才能找得到</li>
<li>手动更新数据库<code>updatedb</code></li>
</ul>
<p><img src="/images/Vbird/6-5.3.png" alt=""></p>
<ul>
<li>可以看到，我在用一般用户执行updatedb时，会产生错误，这是因为一般用户无法读取mlocate.db文件，在之前的实验中也看到了</li>
<li><code>find [PATH] [option] [action]</code></li>
<li>与时间有关的选项，下方以mtime为例，也可以对atime和ctime使用<ul>
<li>-mtime n ：n为数字，意义为，在n天之前的一天之内被更改过的文件</li>
<li>-mtime +n：列出n天之前（不含n天本身）被更改过的文件</li>
<li>-mtime -n：列出n天之内（不含n天本身）……</li>
<li>-newer file：file是一个已存在的文件名，列出比file还要新的文件名称</li>
</ul>
</li>
<li>与使用者或群组名称有关的选项<ul>
<li>-uid n：n为数字，是使用者账号的ID</li>
<li>-gid n：n为数字，是群组名称的ID</li>
<li>-user name：name 是使用者的名称</li>
<li>-group name：name是群组的名称</li>
<li>-nouser：寻找文件的拥有者不存在于/etc/passwd记录的人</li>
<li>-nogroup：寻找文件的拥有群组不存在与/etc/group</li>
</ul>
</li>
<li>由源代码自行编译的软件也可能是nouser</li>
<li>与文件权限及名称有关的参数<ul>
<li>-name filename：搜寻指定文件名称的文件</li>
<li>-size [+-]SIZE：搜寻比SIZE还要大或小的文件</li>
<li>-type TYPE：搜寻文件类型为TYPE的<ul>
<li>f 一般正规文件</li>
<li>b，c设备文件</li>
<li>d目录</li>
<li>l（小写L）链接文件</li>
<li>s socket文件</li>
<li>p FIFO文件</li>
</ul>
</li>
<li>-perm mode 搜寻权限为mode的文件</li>
<li>-perm -mode 搜寻权限包裹mode 的文件</li>
<li>-perm /mode 搜寻权限包含任一mode中的权限</li>
</ul>
</li>
<li><code>find /usr -name &quot;*passwd*&quot;</code>寻找包含passwd的文件</li>
<li><code>find /run -type s</code>寻找类型为socket的文件</li>
<li><code>find / -perm /7000</code>寻找带有SUID SGID SBIT权限的文件</li>
<li>其他选项和参数<ul>
<li>-exec command：command为其他指令，可以用其他指令来处理搜寻到的结果</li>
<li>-print：将结果打印在屏幕上，默认选项</li>
</ul>
</li>
</ul>
<p><img src="/images/Vbird/6-5.4.png" alt=""></p>
<ul>
<li><code>find / -perm /6000 -exec ls -l {} \;</code>找出带有SUID 和SGID的文件并用ls显示其具体属性</li>
<li>{}代表find找到的内容，封号;代表-exec的结束，因为；在bash中有特殊含义，所以用\来转义</li>
<li>找出大小在50k到60k之间的文件<code>find / -size +50k -a -size -60k -exec ls -hl {} \;</code> ，这里-a表示and，<code>ls -h</code>显示文件大小单位</li>
<li>找出大于50k且所有人不是root的文件<code>find / -size +50k -a ! -user root -exec ls -lhd {} \;</code>，可以用！表示NOT的逻辑运算</li>
<li>找出容量大于50k和容量等于0的文件<code>find /etc -size +50k -o -size 0 -exec ls -lh {} \;</code>，-o 表示or</li>
</ul>
<h4 id="第七章-Linux磁盘与文件系统管理"><a href="#第七章-Linux磁盘与文件系统管理" class="headerlink" title="第七章 Linux磁盘与文件系统管理"></a>第七章 Linux磁盘与文件系统管理</h4><ul>
<li>Windows 98 以前的文件系统是FAT</li>
<li>Windows 2000 以后的是NTFS</li>
<li>Linux的文件系统是Ext2</li>
<li>LVM可以将一个分区格式化为多个磁盘系统</li>
<li>LVM RAID都可以把多个分区合成一个文件系统</li>
<li>Linux文件系统会将权限和属性放在inode中，实际数据放在data block中，文件较大时会占用多个block</li>
<li>superblock记录整个文件系统的整体信息</li>
<li>inode中有文件数据放置的block号码</li>
<li>索引式文件系统<ul>
<li>根据inode中的号码查询block，然后读取数据</li>
</ul>
</li>
<li>FAT为链式读取，如果block过于离散，就会导致文件读取性能变差，就需要磁盘重组</li>
<li>Ext2文件系统</li>
<li><strong>data block</strong><ul>
<li>支持1K 2K 4K三种大小的block</li>
<li>格式化时block大小固定，不能改变</li>
<li>每个block只能存放一个文件的数据</li>
<li>如果文件大小大于block，则会占用多个block来存储</li>
<li>如果文件大小小于block，则剩余的容量不能继续使用（因此导致空间浪费）</li>
<li>1kb大小block支持最大单一文件为16GB，最大文件系统容量为2TB</li>
<li>2kb大小block  为    256GB 8TB</li>
<li>4kb 大小block 为     2TB  16TB</li>
</ul>
</li>
<li>所以选择block大小时要根据需要</li>
<li><strong>inode table</strong></li>
<li>记录的数据<ul>
<li>文件的rwx属性（存取模式）</li>
<li>文件的owner 和 group</li>
<li>文件的容量</li>
<li>文件创建或状态改变的实际（ctime）</li>
<li>最近读取时间（atime）</li>
<li>最近修改时间（mtime）</li>
<li>定义文件特征的标志（flag）如SUID</li>
<li>该文件内容的指向（pointer）</li>
</ul>
</li>
<li>inode的数量和大小也是在格式化时就已经固定了<ul>
<li>每个inode大小均为128字节（Ext4和xfs可以到256字节）</li>
<li>每个文件都仅占用一个inode</li>
<li>文件系统能够创建的文件数量与inode的数量有关</li>
<li>系统读取文件时需要先找到inode，分析inode记录的权限与使用者是否符合，然后在开始读取block的内容</li>
</ul>
</li>
</ul>
<p><img src="/images/Vbird/inode.jpg" alt=""></p>
<ul>
<li>inode的指定，12个直接指向，一个间接指向，一个双间接指向，一个三间接指向。</li>
<li>每笔block号码记录会花费4字节，1K的block用来做间接指向可以记录256个号码</li>
<li>多层间接指向每一层用来指定下一次的block可以指定256个下一层</li>
<li><strong>Superblock</strong>超级区块</li>
<li>记录整个filesystem的相关信息<ul>
<li>记录block与inode 的总量</li>
<li>未使用与已使用的inode/block的数量</li>
<li>block与inode的大小（block：1k,2k,4k, inode: 128B, 256B）</li>
<li>filesystem的挂载时间，最近一次写入时间，最近一次检查磁盘时间</li>
<li>一个valid bit 数值，若文件系统已挂载，valid bit 为0，未挂载valid bit为1</li>
</ul>
</li>
<li>一般superblock的大小为1024B，可以用<code>dumpe2fs</code>指令查看信息</li>
<li>第一个superblock作为filesystem的superblock，如果其他block group中也有superblock，则作为第一个superblock的备份<ul>
<li>Filesystem Description：描述每个block group的开始结束号码，以及每个group区段分别介于哪一个block号码之间</li>
<li>block bitmap：记录哪些block是空的</li>
<li>inode bitmap：记录未使用的inode号码</li>
<li>dumpe2fs：查询superblock的指令（xfs文件系统已经不能使用此命令）</li>
</ul>
</li>
<li><code>blkid</code>可以调出系统中所以被格式化的设备</li>
</ul>
<ul>
<li>创建目录时，文件系统会分配一个inode与至少一块block给该目录</li>
<li>inode记录该目录的权限和属性，以及那块block的号码</li>
<li>block记录这个目录下的文件名，以及文件名占用的inode号码</li>
<li>想观察文件夹内文件占用的inode号码，可以用<code>ls -i</code>来显示</li>
</ul>
<p><img src="/images/Vbird/7-1.1.png" alt=""></p>
<ul>
<li>当目录中文件过多时，会多一个block来记录</li>
<li>文件系统规划很大时，文件通常无法连续写，block号码通常是离散的</li>
<li>新建文件时，文件系统的行为：<ul>
<li>确定使用者对目录是否有wx权限</li>
<li>根据inode bitmap找到没有使用的inode号码，写入新文件的权限/属性</li>
<li>根据block bitmap找到没有使用的block号码，写入实际数据，并更新inode</li>
<li>将刚刚写入inode和block数据同步更新inode bitmap和block bitmap，并更新superblock的内容</li>
</ul>
</li>
<li>一般，将inode table 和 data block称为数据存放区域，而superblock、block bitmap、inode bitmap等区段称为metadata（中介数据），因为他们经常变动，每次新增，移除，编辑都会影响这三个部分的数据</li>
<li>数据的不一致（inconsistent）状态：</li>
<li>metadata与实际数据存放区产生不一致（在未更新metadata前系统突然中断），Ext2系统会在重启时进行数据一致性检查。</li>
<li>日志式文件系统（journaling filesystem）</li>
<li>在filesystem中规划出专门记录写入和修订文件时的步骤<ul>
<li>预备：要写入文件时，先在日志记录区块中记录某个文件，准备要写入的信息</li>
<li>实际写入：开始写入文件的权限和数据，开始更新metadata</li>
<li>结束：在日志记录区块当中完成该文件的记录</li>
</ul>
</li>
<li>Linux文件系统的运行</li>
<li>异步处理：<ul>
<li>如果载入内存的数据是未变动过的，会被标志为clean，如果被更改了，则会被标志为dirty</li>
<li>系统会不定时地把内存中标志为dirty的数据写入硬盘</li>
<li>也可以通过<code>sync</code>指令手动把内存中的dirty数据写入硬盘</li>
</ul>
</li>
<li>挂载点的意义：</li>
<li>将文件系统和目录树结合称为挂载（mount）</li>
<li>其他Linux支持的文件系统与VFS<ul>
<li>传统文件系统：Ext2/minix/MS-DOS/FAT/iso9660（光盘）</li>
<li>日志式文件系统：Ext3/Ext4/ReiserFS/Windows’ NTFS/IBM’s JFS/SGI’s XFS/ZFS</li>
<li>网络文件系统：NFS/SMBFS</li>
</ul>
</li>
<li>查看目录<code>ls -l /lib/modules/$(uname -r)/kernel/fs</code>来获取Linux支持的文件系统</li>
</ul>
<p><img src="/images/Vbird/7-1.2.png" alt=""></p>
<ul>
<li>查看目前已载入到内存中支持的文件系统<code>cat /proc/filesystems</code></li>
<li>Linux VFS （Virtual Filesystem Switch）</li>
<li>Linux通过这个核心来管理filesystem</li>
<li><strong>参考相关链接[5]</strong></li>
<li>XFS文件系统配置</li>
<li>数据分布上分为三个区：<ol>
<li>数据区：整个文件系统的superblock、剩余空间的管理机制、inode的分配与追踪，inode和block都是在需要用时才动态产生。<ul>
<li>XFS的block容量可由512B到64K调配，但是由于Linux环境下最高只能使用4K的block</li>
<li>inode的容量可由256B到2M，不过256B的默认值就足够了</li>
</ul>
</li>
<li>文件系统活动登录区（log section）：记录文件的变化，直到变化完整写入数据区后才会结束。可以理解为日志区。<ul>
<li>可以指定外部磁盘为xfs的日志区，如果用SSD来做日志区，可以更快速的工作了</li>
</ul>
</li>
<li>实时运行区（realtime section）：创建文件时，会在这个section中找数个extent区块，将文件放置在这个区块内，分配完毕后，再写入data section的 block和inode中</li>
</ol>
</li>
<li>使用 <code>xfs_info</code>观察数据</li>
<li><code>df -T /boot</code>找出/boot挂载点下文件系统的superblock记录</li>
<li><code>xfs_info /dev/sda2</code></li>
</ul>
<p><img src="/images/Vbird/7-1.3.png" alt=""></p>
<ul>
<li>isize = inode的大小    agcount = 储存区群组个数    agsize = 每个储存区群组的block个数</li>
<li>sectsz = 逻辑扇区容量  </li>
<li>bsize =block的容量 </li>
<li>sunit、swidth 是有关磁盘阵列stripe的，因为没有用磁盘阵列，所以是0</li>
<li>internal = 这个log section在filesystem内，而不是外部</li>
<li>extsz = extent的容量</li>
</ul>
<ul>
<li>文件系统简单操作</li>
<li>df：列出文件系统的整体磁盘使用量<ul>
<li><code>df [-ahikHTm] [dirorfilename]</code>，后面加上目录或者文件时，会自动分析目录所在partition的容量</li>
<li>-a 列出所有的文件系统，包括系统特有的/proc等文件系统</li>
<li>-k、-m 以KBytes、MBytes的容量单位显示各文件系统（默认KB）</li>
<li>-h 在结果处，以GB, MB, KB等格式自行显示大小</li>
<li>-H 以十进制的进位方式显示MB与KB的换算</li>
<li>-T 显示type</li>
</ul>
</li>
<li>主要关心根目录<code>/</code>的容量，如果没有容量了的话Linux就问题很大了</li>
<li>/dev/shm 是内存仿真出来的，存取很快，但不会存入硬盘</li>
<li>du：评估文件系统的磁盘使用量<ul>
<li><code>du [-ahskm] fileordirname</code></li>
<li>-a 列出所有的文件与目录容量（默认仅统计目录下的文件量）（列文件时用）</li>
<li>-h 加个单位：G/M</li>
<li>-s 列出总量，不列出每个个别的目录占用容量（列本目录时用，不显示子目录，但是数值是相加的）</li>
<li>-S 不包括子目录下的总计（子目录的数值也不会添加上去）</li>
<li>-k -m 以KB/MB作为容量显示（默认KB）</li>
</ul>
</li>
<li>实体链接与符号链接</li>
<li>Hard link（实体链接）</li>
<li>多个文件名链接到同一个inode号码，Hard link 和源文件inode号码相同</li>
<li>用<code>ln source destination</code>来创建Hard link</li>
<li>限制<ul>
<li>不能跨Filesystem</li>
<li>不能链接到目录</li>
</ul>
</li>
<li>Symbolic Link（符号链接）</li>
<li>相当于Windows快捷方式</li>
<li>创建了一个独立的文件，让数据读取指向link的文件名</li>
<li>如果删除源文件会导致无法打开</li>
<li>Symbolic link文件和源文件inode是不同的，因此建立Symbolic Link文件是会占用inode的</li>
<li>Symbolic link文件大小和带绝对路径的源文件大小是相同的</li>
<li><code>ln [-sf] source destination</code><ul>
<li>-s 创建Symbolic Link，默认创建Hard Link</li>
<li>-f 如果destination存在，则主动移除Destination后再创建</li>
</ul>
</li>
</ul>
<p><img src="/images/Vbird/7-1.4.png" alt=""></p>
<ul>
<li><code>lsblk [-dfimpt] [device]</code>列出系统上所有的磁盘列表<ul>
<li>-d 仅列出磁盘本身</li>
<li>-f  同时列出该磁盘内的文件系统名称</li>
<li>-i   使用ASCII的线段输出</li>
<li>-m 同时输出该设备在/dev 下面的权限数据</li>
<li>-p   列出完整的文件名</li>
<li>-t    列出详细数据，包括磁盘伫列机制</li>
</ul>
</li>
<li>下达<code>lsblk</code>，显示数据</li>
</ul>
<p><img src="/images/Vbird/7-1.5.png" alt=""></p>
<ul>
<li>MAJ:MIN ：kernel识别设备代码，主要：次要 设备</li>
<li>RM：是否为可卸载设备。</li>
<li>RO：是否为只读设备。</li>
<li><code>blkid</code>列出设备的UUID等参数</li>
<li><code>parted</code>列出磁盘的分区表类型与分区信息<ul>
<li><code>parted [device_name] print</code>列出设备相关数据，可以看到MBR分区还是GPT分区</li>
</ul>
</li>
<li>MBR分区使用fdisk</li>
<li>GPT分区使用gdisk</li>
<li><code>gdisk device_name</code></li>
<li>分区步骤<ol>
<li>通过lsblk或blkid找到磁盘</li>
<li>用<code>parted /dev/xxx print</code>找出内部分区表类型</li>
<li>用gdisk或fdisk来操作系统</li>
</ol>
</li>
<li><code>gdisk</code>的选项<ul>
<li>w 保存退出，q 不保存退出，所以只要退出时按下q就可以随便玩gdisk了</li>
<li>用n添加分区</li>
<li>d删除分区</li>
<li>可以输入？自行查看指令</li>
</ul>
</li>
<li>文件系统ID：Linux：8300/8200(swap)/8e00<ul>
<li>​        Windows:0700</li>
</ul>
</li>
<li>使用<code>cat /proc/partitions</code>查看分区情况</li>
<li>新分区之后不会立即看到新的分区，系统提示需要重启才能看到新的分区</li>
<li>也可以通过命令<code>partprobe</code>更新Linux核心的分区表信息</li>
<li><code>partprobe -s</code>可以显示信息</li>
<li><strong>注意！不要处理正在使用的分区，如果要删除正在使用的分区，必须先将其卸载，直接删除的话核心会无法更新分区表信息</strong></li>
<li>MBR分区表使用fdisk分区</li>
</ul>
<ul>
<li><p>……磁盘分区完成！</p>
</li>
<li><p>开始磁盘格式化！</p>
</li>
<li>XFS文件系统<code>mkfs.xfs</code></li>
<li>格式化 == 创建文件系统</li>
<li><code>mkfs.xfs [-bdfiLlr] device</code></li>
<li>输入<code>mkfs.xfs --help</code>可以看到完整的参数介绍</li>
<li>直接加device名称使用默认设置</li>
<li>CentOS 7默认值</li>
</ul>
<p><img src="/images/Vbird/7-3.1.png" alt=""></p>
<ul>
<li>agcount参数可以和CPU核心数设置相同</li>
<li><code>grep &#39;processor&#39; /proc/cpuinfo</code>查看CPU编号</li>
<li>有两颗核心时，设置agcount<code>mkfs.xfs -f -d agcount=2 /dev/sda4</code> -f 参数强制格式化</li>
<li><strong>7.3 XFS文件系统for RAID性能优化</strong> 已跳过，可以看完14章后回来再看</li>
<li>可以使用<code>mkfs.ext4</code>来格式化出Ext4的分区</li>
<li>其他文件系统<code>mkfs</code></li>
<li>输入<code>mkfs</code>然后双击Tab就可以看到支持的全部的文件系统</li>
<li>用法都与<code>mkfs.xfs</code>类似</li>
</ul>
<ul>
<li>……格式化完成！</li>
<li>开始检验文件系统！</li>
<li>当xfs文件系统错乱时！！！使用<code>xfs_repair</code>指令救援（为什么会错乱啊555555）</li>
<li><code>xfs_repair</code>参数们！<ul>
<li>-f 后面的设备其实是文件而不是实体设备！</li>
<li>-n 就仅仅是检查一下而已啦（我就碰碰我不进去）</li>
<li>-d 针对根目录<code>/</code>进行检查和修复的动作！炒鸡危险哒！</li>
</ul>
</li>
<li>检查方法<code>xfs_repair device</code>，有7个流程，可以通过man xfs_repair查看</li>
<li><em>使用xfs_repair时，被修复的硬盘不能已被挂载！</em></li>
<li>如果根目录出现问题….<ul>
<li>你就需要进入单人维护模式或救援模式</li>
<li>通过-d选项强制检验设备</li>
<li>检验完毕重新开机</li>
</ul>
</li>
<li>使用<code>fsck.ext4</code>来处理Ext4文件系统</li>
<li>参数们！<ul>
<li>-p 萌萌的小P，自动帮您选择需要选择<code>y</code>的步骤哟！</li>
<li>-f   强制检查！当fsck没有发现任何标志时不会主动进入，此时就需要-f来强行进入！</li>
</ul>
</li>
<li><code>dumpe2fs -h /dev/sda5|grep &#39;Blocks per group&#39;</code>查看每个block群组有多少个block，然后因为block号码是从0开始的，所以第二个superblock就在这个数字的位置！</li>
</ul>
<p><img src="/images/Vbird/7-3.2.png" alt=""></p>
<ul>
<li>那么就根据这个superblock来检测系统</li>
<li><code>fsck.ext4 -b 32768 /dev/sda5</code></li>
<li><strong>Attention!上述介绍的两个指令（fsck.ext4 xfs_repair）对系统有可能造成损害，所以只有在系统出现大问题（开机必须进入单人单击模式）时才使用</strong></li>
<li>此外，被检查的分区必须在卸载状态，不能挂载在系统上</li>
</ul>
<ul>
<li><p>……分区检测完毕！</p>
</li>
<li><p>开始文件系统挂载与卸载！！</p>
</li>
<li>前提条件：<ul>
<li>单一文件系统不应该被重复挂载在不同挂载点</li>
<li>单一目录不应该重复挂载多个文件系统</li>
<li>作为挂载点的目录理论上应该都是空目录（如果不是空的，文件会被隐藏，知道新分区卸载，才会再次出现！）</li>
</ul>
</li>
<li><code>mount</code>指令！博大精深！<ul>
<li>-a 依照配置文件 /etc/fstab 将所有未挂载的磁盘都挂载上来</li>
<li>-l 增加Label</li>
<li>-t 增加类型，不过Linux会自动检测文件系统的类型，检测顺序见 /etc/filesystems</li>
<li>-n 在默认情况下，系统会把实际挂载情况写入/etc/mtab，但在单人维护模式中，会刻意不写入，加入这个选项让他写入吧！</li>
<li>-o 接挂载时额外加上的参数</li>
</ul>
</li>
<li>Linux已经载入的文件系统类型：/proc/filesystems</li>
<li>查看Linux是否有相关文件系统类型的驱动程序：/lib/modules/$(uname -r)/kernel/fs/</li>
<li>用UUID来挂载新分出的sda4区</li>
<li><code>blkid /dev/sda4</code>查看UUID</li>
<li><code>mount UUID=&quot;&quot; /data/xfs</code>会报错，非正规目录，先手动创建一个</li>
<li><code>mkdir -p /data/xfs</code></li>
<li><code>mount UUID=&quot;&quot; /data/xfs</code></li>
<li><code>df /data/xfs</code>查看分区挂载情况</li>
</ul>
<ul>
<li>重新挂载根目录</li>
<li><code>mount -o remount,rw,auto /</code>如果不加后两个参数，根目录会被挂载为只读</li>
<li>也可以把一个目录挂载到另一个目录上去（不能添加symbolic Link的时候可以这么做）</li>
<li><code>mkdir /data/var</code></li>
<li><code>mount --bind /var /data/var</code></li>
<li>这样就挂载好了，看看结果</li>
<li><code>ls -ild /var /data/var</code></li>
<li>发现内容是完全一样的</li>
</ul>
<ul>
<li><code>umount</code>卸载设备，学了挂载肯定也得学卸载喽<ul>
<li>-f 强制！</li>
<li>-l 立即卸载！更加强制</li>
<li>-n 不更新 /etc/mtab 的情况下卸载</li>
<li>（好粗暴哟）</li>
</ul>
</li>
<li>卸载之后可以使用df 或 mount 查看</li>
</ul>
<ul>
<li>Linux下所有文的设备都是文件。文件通过major 和 minor两个数值来表示</li>
<li>由<code>mknod</code>来手动创建设备文件</li>
<li><code>mknod device [bcp] [major] [minor]</code><ul>
<li>b 设置设备为一个周边储存设备</li>
<li>c  设置设备为一个周边输入设备</li>
<li>p  设置设备为一个FIFO文件</li>
</ul>
</li>
</ul>
<ul>
<li>xfs_admin修改UUID和Label name<ul>
<li>如果格式化的时候忘记加上标头名称，就可以用这条指令来添加</li>
</ul>
</li>
<li><code>xfs_admin [-lu] [-L label] [-U uuid] device</code><ul>
<li>-l -u ，列出device的label name ，UUID</li>
<li>-L，设置device的Label name</li>
<li>-U，设置device的UUID</li>
</ul>
</li>
<li><code>uuidgen</code>生成新的UUID</li>
</ul>
<ul>
<li>fstab的信息:</li>
<li><p><code>[设备/UUID等] [挂载点] [文件系统] [文件系统参数] [dump] [fsck]</code></p>
</li>
<li><p>文件系统参数：</p>
</li>
</ul>
<p><img src="/images/Vbird/7-3.4.png" alt=""></p>
<ul>
<li>将想要开机挂载的分区添加到fstab中就可以开机自动挂载了</li>
<li><code>nano /etc/fstab</code>编辑fstab</li>
<li><code>UUID=&quot;&quot; /data/xfs xfs defaults 0 0</code>添加开机自动挂载/dev/sda4到/data/xfs上</li>
<li>测试语法是否正确<ul>
<li><code>df</code>先确定/dev/sda4还未挂载</li>
<li><code>mount -a</code>按配置文件挂载</li>
<li><code>df</code>如/dev/sda4被挂载上，则语法无误</li>
</ul>
</li>
<li>如果语法有错误，将从单人维护模式进入，根目录是只读状态可以使用命令</li>
<li><code>mount -n -o remount,rw /</code>重新挂载根目录，修改/etc/fstab</li>
<li>直接挂载镜像文件<ul>
<li>创建挂载点<code>mkdir /data/dvd</code></li>
<li>挂载！<code>mount -o loop [.iso文件] /data/dvd</code></li>
<li>卸载<code>umount /data/dvd</code></li>
</ul>
</li>
<li>挂载大型文件<ul>
<li>创建空文件在/src/loopdev<code>dd if=/dev/zero of=/srv/loopdev bs=1M count=512</code><ul>
<li>if ：input file输入文件,/dev/zero是会一直输出0的设备</li>
<li>of：output file，将一堆0写在/srv/loopdev中</li>
<li>bs：每个block的大小</li>
<li>count：总共有多少个block</li>
</ul>
</li>
<li>格式化大型文件<code>mkfs.xfs -f /srv/loopdev</code></li>
<li>挂载<code>mount -o loop UUID=&quot;&quot; /mnt</code></li>
<li>设置开机挂载<ul>
<li><code>nano /etc/fstab</code></li>
<li><code>/srv/loopdev /data/file xfs defaults,loop 0 0</code>（鸟哥教程上是defaults**,loop**，但我测试时，会报错）</li>
</ul>
</li>
</ul>
</li>
<li><strong>swap之创建</strong></li>
<li>步骤：</li>
<li>分区 <code>gdisk</code><ul>
<li><code>gdisk /dev/sda</code></li>
<li>+512M</li>
<li>8200</li>
<li><code>partprobe</code></li>
</ul>
</li>
<li>格式化 <code>mkswap</code><ul>
<li><code>mkswap /dev/sda6</code></li>
</ul>
</li>
<li>使用 <code>swapon device</code><ul>
<li><code>swapon /dev/sda6</code></li>
</ul>
</li>
<li>观察 <code>free &amp; swapon -s</code></li>
<li>写入配置文件<ul>
<li><code>nano /etc/fstab</code></li>
<li><code>UUID=&quot;&quot; swap swap dafaults 0 0</code></li>
</ul>
</li>
</ul>
<p><img src="/images/Vbird/7-5.1.png" alt=""></p>
<ul>
<li>使用文件创建swap</li>
<li>创建一个128MB的swap</li>
<li>创建一个128MB的文件<ul>
<li><code>dd if=/dev/zero of=/tmp/swap bs=1M count=128</code></li>
</ul>
</li>
<li>格式化为swap格式<ul>
<li><code>mkswap /tmp/swap</code></li>
</ul>
</li>
<li>启动<ul>
<li><code>swapon /tmp/swap</code></li>
</ul>
</li>
<li>设置自动启用<ul>
<li><code>nano /etc/fstab</code></li>
<li><code>/tmp/swap swap swap defaults 0 0</code></li>
</ul>
</li>
<li>关闭swap file<ul>
<li><code>swapoff /tmp/swap /dev/sda6</code></li>
</ul>
</li>
<li>按照配置文件启动<ul>
<li><code>swapon -a</code></li>
</ul>
</li>
</ul>
<ul>
<li>文件系统的特殊观察与操作</li>
<li>使用<code>ls</code>时会有<strong>总用量</strong>或<strong>total</strong>标识，那就是目录使用的block的大小，可以看到，不足4k的文件依然占用了4k的存储空间</li>
</ul>
<p><img src="/images/Vbird/7-6.1.png" alt=""></p>
<ul>
<li>使用<code>parted</code>创建分区<ul>
<li><code>parted /dev/sda print</code>找到下一个分区的起始点</li>
<li><code>parted /dev/sda mkpart primary fat32 36.0Gb 36.5GB</code> 仅需要这一条指令就可以创建分区，不需要和用户互动。</li>
<li><code>parted /dev/sda print</code></li>
</ul>
</li>
<li>鸟哥还是推荐尝试parted</li>
</ul>
<ul>
<li>删除分区<code>parted /dev/vda rm 号码（vda?）</code></li>
<li>文件系统损毁会导致报错：发现磁盘有问题，只需要重建文件系统即可</li>
</ul>
<h4 id="第八章-文件与文件系统的压缩、打包与备份"><a href="#第八章-文件与文件系统的压缩、打包与备份" class="headerlink" title="第八章 文件与文件系统的压缩、打包与备份"></a>第八章 文件与文件系统的压缩、打包与备份</h4><p>Linux常见压缩扩展名</p>
<ul>
<li>.z：compress压缩</li>
<li>.zip：zip压缩</li>
<li>.gz：gzip压缩</li>
<li>.bz2：bzip2压缩</li>
<li>.xz：xz压缩</li>
<li>.tar：tar打包数据，还没有压缩</li>
<li>.tar.gz：tar包经过gzip压缩</li>
<li>.tar.bz2    .tar.xz同理</li>
</ul>
<p><code>tar</code>可以将多个文件打包成一个文件，目录也可以打包，其他软件都只能压缩一个文件</p>
<p>GNU计划中，将整个tar与压缩的功能结合在了一起</p>
<p><code>gzip</code>：使用最广的压缩指令：可以解开compress，zip与gzip等软件所压缩的文件</p>
<p>用法：</p>
<ul>
<li><code>gzip [-cdtv#] filename</code></li>
<li>-c 将压缩的数据输出到屏幕上</li>
<li>-d 解压缩的参数</li>
<li>-t  可以用来检验一个压缩文件的一致性</li>
<li>-v  可以显示出源文件、压缩文件的压缩比等信息</li>
<li>-#  #用数字代替，-1最快，压缩比最低，-9最慢，压缩比最高，默认-6</li>
</ul>
<p><code>ls -Sld /etc</code>找出目录中最大的文件/目录</p>
<p>使用<code>zcat/zless/zmore</code>能像用<code>cat/less/more</code>一样去查看.gz压缩包的内容（牛皮！）</p>
<p>使用<code>&gt;</code>使原本要输出在屏幕上的文本存在&gt;后面的文件中</p>
<p><code>gzip -c -9 service &gt; service.gz</code>将service压缩并保留源文件</p>
<p><code>zgrep</code>用法相当于<code>grep</code></p>
<p><code>grep</code></p>
<ul>
<li>用法<code>grep [options] [pattern] filename</code></li>
<li>在文件中寻找[pattern]类似的部分并打印在屏幕上</li>
<li>[pattern]可以用正则表达式</li>
</ul>
<p>看到8.2.2 bzip and his family</p>
<p>Typora 统计词数18101词</p>
<hr>
<h3 id="2018-7-17"><a href="#2018-7-17" class="headerlink" title="2018-7-17"></a>2018-7-17</h3><ul>
<li>搬家后第一次来嘉定图书馆，环境真棒啊，激起了满满学习的激情！</li>
<li>今天从FHS开始</li>
<li><strong>目录配置</strong></li>
<li>第一部分：FHS要求必须存在的目录<ul>
<li>/bin ：放置在单人维护模式下还能够被操作的指令，可以被root与一般账号所使用，主要有：cat, chmod, chown, date, mv, mkdir, cp, bash等常用命令</li>
<li>/boot：主要放置开机使用的文件，包括Kernel和开机菜单及配置文件。Kernel常用的文件名是：vmlinuz，如果使用grub2开机，还会存在/boot/grub2</li>
<li>/dev：所有设备和周边设备都以文件的形态存储在这个目录，重要文件/dev/null，/dev/zero，/dev/tty，/dev/loop，/dev/sd等</li>
<li>/etc：系统主要的配置文件。如账号密码，一般用户也可以查阅，但是只有root用户才能更改。重要文件：/etc/passwd, /etc/fstab, /etc/issue等<ul>
<li>不建议二进制文件存储在此目录</li>
<li>/etc/opt：必须存在于etc目录下的子目录，放置第三方支持软件</li>
<li>/etc/X11：建议，与X Window有关的配置文件都在这里，尤其是xorg.conf</li>
<li>/etc/sgml：建议，与SGML格式有关的各项配置文件</li>
<li>/etc/xml：建议，与XML格式有关的各项配置文件</li>
</ul>
</li>
<li>/lib：开机时会使用到的函数库，以及/bin及/sbin下面指令会调用的函数库。<ul>
<li>/lib/modules/：必须，放置可改变的驱动程序</li>
</ul>
</li>
<li>/media：放置可移除的设备，包括光盘，DVD，软盘等，常见文件名：/meida/floppy, /media/cdrom</li>
<li>/mnt：暂时挂载某些额外设备，与/media用途相同</li>
<li>/opt：非原本distribution提供的额外软件，在以前的Linux系统中，习惯于放置在/usr/local目录下</li>
<li>/run：放置开机后所产生的各项信息，早期FHS规定放置于/var/run，新版规定为/run，性能有所提升</li>
<li>/sbin：许多用来设置系统环境的指令，只有root才能用来<strong>设置</strong>系统，而一般用户只能用来<strong>查询</strong>。此目录下为开机过程中所需要的，包括开机、修复、还原系统指令。<ul>
<li>某些服务器的软件程序，一般放置到/usr/sbin中</li>
<li>本机自行安装的软件所产生的可执行文件，一般放置到/usr/local/sbin当中。常见指令包括：fdisk, fsck, ifconfig, mkfs</li>
</ul>
</li>
<li>/srv：可以视为’service’的缩写，是一些网络服务启动后，这些服务所需要取用的数据目录。常见的WWW放置在/srv/www中。<ul>
<li>不过，系统不希望提供给网际网络任何人浏览的话，默认建议放置到/var/lib目录下</li>
</ul>
</li>
<li>/tmp：让一般使用者或是正在执行的程序暂时放置文件的地方。任何人都能存取这个目录，需要定期清理，<strong>重要数据不能放置在这里</strong>。<ul>
<li>FHS建议在开机时将/tmp下的数据全部删除</li>
</ul>
</li>
<li>/usr</li>
<li>/var：主要放置变动性数据</li>
</ul>
</li>
<li>第二部分：FHS建议可以存在的目录<ul>
<li>/home：使用者的主文件夹，新增账户时，默认主文件夹规范都会放置到这里，主文件夹还可以用波浪号<code>~</code>表示，可以使用<code>cd ~</code>进入主文件夹</li>
<li>lib\<qual>：用来存放与/lib不同格式的二进制函数库，如/lib64</qual></li>
<li>/root：系统管理员的主文件夹。</li>
</ul>
</li>
<li>其他FHS标准以外的重要目录<ul>
<li>/lost+found：使用ext2/ext3/ext4文件系统格式才会产生的目录，目的是文件系统发生错误时，将一些遗失的片段放置在这里。xfs文件系统不存在这个目录</li>
<li>/proc：虚拟文件系统，放置的数据都在内存当中，如系统核心、行程信息（process）、周边设备和网络状态等。该目录不占任何硬盘空间，因为文件都在内存当中<ul>
<li>重要文件：/proc/cpuinfo, /proc/dma, /proc/interrupts, /proc/ioports, /proc/net/*等</li>
</ul>
</li>
<li>/sys：与/proc类似，记录kernel与系统硬件信息较相关的信息。包括目前已载入的核心模块与核心侦测到的硬件设备信息。不占硬盘</li>
</ul>
</li>
<li>/usr的意义和内容：<ul>
<li>内部数据是可分享，不可改变的。可以分享给局域网内的其他主机</li>
<li>Unix Software Resource的缩写。FHS建议开发者把自己的数据放在这个目录的子目录。</li>
<li>所有系统默认软件都会放在此目录下</li>
<li>FHS要求必须存在的子目录<ul>
<li>/usr/bin：所有一般用户能够使用的指令。此目录下不应该有子目录。/bin链接到此目录</li>
<li>/usr/lib：与/lib相同，/lib链接到此目录</li>
<li>/usr/local：自行下载的软件建议安装到此目录，和/usr的目录结构完全一样</li>
<li>/usr/sbin：非系统正常运行所需要的系统指令。常见的是网络服务器软件的服务指令（daemon）</li>
<li>/usr/share：主要放置只读架构的数据文件。几乎都是文本本件。<ul>
<li>常见子目录：/usr/share/man：man的文档，/usr/share/doc：软件杂项的文件说明，/usr/share/zoneinfo：时区文件</li>
</ul>
</li>
</ul>
</li>
<li>FHS建议可以存在的目录<ul>
<li>/usr/games/：与游戏相关的数据</li>
<li>/usr/include/：c/c++等程序语言的头文件</li>
<li>/usr/libexec：某些不被一般使用者惯用的可执行文件或脚本。</li>
<li>/usr/lib\<qual>：与/lib\<qual>功能相同</qual></qual></li>
<li>/usr/src/：一般源代码建议放置在这里。kernel源代码建议放置在/usr/src/linux目录下</li>
</ul>
</li>
</ul>
</li>
<li>/var的意义和内容<ul>
<li>/var目录主要针对经常变动的文件，包括高速缓存cache，登陆文件log file，MySQL数据库文件等</li>
<li>常见子目录</li>
<li>FHS要求必须存在的目录<ul>
<li>/var/cache/：应用程序运行过程中会占用一些暂存盘</li>
<li>/var/lib/：程序执行的过程中，需要使用到的数据文件放置第目录。各自的软件应当有各自的目录</li>
<li>/var/lock/：某些设备或文件一次只能被一个应用程序所使用，否则可能出现错误。因此就要将此设备上锁（lock），以确保只会给单一软件使用。</li>
<li>/var/log/：非常重要，登录文件放置的目录，其中重要的信息包括/var/log/messages/, /var/log/wtmp等</li>
<li>/var/mail：记录电子邮件信箱的目录，也被放置到/var/spool/mail中，两者互为链接目录</li>
<li>/var/run：某些程序或服务启动后，会将他们的PID放置在这个目录下，和/run链接</li>
<li>/var/spool：放置队列中的数据，使用后通常被删除</li>
</ul>
</li>
</ul>
</li>
<li>完成基础篇的学习后，可以去看看FHS的官方英文文件</li>
<li>除了FHS中定义的最上层/和次层目录以外，其他次级目录内，开发者就可以自行配置了。</li>
<li>CentOS 7中把许多应该在根目录<code>/</code>中的目录移动到了/usr中去，然后以链接的方式在根目录展示<ul>
<li>包括/bin -&gt; /usr/bin</li>
<li>/sbin -&gt; /usr/sbin</li>
<li>/lib -&gt; /usr/lib</li>
<li>/lib64 -&gt; /usr/lib64</li>
<li>/var/lock -&gt; /run/lock</li>
<li>/var/run -&gt; /run</li>
</ul>
</li>
<li>目录树<ul>
<li>从根目录起始</li>
<li>每个目录除了本地partition，也可以使用网络file system。如Network File System（NFS）服务器挂载特定目录</li>
<li>每一个文件在整个目录数中的文件名都是独一无二的</li>
</ul>
</li>
<li>使用<code>ls -al</code>查询根目录结构</li>
</ul>
<p><img src="/images/Vbird/5-3.1.png" alt=""></p>
<ul>
<li>相对路径<ul>
<li>./ 代表当前目录</li>
<li>../ 代表上一级目录</li>
</ul>
</li>
<li>若可执行文件放在某目录，且本目录不是正规可以执行文件目录（/bin，/usr/bin）,此时执行文件就需要严格指定文件目录用 ./ 表示本目录，如<code>./run.sh</code></li>
<li>LSB：Linux Standard Base</li>
<li>可以使用<code>uname</code> <code>lsb_release</code>等指令查阅Kernel和LSB需求的几种重要标准</li>
<li><code>uname -r</code>查看核心版本</li>
<li><code>uname -m</code>查看操作系统的位数</li>
</ul>
<p><img src="/images/Vbird/5-3.2.png" alt=""></p>
<ul>
<li>在有网络可以使用的情况下</li>
<li><code>yum install redhat-lsb</code></li>
<li><code>lsb_release -a</code></li>
</ul>
<h4 id="第六章-Linux文件与目录管理"><a href="#第六章-Linux文件与目录管理" class="headerlink" title="第六章 Linux文件与目录管理"></a>第六章 Linux文件与目录管理</h4><ul>
<li><p>写shell script 时，务必使用绝对路径</p>
</li>
<li><p>目录的相关操作</p>
</li>
<li><p>特殊目录：</p>
<ul>
<li>. 此层目录</li>
<li>.. 上一层目录</li>
<li>- 前一个工作目录</li>
<li><code>~</code>目前账户所在主文件夹</li>
<li><code>~[account]</code>是[account]这个用户的主文件夹</li>
</ul>
</li>
<li><p>常见指令</p>
<ul>
<li><p><code>cd</code>变换目录</p>
</li>
<li><p><code>pwd</code>显示目前目录（print working dictionary）</p>
<ul>
<li>-P 显示出确实的路径，而非链接路径</li>
</ul>
<p><img src="/images/Vbird/6-1.1.png" alt=""></p>
</li>
<li><p><code>mkdir</code>创建一个新目录</p>
<p><img src="/images/Vbird/6-1.2.png" alt=""></p>
<ul>
<li>-m 设置创建目录权限，默认新建目录的权限可以看到是755，这个跟umask有关</li>
</ul>
<p><img src="/images/Vbird/6-1.4.png" alt=""></p>
<ul>
<li>-p 将输入的不存在的父级目录同时创建出来</li>
</ul>
<p><img src="/images/Vbird/6-1.3.png" alt=""></p>
</li>
<li><p><code>rmdir</code>删除一个空目录</p>
<ul>
<li>-p 删除输入的所有空目录</li>
</ul>
<p><img src="/images/Vbird/6-1.5.png" alt=""></p>
<ul>
<li>成功删除test1/test2/test3</li>
</ul>
<p><img src="/images/Vbird/6-1.6.png" alt=""></p>
<ul>
<li>我之前因为没有加-p 所以之删除了test3目录下的test4目录</li>
</ul>
</li>
<li><p>使用<code>rm -r [directory]</code>可以删除目录下的所有东西，不过比较危险，rm 也可以增加-p参数来删除上层的目录</p>
</li>
</ul>
</li>
<li><p>可以执行文件路径的变量：$PATH</p>
<ul>
<li>又称环境变量</li>
<li>系统会按照PATH的设置 在每个PATH定义的目录下搜寻输入的指令</li>
<li><code>echo $PATH</code>来看看有哪些目录被定义了（echo为显示指令）</li>
</ul>
<p><img src="/images/Vbird/6-1.7.png" alt=""></p>
<ul>
<li>PATH变量由目录组成，每个目录中间用<code>：</code>隔开</li>
<li><code>mv [file] [directory]</code>移动文件到另一个目录</li>
</ul>
<p><img src="/images/Vbird/6-1.8.png" alt=""></p>
<ul>
<li>直接输入<code>ls</code>无法执行命令，因为/root目录不再环境变量中，需要通过确定的路径来调用命令</li>
<li>输入<code>PATH=&quot;${PATH}:/root&quot;</code>把/root目录添加到环境变量，就又可以使用<code>ls</code>命令了</li>
</ul>
<p><img src="/images/Vbird/6-1.9.png" alt=""></p>
<ul>
<li>完成练习后把ls 搬回原位</li>
</ul>
<p><img src="/images/Vbird/6-1.10.png" alt=""></p>
<ul>
<li>发现还是不能使用<code>ls</code>命令，可能是指令参数被高速缓存的原因，只需要登出root再重新登录就可以再次使用<code>ls</code>了</li>
</ul>
</li>
<li><p>文件与目录的检视</p>
</li>
<li><p><code>ls</code>（黑体为常用）</p>
<ul>
<li><strong>-a 列出所有文件</strong></li>
<li>-A 列出除了. 和 .. 这两个文件以外的所有文件</li>
<li><strong>-d 目录中有文件时，仅列出目录本身，不列出目录中的文件</strong></li>
<li>-f 不进行排序</li>
<li>-F 给文件目录给予附加数据结构<ul>
<li>* 代表可执行文件</li>
<li>/ 代表目录</li>
<li>= 代表socket文件</li>
<li>&amp;#124；代表FIFO文件</li>
</ul>
</li>
<li>-h 将文件大小以带单位的形式列出来</li>
<li>-i 列出inode号码</li>
<li><strong>-l 列出详细信息，权限，owner，group，size等</strong></li>
<li>-n 列出UID与GID而非使用者与群组的名称</li>
<li>-r 将排序结果反向输出</li>
<li>-R 连同子目录一起列出，也就是说该目录下所有文件都会显示出来</li>
<li>-S 以文件大小排序</li>
<li>-t 以时间排序</li>
<li>–color=never  不要依据文件特性给予颜色显示</li>
<li>–color=always 显示颜色</li>
<li>–color=auto  让系统自行依据设置来判断是否给予颜色</li>
<li>–full-time  以完整时间模式输出</li>
<li>–time={atime，ctime} ：输出access时间或改变权限属性时间（ctime），而不是修改时间（modification time）</li>
</ul>
</li>
<li><p><code>cp [options] source destination</code>复制文件或目录</p>
<ul>
<li><strong>-a 相当于-dr –preserve-all</strong></li>
<li>-d 若来源文件为链接文件，则复制链接文件属性而不是文件本身</li>
<li>-f 强制，若文件已经存在且无法打开，则移除后再试一次</li>
<li><strong>-i 若目标文件已经存在，在覆盖时会先询问是否覆盖</strong></li>
<li>-l 进行硬式链接的链接文件创建，而非复制文件本身</li>
<li><strong>-p 连同文件属性一起复制，而非默认属性（备份用）</strong></li>
<li><strong>-r 用于目录复制，递回地复制目录</strong></li>
<li>-s 复制成为符号链接文件，即快捷方式</li>
<li>-u destination比source旧，才更新destination，不存在则复制</li>
<li>–preserve=all 除了 -p 的相关属性外，还加入了SELinux的属性，links，xattr等也复制了。</li>
</ul>
</li>
<li><p>如果来源文件有两个及以上，destination必须是目录才行</p>
</li>
<li><p>复制并更名<code>cp .bashrc /tmp/bashrc</code></p>
</li>
</ul>
<p><img src="/images/Vbird/6-2.1.png" alt=""></p>
<ul>
<li>加上 -i参数<code>cp -i .bashrc /tmp/bashrc</code></li>
</ul>
<p><img src="/images/Vbird/6-2.2.png" alt=""></p>
<ul>
<li><code>cp /var/log/wtmp .</code>使用 . 表示当前目录</li>
<li>查看权限情况<code>ls -l /var/log/wtmp wtmp</code></li>
</ul>
<p><img src="/images/Vbird/6-2.3.png" alt=""></p>
<ul>
<li>复制时加上选项 -a 把所以特性都复制过来</li>
</ul>
<p><img src="/images/Vbird/6-2.4.png" alt=""></p>
<ul>
<li>因为在复制的过程中，owner和权限都会改变，所以在复制密码文件和配置文件时就需要使用<code>cp -a</code>来完整复制文件权限</li>
<li>在复制目录时加上 -r 选项才能复制</li>
</ul>
<p><img src="/images/Vbird/6-2.5.png" alt=""></p>
<ul>
<li><p>使用<code>cp -l</code>创建一个硬式链接文件（涉及inode，在下一章讲）</p>
</li>
<li><p>使用<code>cp -s</code>创建一个快捷方式</p>
</li>
</ul>
<p><img src="/images/Vbird/6-2.6.png" alt=""></p>
<ul>
<li>使用<code>cp -u</code>当源比目标新时才复制（常用于备份）</li>
<li>使用<code>cp -d</code>复制快捷方式</li>
</ul>
<p><img src="/images/Vbird/6-2.7.png" alt=""></p>
<ul>
<li>复制多个文件到同一个目录<code>cp ~/.bashrc ~/.bash_history /tmp</code></li>
</ul>
<p><img src="/images/Vbird/6-2.8.png" alt=""></p>
<ul>
<li>使用一般用户复制<code>cp -a /var/log/wtmp /tmp/captainxu_wtmp</code></li>
</ul>
<p><img src="/images/Vbird/6-2.9.png" alt=""></p>
<ul>
<li>发现虽然能复制，但是文件的owner和group没有完全相同地移动过来，是因为一般用户不能随意地修改文件的拥有着和群组</li>
<li>在使用<code>cp</code>命令时，因为有文件类型和权限的特性，复制前必须了解<ul>
<li>是否需要完整的来源信息</li>
<li>来源文件是否为链接文件</li>
<li>来源文件是否为特殊文件：FIFO，socket等</li>
<li>来源文件是否为目录</li>
</ul>
</li>
</ul>
<ul>
<li><code>rm [options] 文件或目录</code>移除文件或目录<ul>
<li>-f 忽略不存在的文件，不会出现警告信息</li>
<li>-i 删除前会询问是否删除</li>
<li>-r 递回删除，删除目录中所有东西，非常危险的操作！</li>
</ul>
</li>
<li>使用<code>rm -i bashrc</code>删除刚才创建的文件bashrc</li>
<li>使用<code>rm -i bashrc*</code>删除所有以bashrc开头的文件</li>
</ul>
<p><img src="/images/Vbird/6-2.10.png" alt=""></p>
<ul>
<li>将刚才创建的/tmp/etc目录删除<code>rm -r /tmp/etc</code>，因为用户是root，所以默认加入了<code>-i</code>选项，需要不断按y来确认删除，<code>\rm -r /tmp/etc</code>，在指令前增加反斜线忽略指定选项</li>
</ul>
<p><img src="/images/Vbird/6-2.11.png" alt=""></p>
<ul>
<li>千万不要手残删掉了etc，系统会挂掉！</li>
<li>删除一个开头带<code>-</code>的文件<code>rm ./-sadwdaw</code> 或<code>rm -- -asdwadsda</code></li>
</ul>
<p><img src="/images/Vbird/6-2.12.png" alt=""></p>
<ul>
<li><code>mv [options] sources destination</code>移动文件与目录，或更名<ul>
<li>-f 强制，不询问</li>
<li>-i 已存在时，询问是否覆盖</li>
<li>-u update，目标已存在且source比较新时才会更新</li>
</ul>
</li>
<li>使用<code>mv mvtest mvtest2</code>来更名（还有一个叫做rename的更名指令，可以根据表达式来更名）</li>
</ul>
<p><img src="/images/Vbird/6-2.13.png" alt=""></p>
<ul>
<li>使用<code>mv bashrc1 bashrc2 mvtest2</code>同时把两个文件移动到目标目录</li>
</ul>
<p><img src="/images/Vbird/6-2.14.png" alt=""></p>
<ul>
<li>有多个源文件时，目标文件必须是目录</li>
<li>获取文件名<code>basename /etc/sysconfig/network</code></li>
<li>获取目录名<code>dirname /etc/sysconfig/network</code></li>
</ul>
<p><img src="/images/Vbird/6-2.15.png" alt=""></p>
<ul>
<li><p>文件内容查询</p>
<ul>
<li><p><code>cat</code> 从第一行开始显示文件内容</p>
<ul>
<li>-A 可列出一些特殊字符，而不是空白</li>
<li>-b 列出行号，空白行不标号</li>
<li>-E 将结尾的断行字符 $ 显示出来</li>
<li>-n 打印处行号，空白行也有行号</li>
<li>-T 将Tab键以 ^I 显示出来</li>
<li>-v 显示处一些看不出的字符</li>
</ul>
</li>
<li><p><code>tac</code>从最后一行显示文件内容</p>
</li>
<li><p><code>nl</code>  显示的时候，同时输出行号</p>
<ul>
<li><p>-b 指定行号标记的方式</p>
<ul>
<li>-b a 空行也标号</li>
<li>-b t 空行不标号（默认值）</li>
</ul>
</li>
<li><p>-n 行号的表示方法</p>
<ul>
<li>-w + 数字    设置补0后的位数，默认6位</li>
<li>-n ln 在屏幕左端显示</li>
<li>-n rn 在自己字段的左端显示且不添加0</li>
<li>-n rz 在自己字段的左端显示且添加0</li>
</ul>
<p><img src="/images/Vbird/6-2.16.png" alt=""></p>
</li>
</ul>
</li>
<li><p><code>more</code> 一页一页的显示文件内容</p>
<ul>
<li>输入  <code>/</code>搜索内容</li>
</ul>
</li>
<li><p><code>less</code> 与<code>more</code>相同，可以向前翻页</p>
<ul>
<li>输入<code>?</code>可以向前搜索</li>
<li>使用<code>pageup</code> <code>pagedown</code>向前后翻页</li>
<li>man 就是调用less来显示文档内容的</li>
</ul>
</li>
<li><p><code>head</code> 只看头几行</p>
<ul>
<li><code>head -n number</code>显示前面的number行，默认显示10行，number可以是负值，表示不显示后面的number行（包括第number行）</li>
</ul>
</li>
<li><p><code>tail</code>只看尾巴几行</p>
<ul>
<li><code>tail -n number</code>显示最后的number行，默认显示10行</li>
<li><code>tail -n +100</code>表示显示100以后的内容（包括第100行）</li>
<li>-f 持续侦测文件内容，按 ^C停止</li>
</ul>
</li>
<li><p><code>od</code> 以二进制的方式读取文件内容</p>
<ul>
<li><code>od -t Type</code></li>
<li>Type:<ul>
<li>a 利用默认的字符来输出</li>
<li>c 使用ASCII字符来输出</li>
<li>d[size] 使用10进制来输出，每个整数占size个字节</li>
<li>f[size] 使用浮点数输出</li>
<li>o[size] 使用八进制输出</li>
<li>x[size] 使用十六进制输出</li>
</ul>
</li>
<li>输出文件内容8进制存储和ASCII存储的对照表</li>
</ul>
<p><img src="/images/Vbird/6-2.18.png" alt=""></p>
<ul>
<li>利用<code>echo someword|od -t oCc</code>可以输出任意字符的ASCII对照表</li>
</ul>
</li>
</ul>
</li>
<li><p>管线符号：<code>|</code>，意思是，前面指令所输出的信息，交给后续指令继续使用</p>
</li>
<li><p>输出某一文件的第11到第20行，且带行号</p>
</li>
</ul>
<p><img src="/images/Vbird/6-2.17.png" alt=""></p>
<ul>
<li>修改文件时间和创建新文件：touch</li>
<li>Linux下文件有三个时间参数：mtime(modification time), ctime(status time), atime(access time)，分别表示：文件内容修改时间，文件状态（权限等）修改时间，文件调用时间</li>
<li><code>ls -l /etc/man_db.conf ;ls -l --time=atime /etc/man_db.conf ;ls -l --time=ctime /etc/man_db.conf</code>查看文件的时间</li>
<li>使用<code>touch -acdmt file</code> 来修改文件的时间<ul>
<li>-a 仅修改access time</li>
<li>-c 修改文件所有的时间，若文件不存在将不创建</li>
<li>-d 后面接欲修订的日期而不用当前日期，= <code>--date=</code></li>
<li>-m 仅修改mtime</li>
<li>-t 后面可以接欲修改的时间而不是当前时间，格式<code>YYYYMMDDhhmm</code></li>
</ul>
</li>
<li><code>touch -d &quot;2 days ago&quot; bashrc</code>将日期调整到两天前，但ctime不变</li>
</ul>
<ul>
<li>文件与目录的默认权限和隐藏权限</li>
<li>文件目录的隐藏属性，用<code>chattr</code>来设置，<code>lsattr</code>来查看</li>
<li>最重要的属性是设置文件不可修改的属性，即使文件所有者也不能修改</li>
<li>文件默认权限：<code>umask</code></li>
<li><code>umask -S</code>以符号表示显示默认权限设置</li>
<li><code>umask</code>以数字表示显示默认权限设置<ul>
<li>显示4位数字，第一位是隐藏权限，后三位是owner，group，others权限</li>
<li>创建文件时，默认是不具有执行权限，也就是-rw-rw-rw-</li>
<li>创建目录时，因为x权限十分重要，所以默认全部权限开启，也就是drwxrwxrwx</li>
<li>umask 显示的分数表示被拿走的权限的分数<ul>
<li>例如。umask 分数为0022，owner没有被拿走任何权限，group和others都被拿走了2分的权限，也就是—–w–w-，因此，新文件的权限默认为：-rw-r–r–，新目录的权限默认为：drwxr-xr-x</li>
</ul>
</li>
<li>设置<code>umask</code>，直接在后面输入数字即可，<code>umask 002</code>，输入三位时默认不含隐藏权限</li>
</ul>
</li>
<li><code>chattr [+-=][ASacdistu]</code> 设置文件的隐藏属性<ul>
<li>xfs文件系统仅支持AadiS五个属性</li>
<li>A：使有此属性的文件存取时间<code>atime</code>不会被修改</li>
<li>a：<strong>重要</strong>：有此属性的文件将只能增加数据，不能删除也不能修改数据，只有root可以设置此属性</li>
<li>d：dump程序被执行的时候，有此属性的文件不会吧dump备份</li>
<li>i：<strong>重要：</strong>使有此属性的文件<strong>不能被删除、改名、设置链接也无法写入或新增数据（root账户也不能操作）</strong>，也只有root可以设置</li>
<li>S：如果有此属性的文件被删除，他将被完全移出这个硬盘，无法恢复</li>
</ul>
</li>
<li><code>lsattr [-adR] file or directory</code>显示文件的隐藏属性<ul>
<li>-a：将隐藏文件的属性也显示出来</li>
<li>-d：如果后面连接的是目录，则列出目录本身的属性</li>
<li>-R：子目录的数据也列出来</li>
</ul>
</li>
<li><code>chattr</code>和<code>lsattr</code>的使用要千万小心，如果发现不能修改或不能增加某个文件时，可以用<code>lsattr</code>来查看</li>
<li>文件的特殊权限：SUID，SGID，SBIT</li>
<li>Set UID<ul>
<li>当s标志出现在owner的x权限上时，被称为<code>Set UID</code>，简称SUID<ul>
<li>SUID仅对二进制程序有效</li>
<li>执行者对于该程序需要有x权限</li>
<li>本权限仅在执行该程序的过程中有效（run-time）</li>
<li>执行者将具有该程序的owner权限</li>
</ul>
</li>
</ul>
</li>
<li>/etc/shadow 中存储了用户名和密码，权限是———- owner是root，只有root可以读取和修改</li>
<li>普通用户为什么能够通过调用程序passwd修改自己的密码？</li>
</ul>
<p><img src="/images/Vbird/6-4.1.png" alt=""></p>
<ul>
<li>可以看到/usr/bin/passwd拥有SUID，所以在调用passwd时，普通用户就临时拥有了root权限</li>
<li>Set GID</li>
<li>当s标志出现在group的x权限上时，称为<code>Set GID</code>简称<code>SGID</code>。<ul>
<li>SGID对二进制程序有用</li>
<li>程序执行者需具备x权限</li>
<li>执行者在执行过程中得到group的支持</li>
</ul>
</li>
</ul>
<p><img src="/images/Vbird/6-4.2.png" alt=""></p>
<p><img src="/images/Vbird/6-4.3.png" alt=""></p>
<ul>
<li>SGID设置在目录上时：<ul>
<li>使用者对于此目录具有rx权限时，可以进入此目录</li>
<li>使用者在此目录下的有效群组（effective group）将变成该目录的群组</li>
<li>用途：若使用者在该目录下有<strong>w</strong>权限，则使用者在此目录下<strong>创建</strong>的新文件<strong>群组</strong>与此目录相同</li>
</ul>
</li>
<li>Sticky BIT</li>
<li>SBIT目前只对目录有效<ul>
<li>当使用者对此目录具有w，x权限时</li>
<li>该使用者在此目录中创建的文件或目录，仅自己和root有权力删除文件</li>
</ul>
</li>
<li>作用：使一个目录中的文件只有他们各自的创建者才有权移动、改名和删除。</li>
<li>/tmp目录就有这样的权限</li>
</ul>
<p><img src="/images/Vbird/6-4.4.png" alt=""></p>
<ul>
<li>设置文件/目录具有SUID/SGID/SBIT权限<ul>
<li>SUID = 4</li>
<li>SGID = 2</li>
<li>SBIT = 1</li>
</ul>
</li>
<li>用<code>chmod</code>更改权限时，在原先 的三位数字前再加一位就是这三种新的权限啦</li>
<li><code>chmod 4755 filename</code> = <code>-rwsr-xr-x</code> SUID</li>
<li><code>chmod 6755 filename</code> = <code>-rwsr-sr-x</code> SUID &amp; SGID</li>
<li><code>chmod 1755 filename</code> = <code>-rwxr-xr-t</code> SBIT</li>
<li><code>chmod 7666 filename</code> = <code>-rwSrwSrwT</code> 空的SUID和SGID权限</li>
<li>大写的S T标志代表owner group others 都没有x权限</li>
<li>符号法也可以处理：SUID=u+s，SGID=g+s，SBIT=o+t</li>
<li><code>chmod u=rwxs,go=x test</code> = <code>-rws--x--x</code></li>
<li>在上一指令的基础上<code>chmod g+s,o+t test</code> = <code>-rws--s--t</code></li>
<li>观察文件类型：<strong>file</strong></li>
<li><code>file filename</code></li>
<li>看到6.5 指令与文件的搜寻</li>
<li>typora记录词数11901词</li>
</ul>
<hr>
<h3 id="2018-7-16"><a href="#2018-7-16" class="headerlink" title="2018-7-16"></a>2018-7-16</h3><ul>
<li>文件权限的含义<ul>
<li>r（read）：可以读取此文件的内容</li>
<li>w（write）：可以编辑（新增或修改）此文件的内容（<strong>不能删除</strong>）</li>
<li>x（execute）：该文件有被系统执行的权限</li>
</ul>
</li>
<li>Windows中可执行文件是由扩展名exe来判断的，但是Linux中可执行文件与文件名是没有关系的，是由文件是否具有x权限来决定的</li>
<li>目录权限的含义<ul>
<li>目录的主要内容是记录文件名清单</li>
<li>r（read contents in directory）：表示具有读取目录结构清单的权限，可以查询该目录下文件名数据，拥有此权限才能使用Tab进行文件名补齐</li>
<li>w（modify contents of directory）：表示有目录修改权限1、创建新的文件与目录；2、删除已存在的文件与目录；3、将已存在的文件或目录更名；4、移动该目录内的文件、目录位置</li>
<li>x（access directory）：表示是否能进入该目录（<code>cd</code>），即：将此目录作为工作目录</li>
</ul>
</li>
<li>拥有目录w权限，但没有文件权限时，是可以删除该文件的，就像盒子打不开不妨碍你把他扔进垃圾桶</li>
</ul>
<p><img src="/images/Vbird/5-2.1.png" alt=""></p>
<ul>
<li><p>练习：</p>
<ul>
<li>切换到root账户<code>su -</code></li>
<li>进入tmp目录<code>cd /tmp</code></li>
<li>创建目录testing<code>mkdir testing</code></li>
<li>修改目录权限为744<code>chmod 744 testing</code></li>
<li>在testing目录中创建文件testing<code>touch testing/testing</code></li>
<li>修改文件权限为600<code>chmod 600 testing/testing</code></li>
<li>ls查询目录结构和权限<code>ls -ald testing testing/testing</code></li>
<li>使用另一个用户登录，查询目录结构</li>
</ul>
<p><img src="/images/Vbird/5-2.2.png" alt=""></p>
</li>
<li><p>可见，只有目录r权限是可以读取文件名的，但是不能读取文件详细信息</p>
<ul>
<li>使用root更改目录的owner使用户可以进入<code>chown captainxu testing</code></li>
</ul>
<p><img src="/images/Vbird/5-2.3.png" alt=""></p>
<ul>
<li>尝试删除文件<code>rm testing</code></li>
</ul>
<p><img src="/images/Vbird/5-2.4.png" alt=""></p>
<ul>
<li>成功删除</li>
</ul>
</li>
<li><p>Linux文件类型</p>
<ul>
<li>正规文件（-）<ul>
<li>纯文本文件（ASCII）：最多的文件类型，是人类可以直接读取的数据，如文字数字等，包括配置文件，可以使用<code>cat</code>读取</li>
<li>二进制文件（binary）：可执行文件（scripts），可以运行</li>
<li>数据格式文件（data）：某些特定格式的文件，可以使用<code>last</code>读取</li>
</ul>
</li>
<li>目录（d）</li>
<li>链接文件（L）：类似于Windows快捷方式</li>
<li>设备与设备文件（）：通常都集中在/dev中<ul>
<li>区块设备文件（b）lock：存储数据的设备，如硬盘</li>
<li>字符设备文件（c）haracter：一次性读取，不能截断输出的设备，如键盘，鼠标</li>
</ul>
</li>
<li>数据接口文件（s）ockets：通常用于网络连接，启动一个程序来监听用户的要求，用户端就可以使用这个socket进行数据沟通，通常在/run /tmp这些目录中</li>
<li>数据传送档（FIFO，(p)ipe）：FIFO是一种特殊的文件类型，first in first out（队列），用于解决多个程序同时存取一个文件所造成的错误问题</li>
</ul>
</li>
<li><p>Linux文件扩展名：</p>
<ul>
<li>Linux文件通常没有扩展名</li>
<li>文件能否执行看的是是否具有x权限，但是一个文件有能够执行的权限不代表它可以执行成功，因为只有有能够执行的数据的文件才可以执行成功</li>
<li>但是扩展名也可以帮助我们了解该文件是什么东西，通常还是会有适当的扩展名表示文件的种类<ul>
<li>*.sh：脚本或批处理文件（scripts），批处理文件用shell写成。简写为sh</li>
<li>Z, .tar, .tar.gz, .zip, *.tgz：压缩文件，压缩软件分别为gunzip, tar等，不同的软件有不同的扩展名</li>
<li>.html, .php：网页文件，可以在用户端浏览器浏览</li>
</ul>
</li>
<li>Linux的扩展名只起到提示文件可能的用途的作用，是否能够执行还是需要查看是否有相关的权限</li>
</ul>
</li>
<li><p>Linux文件长度限制</p>
<ul>
<li>单一文件或目录的最大允许文件名为255字节，即255ASCII英文字符，128中文字符</li>
</ul>
</li>
<li><p>Linux文件名称的限制</p>
<ul>
<li>设置文件名时最好避免特殊字符：<code>·?&lt;&gt;;$&amp;![]|\&#39;&quot;&quot;(){}</code></li>
<li>文件名开头为<code>.</code>代表该文件是隐藏文件</li>
</ul>
</li>
<li><p>睡前再看看鸟哥助眠~</p>
</li>
<li><p>Linux目录配置</p>
</li>
<li><p>目录配置的依据：FHS（Filesystem Hierarchy Standard）</p>
<ul>
<li>主要目的是希望使用者了解已安装的文件通常放在哪个目录下</li>
<li>这样就使Linux在<strong>既有的面貌</strong>（目录结构不变）下发展出开发者想要的风格</li>
<li>FHS的文件定义方法<ul>
<li>不变的（不会经常变动的，函数库、文件说明文档等）<ul>
<li>可分享的<ul>
<li>/usr 软件放置处</li>
<li>/opt 第三方协力软件</li>
</ul>
</li>
<li>不可分享的<ul>
<li>/etc 配置文件</li>
<li>/boot 开机和核心档</li>
</ul>
</li>
</ul>
</li>
<li>可变的（经常改变的数据，登录文件、一般用户可自行收受的新闻群组等）<ul>
<li>可分享的（能够分享给网络上其他主机挂载的目录）<ul>
<li>/var/mail 使用者邮件信箱</li>
<li>/var/spool/news 新闻群组</li>
</ul>
</li>
<li>不可分享的（仅与自身机器有关）<ul>
<li>/var/run 程序相关</li>
<li>/var/lock 程序相关</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>FHS根据目录树架构仅定义了以下三层目录<ul>
<li>/ 与开机系统有关</li>
<li>/usr （unix software resource）与软件安装/执行有关</li>
<li>/var 与系统运行过程有关</li>
</ul>
</li>
</ul>
</li>
<li><p>根目录的重要地位</p>
<ul>
<li>是所有目录的基础</li>
<li>与开机/还原/系统修复有关</li>
<li>所以根目录所在分区越小越好，且应用程序最好不要和根目录放在同一分区</li>
</ul>
</li>
<li><p>看到281页。FHS</p>
</li>
<li><p>Typora记录词数：6170词</p>
</li>
</ul>
<hr>
<h3 id="2018-7-15"><a href="#2018-7-15" class="headerlink" title="2018-7-15"></a>2018-7-15</h3><ul>
<li>嘉定的第二个晚上，居然失眠了，我也会不习惯新的床吗？</li>
<li>进行Linux学习机的安装，版本CentOS-7-x86_64-Everything-1804</li>
<li>MSI GP62不支持安装Linux（Linux对笔记本的支持<a href="http://www.linux-laptop.net/" target="_blank" rel="noopener">http://www.linux-laptop.net/</a> ）</li>
<li>使用VMware Workstation 14创建虚拟机，选择custom选项<ul>
<li>处理器数量：1</li>
<li>处理器内核数量：2</li>
<li>虚拟机内存：1200MB</li>
<li>使用桥接网络</li>
<li>IO控制器、虚拟磁盘类型：默认选项</li>
<li>最大磁盘大小：40GB</li>
<li>生成MAC地址</li>
</ul>
</li>
<li>打开虚拟机后将光标放置在Install CentOS 7 上，按下Tab键，输入下方参数，以进行GPT相关的练习</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vmlinuz initrd=initrd.img inst.stage2=hd:LABEL=CentOS\x207\x20x86_64 rd.live.check quiet inst.gpt </span><br><span class="line">笔记本安装还要添加：nofb apm=off acpi=off pci=noacpi</span><br></pre></td></tr></table></figure>
<ul>
<li>键盘菜单中设置切换热键</li>
<li>软件选择中选择：GUI服务器</li>
<li>安装位置：勾选“我要配置分区”</li>
<li>添加挂载点<ul>
<li>单击+，在下拉菜单中选择标准分区，选择BIOS boot，容量输入2M</li>
<li>/boot 1G</li>
<li>/          10G<ul>
<li>/、/home、swap希望使用LVM管理方式，新增后在详细设置中更改</li>
<li>/ 在详细设置中的Volume Group中选择修改</li>
<li>大小策略改为固定大小 30G</li>
</ul>
</li>
<li>/home 5G</li>
<li>swap    1G</li>
<li>点击完成后注意会显示<code>创建格式 分区表（GPT）</code>，点击接受更改</li>
</ul>
</li>
<li>LVM：可弹性增减的文件系统容量的设备设置</li>
<li>网络和主机，选择网络，点击右上角按钮，变为蓝色<code>开</code>状态，点击右下角的配置</li>
<li>在配置中<ul>
<li>常规，点选<code>可用时自动连接到这个网络</code></li>
<li>IPV4设置：改为手动，设置一个局域网IP地址</li>
</ul>
</li>
<li>修改主机名称：VbirdLinux-2018-7</li>
<li>完成网络配置</li>
<li>开始安装！</li>
<li>在安装的过程中设置root密码，并创建一个用户（勾选管理员选项）</li>
<li>安装完成后接受协议书，完成</li>
<li>/root/anaconda-ks.cfg 中记录了之前所选的全部项目</li>
<li>输入locale或echo $LANG查看终端机支持的语系数据</li>
<li>3.3.1记录了安装 CentOS 7.x + Windows 7 规划</li>
</ul>
<h4 id="第四章-首次登录与线上求助"><a href="#第四章-首次登录与线上求助" class="headerlink" title="第四章 首次登录与线上求助"></a>第四章 首次登录与线上求助</h4><ul>
<li>以小数点开头的文件在Linux中为隐藏文件</li>
<li>tty1 - tty6 是用户可用的留个终端编号</li>
<li>通过 ctrl + alt + F1-F6切换终端</li>
<li>输入xstart进入GUI</li>
<li>命令行中：命令太长时可以使用反斜杠换行</li>
<li>一般账号是以$为提示输入字符</li>
<li>root账号以#为提示输入字符</li>
<li>基础指令<ul>
<li><code>date</code>显示时间和日期</li>
<li><code>cal</code>显示日历，<code>cal [month] [year]</code></li>
<li><code>bc</code>计算器<ul>
<li>默认输出整数，要输入小数，使用<code>scale=number</code>指定小数位数</li>
</ul>
</li>
<li>在指令、文件名、参数后按两次Tab键，可以显示所有以已输入的字符开头的指令、文件、参数</li>
<li>CTRL + C 终止当前命令</li>
<li>CTRL + D 离开命令行 = exit</li>
<li>shift + PageUp/PageDown 终端翻页</li>
<li><code>--help</code>选项可以查看简易帮助</li>
</ul>
</li>
<li><strong>man page</strong><ul>
<li><code>man</code>+指令查看操作手册，按q退出<ul>
<li>输入<code>/</code>+关键字在man Page 中向下搜索</li>
<li>输入<code>?</code>+关键字在man page 中向上搜索</li>
<li>搜素后按<code>n</code>向下查询，<code>N</code>向上查询</li>
<li>指令名括号中数字的含义<code>man man</code><ul>
<li>1：在shell环境中可以操作的指令或可执行文件 重要</li>
<li>2：系统核心可调用的函数与工具</li>
<li>3：常用函数与函数库</li>
<li>4：设备文件的说明，通常为/dev下的文件</li>
<li>5：配置文件或某些文件的格式 重要</li>
<li>6：游戏</li>
<li>7：惯例与协定等，例如文件系统，网络协定，ASCII码等</li>
<li>8：管理员可用的管理指令 重要</li>
<li>9：kernel有关的文件</li>
</ul>
</li>
<li><code>man</code>的数据位于 /usr/share/man中，可以通过修改/etc/man_db.conf修改man page 的搜索路径</li>
<li><code>man</code>的选项 <code>-f</code>显示和后面参数相关的文件或指令 = <code>whatis</code></li>
<li><code>man 7 man</code>显示man的说明文档</li>
<li><code>man -k man</code>=<code>apropos man</code>在系统说明文档中，只要存在<code>-k</code>后面关键字的，就列出</li>
<li>使用<code>whatis</code>需要建立<code>whatis</code>数据库，使用<code>sudo mandb</code>或<code>sudo makewhatis</code>建立</li>
</ul>
</li>
</ul>
</li>
<li><strong>Info Page</strong><ul>
<li>将说明文档拆成一个个段落，用分开的页面来写，每个页面称为一个节点（node），是Linux额外提供的求助方法（man来自Unix）</li>
<li>使用方法<ul>
<li><code>info info</code>查看info的说明</li>
<li>按N进入下一个节点</li>
<li>按P进入上一个节点</li>
<li>按U进入上一层节点</li>
<li>按e把光标移到当前页面底端</li>
<li>按b把光标移到当前页面顶端</li>
<li>按s或/可以在info page中搜索</li>
<li>按下h可以进入按键功能提示</li>
<li>按Tab键可以快速光标到页面内标注的节点（有*的文字前）</li>
<li>在Menu中，把光标移动到前面带有<code>*</code>的部分，按Enter键，可以快速移动到那一节点</li>
</ul>
</li>
<li>info page的数据存储在/usr/share/info中</li>
</ul>
</li>
<li><strong>说明文档（documents）</strong><ul>
<li>位置：/usr/share/doc/</li>
</ul>
</li>
<li><p>帮助的使用</p>
<ul>
<li>知道了指令，不知道参数或者选项，使用<code>--help</code>来查询参数</li>
<li>有不知道的指令或者文件格式，用<code>man 或者 info</code>来查询</li>
<li>想使用一整组软件来达成功能时，可以看一看有没有相关的documents</li>
</ul>
</li>
<li><p>文本编辑器：nano</p>
<ul>
<li>[ctrl]-G：取得线上说明（help）</li>
<li>[ctrl]-X：离开naon软件，若有修改过文件会提示是否需要储存 </li>
<li>[ctrl]-O：储存盘案，若你有权限的话就能够储存盘案了</li>
<li>[ctrl]-R：从其他文件读入数据，可以将某个文件的内容贴在本文件中</li>
<li>[ctrl]-W：搜寻字串，这个也是很有帮助的指令喔！</li>
<li>[ctrl]-C：说明目前光标所在处的行数与列数等信息</li>
<li>[ctrl]-_：可以直接输入行号，让光标快速移动到该行</li>
<li>[alt]-Y：校正语法功能打开或关闭（按一下开、再按一下关）</li>
<li>[alt]-M：可以支持鼠标来移动光标的功能</li>
</ul>
</li>
<li>^G = CTRL + G, M - G = ALT + G</li>
<li><p>关机</p>
<ul>
<li>关机前：<ul>
<li>下达<code>who</code>命令，可以查看已登录的用户</li>
<li>下达<code>netstat -a</code>，查看网络的连线状态</li>
<li>下达<code>ps -aux</code>,查看主机当前的使用状态</li>
</ul>
</li>
<li>将内存中的数据同步写入硬盘：<code>sync</code><ul>
<li>防止不正常关机丢失数据</li>
</ul>
</li>
<li>关机指令：<code>shutdown</code><ul>
<li>参数</li>
<li>-k 不关机，只发送警告信息</li>
<li>-r 将系统的服务停止后就重启（常用）</li>
<li>-h 将系统服务停止后关机（常用）</li>
<li>-c 取消已经下达的shutdown命令</li>
</ul>
</li>
<li>重启，关机：<code>reboot、halt、poweroff</code></li>
<li>使用管理工具systemctl关机<ul>
<li>使用init命令可以切换不同的执行等级（0~6）</li>
<li>CentOS7可以使用<code>init 0</code>来关机</li>
<li>其实使用halt、poweroff、reboot、shutdown都是在调用systemctl指令</li>
</ul>
</li>
</ul>
</li>
<li>反斜杠<code>\</code>的英文是“escape”</li>
</ul>
<h4 id="第五章-Linux的文件权限与目录配置"><a href="#第五章-Linux的文件权限与目录配置" class="headerlink" title="第五章 Linux的文件权限与目录配置"></a>第五章 Linux的文件权限与目录配置</h4><ul>
<li>Linux文件管理权限<ul>
<li>文件可存取身份分为三个类别<code>owners/group/others</code></li>
<li>三种身份都有<code>read/write/execute</code>三种权限</li>
</ul>
</li>
<li>输入命令<code>ls -al</code>，显示出当前目录所有文件<ul>
<li>第一部分为文件类型和权限<ul>
<li>第一个字符代表文件类型<ul>
<li>d 代表目录</li>
<li>- 代表文件</li>
<li>L 代表链接文件</li>
<li>b 代表设备文件里可供存储的周边设备（可随机存取设备）</li>
<li>c 代表设备文件里序列设备，例如：键盘、鼠标</li>
</ul>
</li>
<li>接下来的九个字符三个一组，均为rwx的组合<ul>
<li>r 代表可读</li>
<li>w 代表可写</li>
<li>x 代表可执行</li>
<li>上述三个权限如果显示 - 则代表没有这个权限</li>
<li>三组中，第一组为owner的权限，第二组为group中用户的权限，第三组为other的权限</li>
</ul>
</li>
</ul>
</li>
<li>第二部分表示有多少文件名链接到此节点<ul>
<li>每个文件会把权限与属性记录到文件系统i-node中</li>
<li>此数字表示有多少不同的文件名链接到同一个i-node</li>
</ul>
</li>
<li>第三部分表示这个文件的拥有者 owner</li>
<li>第四部分表示这个文件所属群组 group</li>
<li>第五部分表示这个文件的容量大小，默认单位为字节</li>
<li>第六部分表示文件创捷日期或最后修改日期<ul>
<li>使用<code>ls -l --full-time</code>可以显示完整的时间</li>
</ul>
</li>
<li>第七部分表示文件名<ul>
<li>如果是隐藏文件，文件名会以<code>.</code>开头，使用<code>ls -a</code>显示隐藏文件</li>
</ul>
</li>
</ul>
</li>
<li>文件权限的重要性：主要是安全需要</li>
<li>如何改变文件属性与权限：<ul>
<li>chgrp：改变文件所属群组<ul>
<li>使用方法：<code>chgrp [options] dirname filename</code><ul>
<li>dirname：表示群组名</li>
<li>filename：表示文件名</li>
</ul>
</li>
<li>-R：进行递回（recursive）的持续变更，表示连同此目录下的所有文件、目录都更新成为这个群组</li>
</ul>
</li>
<li>chown：改变文件拥有者<ul>
<li>使用方法：<code>chown [options] username filename</code><ul>
<li>username表示要改为的用户名</li>
</ul>
</li>
<li>存在的账号才能更改，账号记录文件：/etc/passwd</li>
<li>-R：对目录下所有文件使用</li>
<li>chown可以同时改变用户和群组<code>chown [options] user.group filename</code></li>
<li>chown也可以只改变群组<code>chown [options] .group filename</code></li>
</ul>
</li>
<li>chgrp, chown的作用<ul>
<li>在使用<code>cp 源文件 目标文件</code>给别的用户复制文件时，也会复制执行者的属性和权限</li>
<li>此时别的用户可能无法使用你的权限文件</li>
<li>因此需要改变文件的owner和group</li>
</ul>
</li>
<li>chmod：改变文件的权限，SUID，SGID，SBIT等</li>
<li>数字类型改变权限<ul>
<li>九个权限，三个一组</li>
<li>r = 4, w = 2, x = 1, - = 0</li>
<li>相加某一族的三个权限数值，得到一个数字，用来代表这一身份的权限</li>
<li>例：<code>-rwxr-x---</code>的权限数字就是4+2+1, 4+0+1, 0+0+0：<code>750</code></li>
<li>使用方法：<code>chmod [options] 权限数字 filename</code></li>
<li>也有-R选项</li>
</ul>
</li>
<li>符号类型改变权限<ul>
<li>(u)ser=rwx, (g)roup=rwx,(o)ther=rwx, (a)ll</li>
<li>使用方法：<code>chmod u=rwx,go=rx filename</code></li>
<li>如果不知道原先的文件权限情况，只想给某个文件增加一种权限或减少一种权限，可以使用<code>chmod a(ugo)+w(-w(rx)) filename</code></li>
</ul>
</li>
</ul>
</li>
<li>看到5.2.3 目录与文件权限的意义</li>
<li>Typora记录词数：4726词</li>
</ul>
<hr>
<h3 id="2018-7-14"><a href="#2018-7-14" class="headerlink" title="2018-7-14"></a>2018-7-14</h3><ul>
<li>各硬件设备在Linux中的文件名<ul>
<li>SATA硬盘、U盘（SCSI模块驱动） /dev/sd[a-p]</li>
<li>打印机 /dev/lp[0-2]</li>
<li>鼠标 /dev/input/mouse[0-15] /dev/psaux /dev/mouse(当前鼠标)</li>
<li>CDROM /dev/scd[0-1]</li>
</ul>
</li>
<li>磁盘分区<ul>
<li>MSDOS (MBR 446B)：<ul>
<li>主要开机记录区：安装开机管理程序</li>
<li>分区表：记录硬盘分区状态</li>
<li>分区后的文件名：/dev/sda1 - /dev/sda4</li>
<li>延伸分区（Extended）只有一个，持续切割处逻辑分区（Logical）</li>
<li>逻辑分区的文件名：/dev/sda5 - /dev/sda?</li>
<li>能够被格式化后存储数据的分区为主要分区（Primary）和逻辑分区</li>
<li>逻辑分区的数量依据操作系统而不同</li>
</ul>
</li>
<li>GUID partition table, GPT磁盘分区表<ul>
<li>用逻辑区块位址（LBA）处理扇区的划分（默认大小512B），从LBA0开始标号</li>
<li>使用34个LBA区块来记录分区信息，用磁盘最后33个LBA区块来备份</li>
<li>LBA0（MBR相容模块）<ul>
<li>储存开机管理程序</li>
<li>存储代表GPT磁盘的标志</li>
</ul>
</li>
<li>LBA1，GPT表头记录<ul>
<li>记录分区表的位置与大小</li>
<li>记录备份用的GPT分区（最后34个LBA）</li>
<li>记录了分区表的检验机制码（CRC32），操作系统通过这个检验码来判断GPT是否正确，若不正确，则读取备份区的GPT，来恢复GPT的正常运行</li>
</ul>
</li>
<li>LBA2 - LBA33，记录实际分区信息<ul>
<li>每个LBA记录4笔分区记录</li>
<li>每笔记录用到128B空间，其中64B用来记载开始/结束的扇区号码</li>
<li>单一分区最大容量限制为8ZB</li>
<li>不再有主、延伸、逻辑分区概念，每笔记录都可以格式化使用</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>开机检测程序：BIOS, UEFI<ul>
<li>CMOS：存储器，记录各项硬件参数</li>
<li>BIOS：写入主板的固件（写入硬件的程序称固件）</li>
<li>BIOS + MBR/GPT 开机流程<ul>
<li>开机</li>
<li>计算机系统执行BIOS</li>
<li>BIOS分析计算机中有哪些存储设备</li>
<li>BIOS根据使用者的设置取得能够开机的硬盘</li>
<li>在该硬盘读取第一个扇区的MBR位置</li>
<li>运行MBR中的开机管理程序（boot loader, 由操作系统提供）<ul>
<li>如果是GPT，会读取LBA0中的boot loader</li>
</ul>
</li>
<li>BIOS任务完成！</li>
</ul>
</li>
<li>用grub等开机管理程序，需要另外分出BIOS boot分区，CentOS中通常占用2MB</li>
<li>每个分区都有自己的开机扇区（boot sector）</li>
<li>双系统开机总结：<ul>
<li>每个分区都有自己的开机扇区</li>
<li>实际可开机的核心文件分置与各个分区</li>
<li>loader只能识别系统盘内的可开机核心文件和其他loader</li>
<li>loader可以直接指向或间接将管理权交给另一个开机管理程序</li>
<li>Linux安装时可以设置把开机管理程序安装在MBR或者别的开机扇区</li>
<li>Windows安装时会主动覆盖MBR</li>
</ul>
</li>
<li>UEFI（UEFI BIOS）：使用C编写<ul>
<li>比BIOS效率稍低</li>
<li>类似于简易的操作系统</li>
<li>有安全启动功能，会检查操作系统</li>
</ul>
</li>
</ul>
</li>
<li>Linux安装模式下，磁盘分区的选择<ul>
<li>目录树结构<ul>
<li>根目录：“/”</li>
<li>结合目录树与磁盘内数据的方式：挂载（mount）</li>
</ul>
</li>
<li>挂载<ul>
<li>定义：利用一个目录作为进入点，将磁盘分区的数据放于该目录下<ul>
<li>即进入该目录就可以读取分区</li>
</ul>
</li>
<li>根目录一定需要挂载到某个分区，其他目录可以根据需要挂载到不同分区</li>
<li>Linux光驱挂载目录：/media/cdrom</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="第三章-安装CentOS-7-x"><a href="#第三章-安装CentOS-7-x" class="headerlink" title="第三章 安装CentOS 7.x"></a>第三章 安装CentOS 7.x</h4><ul>
<li>安装规划<ul>
<li>使用CentOS-7.1.1503来安装</li>
<li>服务器常用服务<ul>
<li>NAT：IP分享器，可以加装分析软件，分析用户端的连线或者控制带宽和流量</li>
<li>SAMBA：Windows系统文件分享服务，没有用户连接数的限制，适合作为文件服务器</li>
<li>MAIL：邮件服务器，具有商业机密或隐私性的邮件需要用Mail Server</li>
<li>Web：www服务器，CentOS使用Apache达成WWW服务器功能</li>
<li>DHCP：用户端自动取得IP的功能</li>
<li>FTP：需要硬盘和网卡较好</li>
</ul>
</li>
<li>硬盘规划<ul>
<li>分区<ul>
<li>/boot</li>
<li>/</li>
<li>/home</li>
<li>/var</li>
<li>Swap</li>
<li>/usr  2-5GB</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>练习机的规划<ul>
<li>虚拟机硬件配备<ul>
<li>CPU：i7 7700HQ</li>
<li>内存：1.2GB左右</li>
<li>硬盘：40GB的 Virtl/O 芯片组的硬盘</li>
<li>网卡：桥接模式</li>
<li>显卡：intel HD Graphics 630</li>
</ul>
</li>
<li>2TB以上Linux会默认以GPT管理，以下会以MBR模式处理，所以在安装时添加参数，使系统用GPT分区表来配置磁盘</li>
<li>CentOS 默认使用LVM的方式来管理文件系统</li>
<li>boot loader：CentOS 7.x 默认使用grub2来管理</li>
<li>软件模式：使用含有X接口的服务器软件来安装</li>
</ul>
</li>
<li>看到3.2 开始安装CentOS 7</li>
</ul>
<hr>
<h3 id="2018-7-13"><a href="#2018-7-13" class="headerlink" title="2018-7-13"></a>2018-7-13</h3><ul>
<li>结果下一次直到搬来了嘉定才重新开始，好好利用这个暑假吧！</li>
<li>操作系统<ul>
<li>前置技能：汇编语言</li>
<li>System Call : 操作系统提供的接口</li>
<li>核心功能<ul>
<li>系统调用接口</li>
<li>程序管理</li>
<li>内存管理</li>
<li>文件管理系统</li>
<li>硬件驱动</li>
</ul>
</li>
</ul>
</li>
<li>应用程序</li>
<li>软件移植：将操作系统修改以在其他架构的CPU上面运行</li>
</ul>
<h4 id="第一章-Linux是什么与如何学习"><a href="#第一章-Linux是什么与如何学习" class="headerlink" title="第一章 Linux是什么与如何学习"></a>第一章 Linux是什么与如何学习</h4><ul>
<li><p>Linux是基于x86 CPU开发的，可以在所以x86计算机上运行，稳定而功能强大</p>
</li>
<li><p>相容分时系统，让大型主机提供数个终端机以连线进入主机，使用主机的资源进行工作</p>
</li>
<li><p>Unix文件系统的两个重要概念</p>
<ul>
<li>所有的程序或系统设备都是文件</li>
<li>不管建构编辑器还是附属文件，所写的程序只有一个目的，且要有效的完成目标。</li>
<li>BSD Sun公司发展的Unix版本</li>
<li>System V 第七版，第一次可以在x86架构计算机上运行Unix</li>
</ul>
</li>
<li><p><strong><code>GNU计划 Richard Mathew Stallman</code></strong></p>
<ul>
<li>创建一个自由、开放的Unix操作系统</li>
<li>GNU C Compiler（gcc）</li>
<li>GNU C library</li>
<li>BASH shell</li>
<li>通用公共许可证PGL（General Public License）：防止自由软件被别人利用成为专利软件</li>
<li>开源软件<ul>
<li>可以取得软件和源代码</li>
<li>可以自由地复制该软件</li>
<li>可以自由地修改源代码</li>
<li>可以将修改后的源代码再次发行</li>
<li>你应该将你修改的程序码回馈社群<ul>
<li>不能将GPL授权的自由软件，修改后取消GPL授权</li>
<li>不能单纯地贩卖自由软件</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Linux核心版本号</p>
</li>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3.10.0-123.e17.x86_64</span><br><span class="line">主版本.次版本.释出版本-修改版本</span><br></pre></td></tr></table></figure>
<p><code>uname -r</code>查阅Linux核心版本</p>
</li>
<li><p>RPM软件管理：Red Hat, Fedora, SuSE</p>
</li>
<li><p>dpkg软件管理：Debian, Ubuntu, B2D</p>
</li>
<li><p>X window system ：Linux窗口套件</p>
</li>
<li><p>Tarball ：源代码</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">计算机基础（http://www.study-area.org/compu/compu.htm）</span><br><span class="line">网络基础（http://www.study-area.org/network/network.htm）</span><br><span class="line">请推荐有关网络的:(看完私房菜之后)http://linux.vbird.org/linux_basic/0120howtolinux/0120howtolinux_1.php</span><br></pre></td></tr></table></figure>
<ul>
<li>Linux FAQ:</li>
<li>Linux的文件数据位置<code>/usr/share/doc</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CLDP中文文件计划 http://www.linux.org.tw/CLDP/ </span><br><span class="line">The	Linux Documentation Project:http://www.tldp.org/</span><br></pre></td></tr></table></figure>
<ul>
<li>log文件位置<code>/var/log/</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Red Hat的硬件支持：https://hardware.redhat.com/?pagename=hcl</span><br><span class="line">Open SuSE的硬件支持:http://en.opensuse.org/Hardware?LANG=en_UK Linux</span><br><span class="line">对笔记本电脑的支持：http://www.linux-laptop.net/</span><br><span class="line">Linux对打印机的支持：http://www.openprinting.org/</span><br><span class="line">Linux硬件支持的中文 HowTo：http://www.linux.org.tw/CLDP/HOWTO/hardware.html#hardware</span><br></pre></td></tr></table></figure>
<h4 id="第二章-主机规划与磁盘分区"><a href="#第二章-主机规划与磁盘分区" class="headerlink" title="第二章 主机规划与磁盘分区"></a>第二章 主机规划与磁盘分区</h4><ul>
<li>磁盘阵列（RAID）：通过硬件方法把多个磁盘整合成一个磁盘</li>
<li>看到 2.1.3 各硬件设备在Linux中的文件名</li>
</ul>
<hr>
<h3 id="2018-5-7"><a href="#2018-5-7" class="headerlink" title="2018-5-7"></a>2018-5-7</h3><ul>
<li><p>第二次看，开始吧！</p>
</li>
<li><p>CPU的架构：</p>
<ul>
<li>精简指令集 RISC : ARM</li>
<li>复杂指令集 CISC : x86</li>
</ul>
</li>
<li><p>可以用 GiB MiB 表示二进制的数据单位</p>
</li>
<li><p>不同的CPU使用不同的脚位 如 LGA1155 FCLGA1150</p>
</li>
<li><p>CPU主频不能决定CPU的运算效率，还有微指令集、架构、cache、算法的影响</p>
</li>
<li><p>DMI 2.0 ：CPU与南桥的沟通管道</p>
</li>
<li><p>如果CPU和南桥沟通速度较慢（4GT/s = 2GByte/s），插卡时要把卡尽量插在和CPU直连的插槽上</p>
</li>
<li><p>CMOS：记录主板重要参数，使用主板电池的电力</p>
</li>
<li><p>电源转换率越高，表示电源使用的电力越少</p>
</li>
<li><p>看到<a href="http://linux.vbird.org/linux_basic/0105computers.php#computer" target="_blank" rel="noopener"><em>0.4.2作业系统</em></a>，回去洗个澡看看番放松一下吧。。下次安排在星期天！</p>
</li>
</ul>
<hr>
<h3 id="2018-4-26"><a href="#2018-4-26" class="headerlink" title="2018-4-26"></a>2018-4-26</h3><ul>
<li>终于开了头<h4 id="第零章，计算机概论。"><a href="#第零章，计算机概论。" class="headerlink" title="第零章，计算机概论。"></a>第零章，计算机概论。</h4></li>
<li>翻译成简中看舒服多了</li>
<li>缩放比例125%</li>
</ul>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Linux/" rel="tag"># Linux</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/08/28/2018-4-10-kalitools-sqlmap/" rel="next" title="KaliTools-nmap">
                <i class="fa fa-chevron-left"></i> KaliTools-nmap
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/08/28/2017-12-8-kalitools-sqlmap/" rel="prev" title="KaliTools-sqlmap">
                KaliTools-sqlmap <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.jpeg"
                alt="Xu" />
            
              <p class="site-author-name" itemprop="name">Xu</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">27</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">9</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/captainxx" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:jakobzcooper@gmail.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#鸟哥的Linux私房菜——学习笔记"><span class="nav-number">1.</span> <span class="nav-text">鸟哥的Linux私房菜——学习笔记</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2018-8-13"><span class="nav-number">1.1.</span> <span class="nav-text">2018-8-13</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#第二十二章-软件安装RPM-SRPM-YUM"><span class="nav-number">1.1.1.</span> <span class="nav-text">第二十二章 软件安装RPM SRPM, YUM</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2018-8-8"><span class="nav-number">1.2.</span> <span class="nav-text">2018-8-8</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2018-8-7"><span class="nav-number">1.3.</span> <span class="nav-text">2018-8-7</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#第二十一章-软件安装：源码与Tarball"><span class="nav-number">1.3.1.</span> <span class="nav-text">第二十一章 软件安装：源码与Tarball</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2018-8-6"><span class="nav-number">1.4.</span> <span class="nav-text">2018-8-6</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#第二十章-基础系统设置与备份策略"><span class="nav-number">1.4.1.</span> <span class="nav-text">第二十章 基础系统设置与备份策略</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2018-8-2"><span class="nav-number">1.5.</span> <span class="nav-text">2018-8-2</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2018-8-1"><span class="nav-number">1.6.</span> <span class="nav-text">2018-8-1</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#第十九章-开机流程、模组管理与loader"><span class="nav-number">1.6.1.</span> <span class="nav-text">第十九章 开机流程、模组管理与loader</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2018-7-31"><span class="nav-number">1.7.</span> <span class="nav-text">2018-7-31</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#第十七章-认识系统服务（daemons）"><span class="nav-number">1.7.1.</span> <span class="nav-text">第十七章 认识系统服务（daemons）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#第十八章-认识与分析登录档"><span class="nav-number">1.7.2.</span> <span class="nav-text">第十八章 认识与分析登录档</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2018-7-30"><span class="nav-number">1.8.</span> <span class="nav-text">2018-7-30</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#程序管理与SELinux初探"><span class="nav-number">1.8.1.</span> <span class="nav-text">程序管理与SELinux初探</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2018-7-28"><span class="nav-number">1.9.</span> <span class="nav-text">2018-7-28</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2018-7-27"><span class="nav-number">1.10.</span> <span class="nav-text">2018-7-27</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#第十五章-例行性工作-crontab"><span class="nav-number">1.10.1.</span> <span class="nav-text">第十五章 例行性工作 crontab</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2018-7-26"><span class="nav-number">1.11.</span> <span class="nav-text">2018-7-26</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#第十四章-磁碟配额-Quota-与进阶文件系统管理"><span class="nav-number">1.11.1.</span> <span class="nav-text">第十四章 磁碟配额(Quota)与进阶文件系统管理</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2018-7-25"><span class="nav-number">1.12.</span> <span class="nav-text">2018-7-25</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2018-7-24"><span class="nav-number">1.13.</span> <span class="nav-text">2018-7-24</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#第十三章-Linux账号管理与ACL权限设置"><span class="nav-number">1.13.1.</span> <span class="nav-text">第十三章 Linux账号管理与ACL权限设置</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2018-7-23"><span class="nav-number">1.14.</span> <span class="nav-text">2018-7-23</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#第十二章-学习Shell-Scripts"><span class="nav-number">1.14.1.</span> <span class="nav-text">第十二章 学习Shell Scripts</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2018-7-21"><span class="nav-number">1.15.</span> <span class="nav-text">2018-7-21</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#第十一章-正则表达式和文件格式化处理"><span class="nav-number">1.15.1.</span> <span class="nav-text">第十一章 正则表达式和文件格式化处理</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2018-7-20"><span class="nav-number">1.16.</span> <span class="nav-text">2018-7-20</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2018-7-19"><span class="nav-number">1.17.</span> <span class="nav-text">2018-7-19</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#第九章-vim编辑器！"><span class="nav-number">1.17.1.</span> <span class="nav-text">第九章 vim编辑器！</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#第十章-认识与学习BASH"><span class="nav-number">1.17.2.</span> <span class="nav-text">第十章 认识与学习BASH</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2018-7-18"><span class="nav-number">1.18.</span> <span class="nav-text">2018-7-18</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#第七章-Linux磁盘与文件系统管理"><span class="nav-number">1.18.1.</span> <span class="nav-text">第七章 Linux磁盘与文件系统管理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#第八章-文件与文件系统的压缩、打包与备份"><span class="nav-number">1.18.2.</span> <span class="nav-text">第八章 文件与文件系统的压缩、打包与备份</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2018-7-17"><span class="nav-number">1.19.</span> <span class="nav-text">2018-7-17</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#第六章-Linux文件与目录管理"><span class="nav-number">1.19.1.</span> <span class="nav-text">第六章 Linux文件与目录管理</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2018-7-16"><span class="nav-number">1.20.</span> <span class="nav-text">2018-7-16</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2018-7-15"><span class="nav-number">1.21.</span> <span class="nav-text">2018-7-15</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#第四章-首次登录与线上求助"><span class="nav-number">1.21.1.</span> <span class="nav-text">第四章 首次登录与线上求助</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#第五章-Linux的文件权限与目录配置"><span class="nav-number">1.21.2.</span> <span class="nav-text">第五章 Linux的文件权限与目录配置</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2018-7-14"><span class="nav-number">1.22.</span> <span class="nav-text">2018-7-14</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#第三章-安装CentOS-7-x"><span class="nav-number">1.22.1.</span> <span class="nav-text">第三章 安装CentOS 7.x</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2018-7-13"><span class="nav-number">1.23.</span> <span class="nav-text">2018-7-13</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#第一章-Linux是什么与如何学习"><span class="nav-number">1.23.1.</span> <span class="nav-text">第一章 Linux是什么与如何学习</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#第二章-主机规划与磁盘分区"><span class="nav-number">1.23.2.</span> <span class="nav-text">第二章 主机规划与磁盘分区</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2018-5-7"><span class="nav-number">1.24.</span> <span class="nav-text">2018-5-7</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2018-4-26"><span class="nav-number">1.25.</span> <span class="nav-text">2018-4-26</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#第零章，计算机概论。"><span class="nav-number">1.25.1.</span> <span class="nav-text">第零章，计算机概论。</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Xu</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动
  <i class="fa fa-user-md"></i><span id="busuanzi_container_site_uv">
  本站访客数:<span id="busuanzi_value_site_uv"></span>
  </span>
  </div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  

</body>
</html>
